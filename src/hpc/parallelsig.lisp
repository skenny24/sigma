;; Copyright (c) 1987--2015 LispWorks Ltd. All rights reserved.

;(load "aggregated.lisp")

;(defconstant dataset-path (merge-pathnames "data/" *sigmahome*))

; -----------------------------------------------------------
; Constants

; Symbol to be used at beginning of a list defining a filter
(defconstant filter-symbol ':filter)

; Symbol to be used at beginning fo a list defining a not-equal test
(defconstant not-equal-symbol '<>)

; Functional infinity for use in episodic memory and other things
; Needs to be no more than seven digits because when add epsilon it
; becomes a floating point number with only seven significant digits
; Slop probably could be just 1
(defconstant infinity 8888888)

; Maximum time allowed
(defconstant max-time 999999)

; Maximum state allowed
(defconstant max-state 100)

; Maximum continuous value allowed in types
(defconstant continuous-max 1000.0)

; Arguments for positive and negative elements
(defconstant boolean-true 'true)
(defconstant boolean-false 'false)
(defconstant sense-positive 1)
(defconstant sense-negative 0)

(defconstant negation-symbol '-) ; Define negation symbol
(defconstant best-symbol '!) ; Unique variable for that actions put best choice into WM
(defconstant distribution-symbol '%) ; Unique variable for that actions put distribution into WM
(defconstant expected-symbol '$) ; Unique variable for actions that put expected value into WM
(defconstant prob-match-symbol '=) ; Unique variable for actions that choose by probability matching
(defconstant exponential-symbol '^) ; Unique variable for actions that exponentially transform their distribution into WM

; Symbol of interruption
(defconstant interrupt-symbol '<***interrupted***>)

; Symbol of halt
(defconstant halt-symbol '<***halted***>)

; Suffix used for predicates in diachronic prediction
(defconstant prediction-suffix '*next)

; Suffice used for predicates in episodic learning
(defconstant episodic-suffix '*episodic)

; Specify temporal predicate name
(defconstant temporal-predicate-name 'time)

; Concat a list of symbols, strings and numbers into a new symbol
; When dashes is true, places a - between them
(defun concat-symbols (symbols &optional dashes)
  (let (string-l)
    (do ((symbol-l symbols (cdr symbol-l)))
        ((null symbol-l))
      (setq string-l (cons (if (symbolp (car symbol-l))
                               (symbol-name (car symbol-l))
                             (if (numberp (car symbol-l))
                                 (format nil "~S" (car symbol-l))
                               (car symbol-l)))
                           string-l))
      (when (and dashes (not (null (cdr symbol-l))))
        (setq string-l (cons '"-" string-l)))
      )
    (intern (apply #'concatenate (cons 'string (reverse string-l))))
    )
  )

; Specify (open-world) temporal predicate name for episodic memory
(defvar temporal-predicate-name-episodic (concat-symbols (list temporal-predicate-name episodic-suffix)))
;(defconstant temporal-predicate-name-episodic 'tpne) DEFCONST not working in PKG


; Specify halt predicate name
(defconstant halt-predicate-name 'halt)

; Indices into the nodes and contents links of arrays
; The variable node is always first and the factor node second
(defconstant var-index 0)
(defconstant fact-index 1)

; Indices of the various queues
(defconstant depth-queues-index 0)
(defconstant other-queue-index 1)

; Symbol to use in marking which attribute is the category
(defconstant category-symbol '*)

; System predicate names that shouldn't be created by users
(defconstant system-predicates '(detect-impasses evaluate-operator halt impasse selected state time))

; -----------------------------------------------------------
; Bipartite parameters and variables
;;; Variables
(defvar bp-nodes)
(defvar bp-graph)
(defvar *bp-node-stream*)
(defvar *nodes-depth* 3)
(defvar *main-pinboard*)
(defvar *selected-node* nil)
(defvar display-subgraph nil)
(defvar *node-stream*) ; Stream for printing information about nodes when they are clicked on
(defvar graph-alpha t) ; Whether or not to include the alpha network (before the alpha memory) in the graph

; -----------------------------------------------------------
; Parameters

; Convert a defvar name into a defparameter name
(defun parameter-name (variable-name)
  (concat-symbols `(* ,variable-name *))
  )

; List of all global parameters (to be created dynamically)
; A list of dotted pairs, with variable name followed by parameter name
(defparameter global-parameters nil)

; List of parameters not to reset automatically (overrides normal resetting)
(defparameter parameter-override-reset nil)

; Define a global parameter
(defun parameter (variable-name initial-value)
  (let ((parameter-name (parameter-name variable-name)))
    (eval (list 'defparameter parameter-name (list 'quote initial-value)))
    (eval `(defvar ,variable-name))
    (push (cons variable-name parameter-name) global-parameters)
    initial-value)
  )

; Whether to use the new bipartite graph display
(parameter 'bipartite-graph-display t)

; Set to true if new constants will be introduced in the evidence
(parameter 'extend-type-constants-by-evidence nil)

; Determine whether to detect impasses
(parameter 'detect-impasses nil)

; Maximum messages to process at a call to process-message-queue
(parameter 'max-messages 10000)
; When non-null, set max-messages to this times number of links in graph
(parameter 'max-messages-links 20)

; Trace messages
(parameter 'trace-messages nil)

; Trace trials
(parameter 'trace-trials t)

; Track distribution of messages per parallel cycle
(parameter 'cycle-message-counts nil)

; Whether a trace of messages should be symbolic
(parameter 'symbolic-trace t)

; Whether to trace number of decisions
(parameter 'trace-decisions t)

; Whether to trace number of parallel elaboration cycles
(parameter 'trace-cycles t)
 
; Whether to print out elements that are (e= to) zero in a symbolic trace
(parameter 'trace-empty nil)
; Whether to print out elements that are (e= to) one in a symbolic trace
; Just modified for printing negated changes, which only matter when 0
(parameter 'trace-full t)

; Temperature variables for Boltzmann selection
;(parameter 'default-temperature 1/5)
(defvar default-temperature 1/5) ; should fix parameter function to add properly or extract from global-params
(parameter 'temperature-minimum 1/60)

; Need this global variable and function here to define parameter
; Number of trials (each of multiple decisions) that have been run
(defvar trial-count 0)
; Standard temperature-schedule
(defun log-trials nil
  (/ default-temperature (log (+ trial-count 1)))
  )
; Function to call to update temperature each trial
(parameter 'temperature-schedule #'log-trials)

; If true, learn for open-world predicates as well as closed-world ones
(parameter 'learn-open nil)

; If true, learn for conditional functions that have no normal variable
(parameter 'learn-no-normal nil)

; Whether to print regions on separate lines
(parameter 'print-regions-on-separate-lines nil)

; When true, use a relative rather than an absolute epsilon in equality tests
(parameter 'use-relative-epsilon t)

; Center discrete numeric (unit) regions on the integer (rather than starting them on the integer)
(parameter 'center-discrete-numeric-on-integer nil)

; Whether to run with multiple agents
(parameter 'multiagent nil)

; Whether to use automatic condition reordering
(parameter 'automatically-reorder-conditions t)

; Learn function factors via gradient descent
(parameter 'learn-via-gradient-descent nil)

; Whether to use new form of subtractive normalization in gradient-descent learning
(parameter 'gdl-subtractive-normalization t)

; Divide gradient by function-message product
; Seems to be required for correctness, but is causing problems
(parameter 'gdl-divide 'newer)

; Trace gradient-descent learning (T, NIL, or a list of node numbers, node names, or conditional names)
(parameter 'trace-gdl nil)

; Subtract average from gradient before using
(parameter 'gradient-subtract-average t)

; Use exponential-product form of gradient
; When do this, should set gradient-subtract-average to NIL and ensure that gdl-divide is NEWER
(parameter 'exponential-product-gradient nil)

; Send feedback messages to function factor nodes rather than optimizing them out
(parameter 'feedback-to-functions t)

; Learning rate for gradient ascent
(parameter 'learning-rate .05)

; Whether to use an adaptive learning rate, rather than fixed parameter
(parameter 'adaptive-learning-rate nil)

; Whether to use an adaptive learning rate, rather than fixed parameter
(parameter 'learning-rate-fraction-of-smoothing-parameter nil)

; Minimum value created in a learned function
(parameter 'smoothing-parameter .000001)

; Whether to do adaptive smoothing, rather than using the fixed parameter
(parameter 'adaptive-smoothing t)

; Maximum increment used in gradient descent learning (if specified)
(parameter 'max-gdl-increment 1)

; Predict results of diachronic activity (results of operators/actions)
(parameter 'diachronic-prediction nil)

; Determine if should do episodic learning
; Can be t, open, closed or nil
(parameter 'episodic-learning nil)

; Determine if should automatically create conditionals for action modeling (aka transition function learning)
(parameter 'automatic-action-models nil)

; Determine if should automatically create conditionals for perception modeling (including maps)
(parameter 'automatic-perception-models nil)

; Determine if should automatically create predicates and conditionals for reinforcement learning
(parameter 'automatic-reinforcement-learning nil)

; What kind of selection to perform among best operators: 'first, 'random
(parameter 'operator-best-select 'random)

; What kind of selection to perform among best values for all other unique variables: 'first, 'random
(parameter 'non-operator-best-select 'random)

; Determine if trace episodic learning
(parameter 'trace-el nil)

; When true, ensure that universal variables don't get non-zero weights in region functions
(parameter 'unique-weights-only t)

; Determine whether to make condition beta networks one direction
(parameter 'one-way-c-a-betas t)

; Determine whether to only reinitialize messages at a node when no WM or CFF factor node
; upon which it depends has changed
(parameter 'save-message-state t)

; Track messages across decisions
(parameter 'track-graph-messages nil)

; Copy state automatically on impasses
; Presently only works in single agent mode
(parameter 'impasse-copy-state nil)

; Trace performance
(parameter 'trace-performance t)

; Debug init-node-descendants-no-parents
; Other values are 'summary (actually anything other than nil or 'all) and 'all
(parameter 'debug-init-descendants nil)

; Debug descendant/message-saving code
(parameter 'debug-descendants nil)

; Trace preferences existing prior to decisions
(parameter 'trace-preferences nil)

; Trace perception
(parameter 'trace-perception nil)

; Trace depths of links on messages
(parameter 'trace-link-depths nil)

; Trace queues into which new messages are being placed
(parameter 'trace-queue nil)

; Whether to always use max for summarizing out action/operator variables
(parameter 'always-max-operators nil)

; Default value for use in creating function factors
(parameter 'function-default 0)

; If true, treat open-world actions like latter half of condacts, otherwise like closed-world actions
(parameter 'open-actions-like-condacts nil)

; If true, connect open-world WMFN directly to WMVN for open-world conditions
(parameter 'open-conditions-like-condacts nil)

; If true, pad filter outputs with 1s for messages going through condacts away from WM
; This is already automatically done for messages going to WM
(parameter 'all-condact-filters-pad-1 nil)

; Threshold that defines the number of connections required to be considered as a dense connection. 
; If the number of connections is bigger than this threshold, a subgraph constructed for efficient processing (that decreases the number of multiplications required) 
(parameter 'threshold-for-dense-connection 5)

; Minimum size of a field for a PLM array print
(parameter 'minimal-parray-field 14)

; Default to printing trace information to listener
(defvar trace-stream)

; Initialization variables for regression testing
(defparameter from-regression nil)
(defvar regression-interface nil)


; Initialization variables for parallel implementation
(defparameter from-parallel nil)
;(defvar *parallel-interface* nil)

;Stream where the information about the output will be displayed
(defparameter *info-stream* t)
(defvar info-stream *info-stream*)

; Base-level state at which processing starts in reflective hierarchy
(parameter 'base-level-state 0)

; Whether to latch evidence in WM VN nodes, implying that products with evidence 1s yields 1
(parameter 'latch-evidence t)

; If serial, use message queue to process one message at a time
; If parallel, perform elaboration cycles in which messages are processed for all links before moving on
(parameter 'message-protocol 'serial)

; Whether to trace wm-driven
(parameter 'trace-wm-driven nil)

; Default to integral in summary-product, rather than maximize
(parameter 'default-integral t)

; Default to nil for tracing product, summarize and normalize
(parameter 'trace-combine nil)
(parameter 'trace-summarize nil)
(parameter 'trace-transform nil)
(parameter 'trace-average nil)

; Whether to trace affine computations
(parameter 'trace-affine nil)

; Whether to trace impasses
(parameter 'trace-impasses t)

; Default to nil tracing for maximals
(parameter 'trace-maximals nil)

; Constant for testing epsilon equality of real numbers
(parameter 'epsilon .0000001)
; Constant used for delimiting a maximal region at the end of an interval
(parameter 'epsilon2 .0001)

; Constant added in at the FAN node for open-world predicates
; Replaces the constant evidence that used to be put explicitly into open-world WMs when there were actions
(parameter 'fan-constant 1e-10)

; Trace the process of deciding what changes to make in WM
(parameter 'trace-wm-changes nil)
; Trace addition and deletion of states
(parameter 'trace-states t)

; Variables for tracing message generation times
(parameter 'trace-message-times nil)

; Default maximum number of (parallel) elaboration cycles per decision
(parameter 'max-elaboration-cycles 50)

; Maximum number of decisions to run if no number is specified
(parameter 'max-decisions 500)

; Determine whether to explicitly specify function variable names
(parameter 'specify-function-variable-names t)

; Number of categories to use in unsupervised learning
(parameter 'unsup-categories 5)

; Maximum number of items in the final region along a discrete dimension to list explicitly
(parameter 'max-final-discrete 10)

; Extent of field beyond length of largest label
(parameter 'field-beyond-label 3)

; Extent of range field beyond twice length of largest label
(parameter 'range-field-beyond-label 3)

; Break when a message specified by a pair of node numbers is non-empty 
; List of lists of pairs of node numbers
(parameter 'break-on-positive-messages nil)

; Discount messages from WM through VAN to FAN
(parameter 'discount-wm t)

; Discount factor to use for WM through VAN to FAN
(parameter 'wm-discount-factor .01)

; Whether to create WMFN nodes for open-world predicates
(parameter 'open-world-wmfns nil)

; Arousal level
(parameter 'arousal nil)

; Integrate over universal variables if there are any unique variables in function
(parameter 'integrate-universal-in-unique nil)

; Whether to automatically calculate surprise over learned functions
(parameter 'compute-surprise nil)

; Whether to automatically calculate progress over goals
(parameter 'compute-progress nil)

; Whether to automatically calculate attention
(parameter 'compute-attention nil)

; Whether to trace attentional processing
(parameter 'trace-attention nil)

; Maximum span of a symbolic region before use print-plm rather than parray in print-smart
(parameter 'max-span-pa 10)

; Max density fraction of PLM for which use regions in arrays within print-smart
(parameter 'max-fraction-pa-regions .5)

;(parameter 'sparse-product t)

;(parameter 'sparse-product-threshold 2)

; The following are special, as they don't get reset by reset-parameters

; Whether to reset-parameters during init
(defparameter reset-parameters-in-init t)

; Whether to track time
(defparameter track-time t)

(defun reset-parameters nil
  (dolist (gp global-parameters)
    (unless (member (car gp) parameter-override-reset)
      (eval `(setq ,(car gp) ,(cdr gp)))
      )
)
  (setq trace-stream t))

; -----------------------------------------------------------
; Global variables

; Graph
(defvar cg)

; Bottom state
(defvar bottom-state)

; Track number of messages that have been processed
(defvar message-count 0)

; Track number of decisions that have been made
(defvar decision-count 0)

; Temperature variables for Boltzmann selection
(defvar temperature default-temperature)
(defvar one-over-temperature (/ 1 temperature))
  
(defvar epsilon21) ; Used whether multiple epsilon2 regions

; Relative epsilon (gets refined as types are defined)
(defvar relative-epsilon)

; Global variable for smooth-plm subregions to be zeroed out
(defvar smooth-plm-subthreshold-regions)

; Messages tracked across across decisions
(defvar global-graph-messages nil)

; Value is NIL after init until first run
(defvar have-run nil)

; Forms to execute before run and before and after a decision and a trial (and before all trials and for perception and action)

(defvar perceive-list nil)
; Execute perceive-list forms
(defun perceive-list nil
  (mapc #'eval perceive-list)
  t)

(defvar action-list nil)
; Execute action-list forms
(defun action-list nil
  (mapc #'eval action-list)
  t)

(defvar pre-run nil)
; Execute pre-run forms
(defun pre-run nil
  (mapc #'eval pre-run)
  t)

(defvar post-run nil)
; Execute post-run forms
(defun post-run nil
  (mapc #'eval post-run)
  t)

(defvar pre-d nil)
; Execute pre-d forms
(defun pre-d nil
  (mapc #'eval pre-d)
  t)

(defvar post-d nil)
; Execute post-d forms
(defun post-d nil
  (mapc #'eval post-d)
  t)

(defvar pre-t nil)
; Execute pre-t forms
(defun pre-t nil
  (mapc #'eval pre-t)
  t)

(defvar post-t nil)
; Execute post-t forms
(defun post-t nil
  (mapc #'eval post-t)
  t)

(defvar post-automatic nil)
; Execute post-automatic forms
(defun post-automatic nil
  (mapc #'eval post-automatic)
  t)

(defvar pre-ts nil)
; Execute pre-ts forms
(defun pre-ts nil
  (mapc #'eval pre-ts)
  t)

; Trace of performance
(defvar global-decision-statistics nil)

; Global variable for tracking which parts of the selected predicate need to be wiped after
; a change to a unique predicate that invovles the state
(defvar selected-operator-wipe)

; Variables for tracing message generation times
(defvar number-of-messages 0)
(defvar sum-of-message-times 0)
(defvar maximum-message-time 0)

; Whether should add a new state/subgoal during the current decision
(defvar add-new-state)

; Which state to flush everything below, if any
(defvar delete-lower-states)

; Global variable for impasse regions
(defvar impasse-regions)

; List of attributes (and category name) in data set
(defvar data-set-attributes nil)

; Category name in data set
(defvar data-set-category nil)

; List of conditional names for which shouldn't learn
(defvar do-not-learn nil)

; Temporarily turn off error detection for defining system predicates
(defvar define-system-predicate nil)

; Constant for use in computing attention-multiplier (will get set in init)
(defvar attention-exponential-numerator 0)

; -----------------------------------------------------------
; Structures

; A graph consists of a name, lists of predicates nodes and links,
; a list of conditional patterns, an association lists of avars and memories,
; the queues of messages to send
; agents is number of agents
(defstruct graph types predicates state-predicates nodes links conditionals pattern-vars queues node-count last-node graph changes positive-preferences negative-preferences depth agents operator-type-name initialized operator-predicates selected-predicate node-vector detect-impasses-predicate goals-set goal-list action-predicate perception-predicate agent-type surprise-predicates surprise-distribution-predicate surprise-predicate attention-predicates attention-distribution-predicate attention-predicate progress-predicates difference-predicates difference-distribution-predicate difference-predicate progress-distribution-predicate progress-predicate predicate-type)

; A queue is a list with pointers to a head element and the sublist containing last element (tail)
; to facilitate adding (to the back) and removing (from the front) elements 
; The head element remains, and the first content is really the next element
(defstruct queue head tail)

; A node (either variable or factor) consists of a name,
; a list of links, a type (variable or factor),
; a subtype (alpha, beta, delta, etc.) that isn't used during processing, only during printout
; arguments is only used for WM variable nodes of condacts, to track the argument list for automated sharing
; a function (a PLM or a special symbol if factor node)
; an inverse-function (the name of the inverse function, if any, for a filter node)
; a vector of variables that are part of the node,
; If the node is a factor, factor-steps defines the sequence of operations to be performed
; This is one place at least where a hierarchical class system would help in specializing two types of nodes
; Evidence t means that a factor node is constant and that a variable node only is to receive input from
; its constant companion
; Action determines if this is a special action node for combining shared actions
; Descendants is a list of descendants
; Descendant-links is a list of descendant links
; Region-pad is the pad to use in an affine node
; Normal is the dimension number for the variable to normalize over during learning, if any
; Conditional-name gives the conditional name for conditional function nodes
; Linear-filter is T if the node is a filter and at least one dimension has a coefficient
; If integral is T then unique varibles in this node are integrated out, otherwise they are maxed
; Changes is number of itmes a conditional factor function has been changed at node (if any)
; Shared-functions is a list of other (CFF) nodes that share the same function
; Variables-same is list of adjacent variable node names for a beta factor with the same variables (in the same order)
; vector if the node performs vector normalizations 
;;Deprecated normalize t,v, or nil: if t, l1 normalization. if v, l2 (or vector) normalization
(defstruct node name type subtype subsubtype object evidence variables factor-steps function inverse-function links number action descendants descendant-links region-pad normal conditional-name linear-filter pattern-type exponential normalize integral predicate learning-rate smoothing-parameter restriction changes shared-functions function-name unique-for-gdl wmvn beta-non-full assumption vector surprise-predicate)

; A factor-step specifies one step of the processing within a factor node
; The type of step can be product or integral
; If type is product, the argument is the link to be multiplied times the current running value
; If type is integral, the argument is a variable to integrate out
(defstruct factor-step type argument)

; Structure used to define connections for a beta factor
(defstruct beta-memories alpha old-beta new-beta)

; A descendant is a node and a set of parents by which it is descended from some other node
(defstruct descendant node parents)

; A descendant-link is a link and a set of parents by which it is descended from some other node
(defstruct descendant-link link direction from to)

; A link consists of a point to the graph it is part of,
; an array of two nodes, an array of two messages (contents),
; an array of two numbers corresponding to the depths of the link in those directions
; an array of two numbers corresponding to the loop-depths of the link in those directions
; an array of two numbers corresponding to when message last initialized, and an array of two incoming
; The first message goes from the first node, and the second from the second
; The first node is always the variable node
; If the contents is nil, no message is sent in that direction
; Incoming specifies whether there is an incoming message in parallel mode
; If there is a T in the 0th/Variable cell that means there is an incoming message from (NOT to) the variable node
; map specifies how variable node variables map onto variables in factor function
; counts is an array of two numbers for messages sent in each direction
; Stale keeps track, for the messages in each direction, of whether the message needs to be recomputed when sent (because an incoming message has changed)
(defstruct link map nodes contents depths loop-depths inits prequeue incoming in out counts stale variables-same)

; A message is a link plus an index into an element of the contents array
; and node array (node message is from)
(defstruct message index link wm-driven)

; A map is a vector of size equal to the number of variables in the corresponding variable node
; vfactor gives the factor node variable index from a variable node variable index
; This earlier also had vpoint and fpoint, as defined below, but they have never been used
; vpoint gives the same mapping but for use in indexing a point (with constant in 0 position) from variable indices
; fpoint sorts the pvf mapping for use in indexing a point from factor indices
; Have added fvar, which maps from summarized product in factor node back to variable node
(defstruct smap vfactor fvar omitted)

; A conditional consists of a name, lists of conditions, condacts and actions, and a function
; Function-variable-names specifies the variable names (and ordering) used in the function
; Normal is the variable name to normalize over during gradient-descent learning, if any
; If map is true, then use max rather than integral for summarization at factor nodes within this conditional
(defstruct conditional name conditions condacts actions variables function-variable-names function condition-later-variable-names condact-later-variable-names action-later-variable-names last-memory last-condition-memory alpha-memories function-node episodic normal function-default shared-action-beta map learning-rate smoothing-parameter reordered-conditions)

; Each wme must now be an instance of a predicate, taking the place of attributes
; arguments is a list of sublists.  The car of a sublist is the argument name, while
; the cadr is the name of a type, and the caddr (if exists) is specifies form of unique variable
; wm is the working memory factor for this predicate
; em is the function factor for this predicate (if it has one)
; em-predicate is the predicate used for this predicates episodic memory, if there is one
; persistent is whether the contents of WM are persistent
; predict is the predicate for diachronic prediction of current predicate
; exponential is if WMFN should transform (the constant part of) its output messages exponentially
; assign-ids is the function to be used in assigning ids to alternatives in predicate if it is an operator
; no-normalization, if T, overides default normalization coming out of WM VN nodes
; unique is the name of the unique argument name, and nil if a multiple predicate
; select is nil, best, prob-match, boltzmann or expected
; cumulative determines whether persistent
; perception is the factor node where perceptions go
; prediction is the predicate being predicted if this is a prediction predicate
; predicted is the original predicate that this predicate is used to predict, if there is one
; perception-temp-mem is temporary memory for aggregating the perceptions before putting them into the factor node
; vector is whether this predicate represents a vector 
(defstruct predicate name world arguments wm em em-predicate persistent predict exponential assign-ids operators first-operator id-contents outgoing-vn incoming-vn fan no-normalize unique select replace agent-arg-index perception prediction perception-temp-mem prediction-link wm-variables function learning-rate smoothing-parameter function-variable-names function-node function-default condact-conditionals unique-for-gdl episodic no-models goal-predicate progress-predicate action-function perception-function vector surprise-predicate automated-perception no-surprise attention-predicate goal difference-predicate)

(defconstant vector-symbol '[]) ; Unique variable for that actions put vector into WM 

; Is symbol vector
(defun vector-argument (a) 
  (eq (argument-symbol a) vector-symbol)
  )
; Determine what form of selection argument specifies
(defun argument-vector (a) 
  (vector-argument a)
  )

; Take the sqrt of the function (only for piecewise-constants
(defun sqrt-function (f r &optional piecewise-constant) 
  r ; dummy so no warning about r not being used
  (if piecewise-constant
      (sqrt f)
    f)
  )


; Working memory, goal memory, and all messages should be PLMs
; A PLM is an N dimensional array of regions
; Active is a Boolean vector saying which variables are active
; Variables is a vector of variables in the PLM
; Array should point to the array of regions
; Slices is a vector of length rank, each with an ordered list of slices for the dimension
(defstruct plm rank active variables array slices removed-unneeded-slices piecewise-constant)

; A region tells you everything you need to know about an N dimensional rectangle of a PLM
; This includes an N dimensional linear function and pointers to adjacent regions
; Dimensions should be a vector of dimension structures
; As opposed to earlier versions, the constant is separated from the dimensions
; left and right are used as temporary storage when the region is bisected until
; the new regions are linked directly into the PLM (in which case old region goes away)
; Evidence specifies whether evidence was provided for the region
; Exponential is true if the actual value is e to the function
(defstruct region constant dimensions maximals evidence exponential bad)

; A dimension provides the information about one direction along a region
; This includes which regions come before and after it along a direction
; Min-slice and max-slice are slices that bound the region along this direction
; Weight gives the coefficient for this dimension/variable in the linear function
(defstruct dimension min-slice max-slice weight discrete)

; A slice is a simple structure just including the location of the slice
(defstruct slice location index)

; Each variable will now be of a type
; Types can be symbolic (numeric false and discrete true), integral (numeric true and discrete true)
; or continuous (numeric true and discrete false).  Max is always an open end for an interval
; For non-numeric variables, constants is a list of values, min is at 0 and max is at #constants+1
; Unit-width is width of the smallest region
(defstruct stype name numeric discrete constants min max span)

; These are the variables used in PLMs and nodes
; unique is T if a unique variable (not multiple)
; select is nil, best or expected
(defstruct svariable name type unique select)

; Structure for affine transformation of PLM variable
; From is the predicate argument being transformed
; To is the predicate argument where the transforms end up
; Coefficent is multiplied times "from" slices
; Offset is added to "from" slices
; Pad, if provided, is how to pad PLM when new regions are introduced
; When apply-coefficient-to-offset is true, apply coefficient to offset as well as to base variable
(defstruct affine from to coefficient offset pad apply-coefficient-to-offset not-equal)

; Trace performance
(defstruct decision-statistics number messages run-time decision-time learn-time init-time)

; A pattern/alpha variable data structure
; Includes name of the pattern/alpha variable, the wm-wmemory variable node,
; A list of the variable names in the node
(defstruct pattern-variable name wm-memory variable-names)

; -----------------------------------------------------------
; Initialization functions

; Conditionals
; ------------

; Initialize a conditional in a graph
(defun conditional (name &rest args)
  (let (nc)
    (setq nc (apply #'make-conditional (append (list ':name name) args)))
    (compile-conditional nc)
    (when (graph-initialized cg) ; This is a conditional added after the graph has been initialized
      (post-process-conditionals)
      )
    nc)
  )

; Find a conditional given its name
(defun conditional-from-name (name)
  (find-if #'(lambda (c) (eq name (conditional-name c))) (graph-conditionals cg))
  )

; Types (stypes)
; --------------

; Initialize a type in the current graph (cg)
(defun new-type (name &rest args)
  (when (member name (graph-types cg) :key #'stype-name)
    (error "Type ~S cannot be redefined!" name)
    )
  (let (nt)
    (setq nt (apply #'make-stype (append (list ':name name) args)))
    (cond ((not (stype-numeric nt)) ; A constant/symbolic type
           (setf (stype-discrete nt) t)
           (setf (stype-min nt) 0)
           (setf (stype-max nt) (length (stype-constants nt)))
           )
          ((and center-discrete-numeric-on-integer (stype-numeric nt) (stype-discrete nt)) ; A discrete numeric type where regions are to be centered around integers
           (setf (stype-min nt) (- (stype-min nt) 1/2))
           (setf (stype-max nt) (- (stype-max nt) 1/2))
           )
          )
    (when (< (stype-max nt) (stype-min nt))
      (error "Maximum (~S) for type ~S is less than minimum (~S)" (stype-max nt) name (stype-min nt))
      )
    (cond ((stype-discrete nt)
           (when (> (stype-max nt) infinity)
             (error "Maximum (~S) for discrete type ~S is greater than (logical) infinity (~S)" (stype-max nt) name infinity)
             )
           (when (< (stype-min nt) (- infinity))
             (error "Minimum (~S) for discrete type ~S is less than (logical) negative infinity (~S)" (stype-min nt) name (- infinity))
             )
           )
          (t
           (when (> (stype-max nt) continuous-max)
             (error "Maximum (~S) for continuous type ~S is greater than continuous max (~S)" (stype-max nt) name continuous-max)
             )
           (when (< (stype-min nt) (- continuous-max))
             (error "Minimum (~S) for continuous type ~S is less than negative continuous-max (~S)" (stype-min nt) name (- continuous-max))
             )
           )
          )
    (setf (stype-span nt) (abs (- (stype-max nt) (stype-min nt))))
    (setf (graph-types cg) (cons nt (graph-types cg)))
    ; For continuous types, determine if need to adjust relative-epsilon
    (unless (stype-discrete nt)
      (setq relative-epsilon (min relative-epsilon (* epsilon2 .1 (/ 1 (max 1 (abs (stype-min nt)) (abs (stype-max nt)))))))
      )
    nt)
  )

; Find a type from a name
(defun type-from-name (name)
  (find name (graph-types cg) :key #'stype-name))

; Find a type from a predicate and argument
(defun type-from-predicate-argument (argument predicate)
  (type-from-name (cadr (assoc argument (predicate-arguments predicate))))
  )

; Variables (svariables)
; ----------------------

; Determine if a variable is unique
(defun best-variable (v)
  (and (svariable-unique v)
       (eq (svariable-select v) 'best)
       )
  )
; Determine if a variable is expected value
(defun expected-variable (v)
  (and (svariable-unique v)
       (eq (svariable-select v) 'expected)
       )
  )
; Determine if a variable is distribution value
(defun distribution-variable (v)
  (and (svariable-unique v)
       (not (svariable-select v))
       )
  )
; Determine if a variable needs a selection (either unique or expected)
(defun selection-variable (v)
  (and (svariable-unique v)
       (svariable-select v)
       )
  )

; Determine if a variable is universal
(defun multiple-variable (v)
  (not (svariable-unique (if (listp v) (car v) v)))
)
; Determine if a variable is non-universal
(defun non-multiple-variable (v)
  (not (multiple-variable v))
  )

; Find a variable from a name
(defun variable-from-name (name variables)
  (find name variables :key #'svariable-name))

; Union of two vectors of variables
(defun union-two-variables (vs1 vs2)
  (let* ((r1 (length vs1))
         (r2 (length vs2))
         (uvs (make-array (list (+ r1 r2)) :adjustable t :fill-pointer 0)))
    (dotimes (i r1)
      (vector-push (elt vs1 i) uvs))
    (dotimes (i r2)
      (unless (find (svariable-name (elt vs2 i)) uvs :key #'svariable-name)
        (vector-push (elt vs2 i) uvs)))
    (adjust-array uvs (list (fill-pointer uvs)))
    uvs)
  )

(defun union-variables (var-vectors)
  (let ((union (car var-vectors)))
    (dolist (var-vector (cdr var-vectors))
      (setq union (union-two-variables var-vector union)))
    union)
  )

; Arguments
; ---------

; Find whether an argument is multiple within a predicate
(defun multiple-from-predicate-argument (argument predicate)
  (multiple-argument (assoc argument (predicate-arguments predicate)))
  )

; Find the position in the argument list from an argument name
(defun position-of-predicate-argument (argument predicate)
  (position argument (predicate-arguments predicate) :key #'car)
  )

; Does predicate have an argument of type operator?
(defun has-operator-argument (p)
  (dolist (arg (predicate-arguments p) nil)
    (when (eq (cadr arg) (graph-operator-type-name cg))
      (return t)
      )
    )
  )

; Define access functions for arguments
(defun argument-name (a) (car a))
(defun argument-type-name (a) (cadr a))
(defun argument-tail (a) (cddr a))
(defun argument-symbol (arg) (caddr arg))

; Is symbol unique
(defun best-argument (a)
  (eq (argument-symbol a) best-symbol)
  )
; Is symbol distribution
(defun distribution-argument (a)
  (eq (argument-symbol a) distribution-symbol)
  )
; Is symbol probability matching
(defun prob-match-argument (a)
  (eq (argument-symbol a) prob-match-symbol)
  )
; Is symbol exponential
(defun exponential-argument (a)
  (eq (argument-symbol a) exponential-symbol)
  )
; Is symbol expected
(defun expected-argument (a)
  (eq (argument-symbol a) expected-symbol)
  )
; Is symbol unique or expected
(defun selection-argument (a)
  (or (best-argument a) (expected-argument a))
  )
; Is argument multiple
(defun multiple-argument (a)
  (not (argument-tail a))
  )
; Is argument unique (not multiple)
(defun unique-argument (a)
  (argument-tail a)
  )

; Determine what form of selection argument specifies
(defun argument-select (a)
  (cond ((or (multiple-argument a)
             (distribution-argument a)
             (exponential-argument a)
             )
         nil)
        ((best-argument a) 'best)
        ((expected-argument a) 'expected)
        ((prob-match-argument a) 'prob-match)
        )
  )

; Determine if argument is state
(defun state-argument (a)
  (eq (argument-type-name a) 'state)
  )

; Predicates
; ----------

; Check whether all of the argument types in the predicate are defined
; Check that there is at most one unique argument
; Set unique and select attributes of predicate
; Check other things...
(defun check-predicate-arguments (pred)
  (let (type as agent-arg-names last-agent-arg-name state-arg-name)
    (when (eq (predicate-select pred) 'boltzman)
      (format trace-stream "Boltzman has been changed to Boltzmann in predicate ~S." (predicate-name pred))
      (setf (predicate-select pred) 'boltzmann)
          )
    (when (not (member (predicate-select pred) '(nil best prob-match boltzmann expected)))
      (error "Attempt to set selection type for predciate ~S to ~S, which is not NIL, BEST, PROB-MATCH, BOLTZMANN or EXPECTED."
             (predicate-name pred) (predicate-select pred))
      )
    (dolist (arg (predicate-arguments pred))
      ; Check whether argument type is defined
      (setq type (argument-type-name arg))
      (unless (type-from-name type)
        (error "Unknown argument type ~S in definition of predicate ~S." type (predicate-name pred))
        )
      ; Mark predicate as computing an exponential
      (when (exponential-argument arg)
        (setf (predicate-exponential pred) t)
        )
      ; Gather agent argument names in a multigent situation
      (when (and multiagent (eq (argument-type-name arg) 'agent))
        (setq agent-arg-names (cons (argument-name arg) agent-arg-names))
        )
      ; Error if predicate has more than one state argument
      (when (eq (argument-type-name arg) 'state)
        (if state-arg-name ; There already is an agent argument
            (error "Multiple state arguments in predicate ~S." (predicate-name pred))
          (setq state-arg-name (argument-name arg)))
        )
      (when (unique-argument arg)
        (setq as (argument-select arg))
        (when (and as (predicate-unique pred) (not (predicate-select pred))) ; Current argument is selection, but a previous one is unique without being selection
          (error "Mixture of selection and unique non-selection argruments found in predicate ~S." (predicate-name pred))
          )
        (when (and (predicate-select pred) ; There is already a form of selection specified
                   (unique-argument arg) ; A symbol has been specified
                   (not (eq (predicate-select pred) as)) ; The new one isn't the same as the existing one
                   )
          (error "Multiple incompatible forms of predicate selection specified in predicate ~S." (predicate-name pred))
          )
        (setf (predicate-unique pred) (adjoin (argument-name arg) (predicate-unique pred)))
        (setf (predicate-select pred) as)
        (setf (predicate-vector pred) (argument-vector arg)) 
        )
      )
    ; Print warning if multiple agent arguments and none is named AGENT
    (when agent-arg-names ; There already is an agent argument
      (if (= (length agent-arg-names) 1) ;If only one, use it
          (setf (predicate-agent-arg-index pred) (position (car agent-arg-names) (predicate-arguments pred) :key #'argument-name))
        (if (member 'agent agent-arg-names) ; If multiple, and there is one name agent, use it
            (setf (predicate-agent-arg-index pred) (position 'agent (predicate-arguments pred) :key #'argument-name))
          (progn ; Otherwise use first
            (setq last-agent-arg-name (car (last agent-arg-names)))
            (setf (predicate-agent-arg-index pred) (position last-agent-arg-name (predicate-arguments pred) :key #'argument-name))
            (format trace-stream "~&Warning: Multiple arguments of type AGENT in predicate ~S, with none being named AGENT.  The first one (~S) is therefore assumed to be primary."
                    (predicate-name pred) last-agent-arg-name)
            )))
      )
    ; Error if state predicate has no agent argument in multiagent situation
    (when (and multiagent state-arg-name (not agent-arg-names))
      (error "State predicate (~S) in multiagent domain lacks an agent argument." (predicate-name pred))
      )
    (when (and (not (predicate-persistent pred)) (predicate-select pred))
      (format trace-stream "~&Non-persistent predicates don't do selection so this has been disabled for predicate ~S." (predicate-name pred))
      (setf (predicate-select pred) nil)
      )
    (when (and (not (predicate-persistent pred)) (predicate-replace pred) (not (predicate-prediction pred)))
      (format trace-stream "~&Non-persistent predicates don't do replacement so predicate ~S has been returned to the default of cumulative." (predicate-name pred))
      (setf (predicate-replace pred) nil)
      )
    (when (and (predicate-replace pred) (predicate-select pred))
      (format trace-stream "~&Replacement doesn't make sense for selection predicates, so it has been ignored in predicate ~S." (predicate-name pred))
      (setf (predicate-replace pred) nil)
      )
    (when (and (predicate-replace pred) (predicate-perception pred) (not diachronic-prediction))
      (format trace-stream "~&Perception not (currently) allowed for replacement predicates, so it has been ignored in predicate ~S." (predicate-name pred))
      (setf (predicate-perception pred) nil)
      )
    )
  )

; Whether a predicate is universal (no unique variables)
(defun predicate-universal (pred)
  (not (predicate-unique pred))
  )

; Whether a predicate accumulates values from the WMFN and actions (not replace)
(defun predicate-cumulative (pred)
  (not (predicate-replace pred))
  )

; Convert a predicate argument into a conditional element with a variable
(defun argument-to-element (arg)
  (list (car arg) (list (car arg)))
  )

; Tests on predicate's world
(defun open-world (pred) (eq (predicate-world pred) 'open))
(defun closed-world (pred) (eq (predicate-world pred) 'closed))

; Get named predicate definition from graph
(defun predicate-from-name (name &optional dont-error)
  (let (pred)
    (setq pred (find name (graph-predicates cg) :key #'predicate-name))
    (when (and (not dont-error) (not pred))
      (error "No predicate found for name ~S in predicate-from-name." name)
      )
    pred)
  )

; Get predicate's perception node from name
(defun perception-node-from-name (name)
  (let ((pred (predicate-from-name name)))
    (unless pred
      (error "No predicate named ~S in PERCEPTION-NODE-FROM-NAME" name)
      )
    (predicate-perception pred)
    )
  )

; Replace selection argument with distribution for prediction
(defun prediction-argument (arg)
  (if (selection-argument arg)
      (list (argument-name arg) (argument-type-name arg) distribution-symbol)
    arg)
  )

(defun convert-to-wm-variable-name (name)
  (concat-symbols (list 'wm name) t)
  )

; Set up a goal (and a progress, difference and attention predicates) for a predicate
(defun goal (pred-name goal)
  (let ((pred (predicate-from-name pred-name))
        (goal-predicate-name (concat-symbols (list pred-name '*goal)))
        )
    (setf (predicate-goal-predicate pred) (predicate goal-predicate-name
                                                     :world 'closed :unique (predicate-unique pred)
                                                     :select (if (and (open-world pred) (predicate-unique pred)) 'best (predicate-select pred)) 
                                                     :replace (predicate-replace pred) :episodic (predicate-episodic pred)
                                                     :arguments (if (and (open-world pred) (predicate-unique pred))
                                                                    (make-unique-arguments-select (predicate-arguments pred))
                                                                  (predicate-arguments pred))))
    (setf (graph-goal-list cg) (cons goal (graph-goal-list cg)))
    (when compute-progress
      (setf (predicate-progress-predicate pred)
            (if (closed-world pred)
                (predicate (concat-symbols (list pred-name '*progress)) :perception t :arguments (meta-arguments pred)
                           :no-surprise t :no-normalize t :function 1
                           )
              (predicate (concat-symbols (list pred-name '*progress)) :perception t :arguments (meta-arguments pred)
                         :no-surprise t :function 1
                         )))
      (setf (predicate-difference-predicate pred)
            (if (closed-world pred)
                (predicate (concat-symbols (list pred-name '*difference)) :perception t :arguments (meta-arguments pred)
                           :no-surprise t :no-normalize t :function 1
                           )
              (predicate (concat-symbols (list pred-name '*difference)) :perception t :arguments (meta-arguments pred)
                         :no-surprise t :function 1
                         )))
      ; Set up global progress
      (setf (graph-progress-predicates cg) (cons pred (graph-progress-predicates cg)))
      (unless (graph-progress-distribution-predicate cg)
        (setf (graph-progress-distribution-predicate cg) (predicate 'progress*distribution :perception t :no-normalize t
                                                       :arguments (if multiagent '((agent agent) (value predicate %)) '((value predicate %)))))
        (setf (graph-progress-predicate cg) (predicate 'progress :perception t :no-normalize t :arguments (if multiagent '((agent agent)) '())))
        )
      ; Set up global difference
      (setf (graph-difference-predicates cg) (cons pred (graph-difference-predicates cg)))
      (unless (graph-difference-distribution-predicate cg)
        (setf (graph-difference-distribution-predicate cg) (predicate 'difference*distribution :perception t :no-normalize t
                                                         :arguments (if multiagent '((agent agent) (value predicate %)) '((value predicate %)))))
        (setf (graph-difference-predicate cg) (predicate 'difference :perception t :no-normalize t :arguments (if multiagent '((agent agent)) '())))
        )
      ; Create an attention predicate if not already one
      (when (and compute-attention (not (predicate-attention-predicate pred)))
        (setf (predicate-attention-predicate pred)
              (predicate (concat-symbols (list pred-name '*attention)) :no-surprise t :perception t :function 1
                         :arguments (meta-arguments pred)))
                 ; Set up global attention
        (setf (graph-attention-predicates cg) (cons pred (graph-attention-predicates cg)))
        (unless (graph-attention-distribution-predicate cg)
          (setf (graph-attention-distribution-predicate cg) (predicate 'attention*distribution :perception t :no-normalize t
                                                          :arguments (if multiagent '((agent agent) (value predicate %)) '((value predicate %)))))
          (setf (graph-attention-predicate cg) (predicate 'attention :perception t :no-normalize t :arguments (if multiagent '((agent agent)) '())))
          )
        )
      )
    )
  )

; Initialize a predicate definition in a graph
(defun predicate (name &rest arguments)
  (when (member name (graph-predicates cg) :key #'predicate-name)
    (error "Predicate ~S cannot be redefined!" name)
    )
  (when (and (not define-system-predicate) (member name system-predicates))
    (error "Attempt to define a predicate (~S) that is a reserved system predicate name!" name)
    )
  (let (np sp sp-perception function-node gpt)
    (setq np (apply #'make-predicate (append (list ':name name) arguments)))
    (unless (predicate-world np) ; Default to open world if not specified
      (setf (predicate-world np) 'open)
      )
    (unless (member ':persistent arguments) ; Default to persistent for closed world and not for open world
      (setf (predicate-persistent np) (if (closed-world np) t nil))
      )
    (check-predicate-arguments np)
    ; If this is a replacement perception predicate, make the predicate itself non-perception but the prediction predicate (if there is one) perceptual
    (when (and (predicate-replace np) (predicate-perception np) diachronic-prediction)
      (setf (predicate-perception np) nil)
      (setq sp-perception t)
      )
    ; It is important that the selected predicate be last in the list for impasse processing
    (setf (graph-predicates cg)
          (if (eq name 'selected)
              (append (graph-predicates cg) (list np))
            (cons np (graph-predicates cg))))
    (when (state-predicate np)
      (setf (graph-state-predicates cg) (cons np (graph-state-predicates cg)))
      )
    ; Create the WMFN node
    (init-wm np)
    ; Update the predicate type
    (setq gpt (graph-predicate-type cg))
    (setf (stype-constants gpt) (cons name (stype-constants gpt)))
    (setf (stype-max gpt) (1+ (stype-max gpt)))
    (setf (stype-span gpt) (1+ (stype-span gpt)))
    ; When there is a function, create a function node and a shared WMVN and attach to the WMFN
    (when (predicate-function np)
      (setq function-node (compile-predicate-function np))
      ; Set up the predicate for the surprise in learning
      (when (and compute-surprise ; We are computing surprise
                 learn-via-gradient-descent ; We are learning in general
                 (not (predicate-no-surprise np)) ; This not a predicate, such as a surprise predicate, for which surprise shouldn't be computed
                 (not (and (predicate-learning-rate np) ; Not a zero learning rate (and thus also not a surprise predicate)
                           (zerop (predicate-learning-rate np))
                           ))
                 )
        (setf (predicate-surprise-predicate np) (predicate (concat-symbols (list name '*surprise)) :perception t :no-surprise t :function 1
                                                           :arguments (meta-arguments np)))
        (setf (node-surprise-predicate function-node) (predicate-surprise-predicate np))
        ; Set up global surprise
        (setf (graph-surprise-predicates cg) (cons np (graph-surprise-predicates cg)))
        (unless (graph-surprise-distribution-predicate cg)
          (setf (graph-surprise-distribution-predicate cg) (predicate 'surprise*distribution :perception t :no-normalize t
                                                         :arguments (if multiagent '((agent agent) (value predicate %)) '((value predicate %)))))
          (setf (graph-surprise-predicate cg) (predicate 'surprise :perception t :no-normalize t :arguments (if multiagent '((agent agent)) '())))
          )
        ; Create an attention predicate
        (when compute-attention
          (setf (predicate-attention-predicate np)
                (predicate (concat-symbols (list (predicate-name np) '*attention)) :no-surprise t :perception t :function 1
                           :arguments (meta-arguments np)))
          ; Set up global attention
          (setf (graph-attention-predicates cg) (cons np (graph-attention-predicates cg)))
          (unless (graph-attention-distribution-predicate cg)
            (setf (graph-attention-distribution-predicate cg) (predicate 'attention*distribution :no-normalize t :perception t
                                                            :arguments (if multiagent '((agent agent) (value predicate %)) '((value predicate %)))))
            (setf (graph-attention-predicate cg) (predicate 'attention :perception t :no-normalize t :arguments (if multiagent '((agent agent)) '())))
            )
          )
        )
      )
    ; Create prediction version of predicate if doing diachronic prediction
    (when (and diachronic-prediction
               (or learn-open ; and either we learn for all predicates
                   (closed-world np) ; or the predicate is closed world
                   )
               (state-predicate np) ; and the predicate tests the state
;               (predicate-select np) ; and the predicate is selection (unique or expected)
               (not (member (predicate-name np) '(impasse state))) ; Don't do for impasse predicate
               )
      (setq sp (make-predicate :name (concat-symbols (list name prediction-suffix))
                               :world 'open
                               :persistent nil
                               ))
      (when (or (predicate-perception np) sp-perception)
        (setf (predicate-perception sp) t)
        )
      (setf (predicate-arguments sp) (mapcar #'prediction-argument (predicate-arguments np)))
      (check-predicate-arguments sp)
      (setf (predicate-prediction sp) np)
      (init-wm sp 1)
      ; It is important that the selected predicate be last in the list for impasse processing
      (setf (graph-predicates cg) (cons sp (graph-predicates cg)))
      (setf (predicate-predict np) sp)
      )
    (when (and episodic-learning ; Create episodic predicates and conditionals when episodic learning is on
               (or learn-open ; and either we learn for all predicates
                   (closed-world np) ; or the predicate is closed world
                   )
               (state-predicate np) ; and the predicate tests the state
               (predicate-select np) ; and the predicate makes a selection
               (not (member name '(impasse state))) ; don't save impasses or states in episodic memory
               )
      (init-predicate-em np))
    ; Replace separate call to goal function with attribute on predicate
    (when (predicate-goal np)
      (goal (predicate-name np) (predicate-goal np))
      )
    np)
  )

; Define a system predicate
; Needed so that no error message for defining one
(defun system-predicate (name &rest arguments)
  (let (np)
    (setq define-system-predicate t)
    (setq np (apply #'predicate (cons name arguments)))
    (setq define-system-predicate nil)
    np)
  )

; Does a predicate test the state?
; Returns state argument
(defun state-predicate (p)
  (find 'state (predicate-arguments p) :key #'argument-type-name)
  )

; Miscellaneous
; -------------

; Set the form of operator selection among best, prob-match and boltzmann
(defun operator-selection (type)
  (when (not (member type '(best prob-match boltzmann)))
    (error "Attempt to set operator selection type to ~S, which is not BEST, PROB-MATCH or BOLTZMANN." type)
    )
  (setf (predicate-select (graph-selected-predicate cg)) type)
  )

; Return a list with n stars (*) in it
(defun nstars (n)
  (let (starlist)
    (dotimes (i n)
      (setq starlist (cons '* starlist))
      )
    starlist)
  )

; A list with n stars
(defun stars (n)
  (make-list n :initial-element '*)
  )

; Compute number of regions in a PLM
(defun regions-in-plm (p)
  (let ((rs 1)
        (sv (plm-slices p))
        )
    (dotimes (i (length sv))
      (setq rs (* rs (length (aref sv i))))
      )
    rs)
  )


; Maps
; ----

; Create a vpoint mapping from a vfactor mapping
; Need to insert a 0 at the front and add 1 to all of the other elements
(defun init-vpoint-map (vfactor)
  (let* ((vf-rank (length vfactor))
         (vpoint (init-vector (+ vf-rank 1) 0)))
    (dotimes (i vf-rank)
      (setf (aref vpoint (+ i 1)) (+ (aref vfactor i) 1)))
    vpoint)
  )



; Empty node function
(defun empty-node-function (node default)
  (let ((fun (node-function node)))
    (setf (node-function node)
          (make-constant-discrete-plm (number-list (plm-rank fun))
                                      (plm-variables fun)
                                      default
                                      0)
          )
    (when save-message-state
      (setf (aref (graph-changes cg) (node-number node)) t)
      )
    )
  )



; Find index of a variable (by its type) in variable sequence
(defun var-type-index (tn vs)
  (position tn vs :key #'(lambda (v) (stype-name (svariable-type v))))
  )


; -----------------------------------------------------------
; Chunking

; Return a pattern for the predicate and the list of variables in the pattern
(defun chunk-pattern (pred)
  (let* ((pname (predicate-name pred))
         (pstr (symbol-name pname))
         v vs aname
         (pattern (list (concat-symbols (list pname '*NEXT))))
        )
    (dolist (arg (predicate-arguments pred))
      (setq aname (argument-name arg))
      (setq v (gentemp (concatenate 'string pstr "-" (symbol-name aname))))
      (setq vs (cons v vs))
      (setq pattern (cons (list aname (list v)) pattern))
      )
    (list (reverse vs) (reverse pattern))
    )
  )

; Create a chunk for a predicate
(defun create-chunk (pred)
  (let (vs conditions cp ap)
    (dolist (wmfn (ess-wm-dependencies (predicate-incoming-vn pred)))
      (setq cp (chunk-pattern (node-predicate wmfn)))
      (setq vs (append (car cp) vs))
      (setq conditions (cons (cadr cp) conditions))
      )
    (setq ap (chunk-pattern pred))
    (setq vs (append vs (car ap)))
    (conditional (concat-symbols (list (predicate-name pred) 'chunk) t)
                 :conditions conditions
                 :condacts (list (cadr ap))
                 :normal (if (symbolp (predicate-unique pred))
                             (caadr (assoc (predicate-unique pred) (cdadr ap)))
                           (mapcar #'(lambda (x) (caadr (assoc x (cdadr ap)))) (predicate-unique pred)))
                 :function-variable-names vs
                 :function (list (cons 1 (make-list (length vs) :initial-element '*)))
                 )
    )
  )

; Create a chunk for each closed-world selection state predicate
(defun create-chunks nil
  (dolist (pred (graph-predicates cg))
    )
  )

; -----------------------------------------------------------
; Initialize graph, test if should halt, and run

; Count number of operators provided by predicate
(defun count-operators-predicate (predicate)
  (setf (predicate-operators predicate)
        (reduce #'* (predicate-wm-variables predicate) :key #'(lambda (v)
                                                                         (stype-span (svariable-type v))
                                                                       )))
  )

; Count number of operators provided across operator predicates
(defun count-operators (predicate-names)
  (let ((count 0)
        countp pred)
    (dolist (pred-name predicate-names)
      (setq pred (predicate-from-name pred-name))
      (setf (predicate-first-operator pred) count)
      (setq countp (count-operators-predicate pred))
      (setf (predicate-id-contents pred) (init-vector countp))
      (setq count (+ count countp))
      )
    count)
  )
    
; Make a predicate into an operator
(defun make-predicate-operator (predicate operator-type)
  (when (state-predicate predicate)
    (error "Found STATE argument in predicate ~S, but state predicates cannot be operator predicates." (predicate-name predicate))
    )
  (when (position-of-predicate-argument 'operator predicate) ; The predicate already has an operator argument
    (error "Predicate ~S already has an OPERATOR argument that conflicts with system generated argument when creating operators from predicate." (predicate-name predicate))
    )
  (let* ((wmfn (predicate-wm predicate))
         (old-vs (predicate-wm-variables predicate))
         old-v
         (old-rank (length old-vs))
         (new-vs (init-vector (1+ old-rank)))
         )
    ; Update list of arguments in predicate
    (setf (predicate-arguments predicate)
          (append (predicate-arguments predicate) (list (list 'operator 'operator))))
    ; Copy and extend variable vector by 1 (and perform necessary checks)
    (dotimes (d old-rank)
      (setq old-v (aref old-vs d))
      (unless (stype-discrete (svariable-type old-v))
        (error "Can't include predicate ~S among operators because variable ~S is not discrete."
               (predicate-name predicate) (svariable-name old-v))
        )
      (unless (multiple-variable old-v)
        (error "Can't include predicate ~S among operators because variable ~S is not universal."
               (predicate-name predicate) (svariable-name old-v))
        )
      (when (eq (svariable-type old-v) 'operator)
        (error "Can't include predicate ~S among operators because variable ~S is of type operator."
               (predicate-name predicate) (svariable-name old-v))
        )
      (setf (aref new-vs d) old-v)
      )
    (setf (aref new-vs old-rank) (make-svariable :name 'wm-operator :type operator-type))
    (setf (predicate-wm-variables predicate) new-vs)
    (when wmfn
      (setf (node-variables wmfn) new-vs)
      ; Regenerate new WMFN function given new variables and limit on operators
      (setf (node-function wmfn)
            (init-plm new-vs
                      (if (closed-world predicate) 0 1)
                      0 (init-vector (length new-vs) t)))
      )
    ; Create assign-ids function for predicate
    (setf (predicate-assign-ids predicate) (create-assign-id-function predicate))
    t)
  )

; Define operators for selection
(defun init-operators (type operator-specification &optional impasses)
  (let (args implicit-operator-type operator-type operator-type-name number-of-operators evaluate-pred evaluation-operators implicit-operator-name)
    (when (predicate-from-name 'selected t)
      (error "Operators were already defined via INIT and can't be redefined via INIT-OPERATORS.")
      )
    (unless (member type '(symbols type predicates))
      (error "In INIT-OPERATORS, the first (TYPE) argument - ~S - must be one of SYMBOLS, TYPE or PREDICATES." type)
      )
    (setq implicit-operator-name (if impasses 'base-operator 'operator))
    (when (and (member type '(symbols predicates))
               (member implicit-operator-name (graph-types cg) :key #'stype-name)
               )
      (error "Operators cannot be specified via ~S if the ~S type is already defined." type implicit-operator-name)
      )
    (setq detect-impasses impasses) ; Set global variable
    ; Create STATE predicate if doesn't already exist
    (unless (predicate-from-name 'state t)
      (system-predicate 'state :world 'closed :arguments (if multiagent '((agent agent) (state state)) '((state state))))
      )
    ; Define type for user specified operators (doesn't include evaluation operators if any)
    (setq implicit-operator-type
          (case type
            ((symbols) (new-type implicit-operator-name :discrete t :min 0 :max (length operator-specification) :constants operator-specification))
            ((type) (if (atom operator-specification) (type-from-name operator-specification) (eval operator-specification)))
            ((predicates) (new-type implicit-operator-name :discrete t :numeric t :min 0 :max (count-operators operator-specification)))
            ))
    (setq number-of-operators (stype-span implicit-operator-type))
    (when impasses
      (setq evaluation-operators number-of-operators)
      (setq number-of-operators (* 2 number-of-operators))
      (setq operator-type (new-type 'operator :discrete t :numeric t :min 0 :max number-of-operators))
      (unless (eq type 'predicates)
        (system-predicate 'operator :arguments (list (list (stype-name implicit-operator-type) (stype-name implicit-operator-type))))
        (setq operator-specification (list 'operator))
        (count-operators operator-specification)
        )
      )
    ; For each operator predicate, extend arguments/variables for operator and generate assign-ids function
    (when (or (eq type 'predicates) impasses)
      (dolist (pred-name operator-specification)
        (make-predicate-operator (predicate-from-name pred-name) (if impasses operator-type implicit-operator-type))
        )
      (setf (graph-operator-predicates cg) (mapcar #'predicate-from-name operator-specification))
      )
    ; Create SELECTED predicate
    (setq args '((state state)))
    (if multiagent (setq args (cons '(agent agent) args)))
    (setq operator-type-name (stype-name (if impasses operator-type implicit-operator-type)))
    (setf (graph-operator-type-name cg) operator-type-name)
    (setf (graph-selected-predicate cg)
          (system-predicate 'selected :world 'closed :persistent t :select 'best
                     :arguments (reverse (cons `(operator ,operator-type-name !) (reverse args)))))
    ; Initiate the possibility of impassing
    (when impasses
      (new-type 'impasse :constants '(tie none no-change))
      (system-predicate 'impasse :world 'closed :arguments (append args `((operator ,operator-type-name) (type impasse !))))
      (setf (graph-detect-impasses-predicate cg) (system-predicate 'detect-impasses :arguments (append args '((value flag %)))))
      (setq evaluate-pred (system-predicate 'evaluate-operator :world 'open :arguments `((evaluate ,operator-type-name))))
      (setf (predicate-first-operator evaluate-pred) evaluation-operators)
      (setf (predicate-operators evaluate-pred) (predicate-first-operator evaluate-pred))
      (setf (predicate-id-contents evaluate-pred) (init-vector evaluation-operators))
      (make-predicate-operator evaluate-pred operator-type)
      (setf (graph-operator-predicates cg) (append (graph-operator-predicates cg) (list evaluate-pred)))
      )
    )
  )

; Checks to be done at init time
(defun init-checks nil
  (unless (member operator-best-select '(random first))
    (error "Unknown value ~S of OPERATOR-BEST-SELECT.  Must be FIRST or RANDOM." operator-best-select)
    )
  (unless (member non-operator-best-select '(random first))
    (error "Unknown value ~S of NON-OPERATOR-BEST-SELECT.  Must be FIRST or RANDOM." non-operator-best-select)
    )
  )

; Initialize
(defun init (&optional operators agents center-discrete)
  (when reset-parameters-in-init
    (reset-parameters))
  (setq trial-count 0)
  (setq center-discrete-numeric-on-integer center-discrete)
  (setq cg (create-graph))
  (init-checks)
  (setq epsilon21 (* epsilon2 1.1))
  (setq relative-epsilon (* .1 epsilon2)) ; Initial value before defining types
  (new-type 'boolean :constants (list boolean-false boolean-true))
  (new-type 'flag :constants '(true))
  (new-type 'state :numeric t :discrete t :min 0 :max max-state)
  (setf (graph-predicate-type cg) (new-type 'predicate :constants nil))
  (when track-time
    (new-type temporal-predicate-name :numeric t :discrete t :min 0 :max max-time)
    (system-predicate temporal-predicate-name :world 'closed :arguments '((value time !)))
    )
  (cond (agents
         (let (agent-type)
           (setq multiagent t)
           (setq agent-type (if (consp agents) ; Take a list of agent names
                                (new-type 'agent :constants agents)
                              (if (and (integerp agents) (> agents 0)) ; Take a number of agents
                                  (new-type 'agent :numeric t :discrete t :min 0 :max agents)
                                (error "Agents specification of ~S is neither a list or a positive integer." agents))))
           (setf (graph-agent-type cg) agent-type)
           (setf (graph-agents cg) (stype-span agent-type))
           (setq bottom-state (init-vector (graph-agents cg) base-level-state))
           (setq delete-lower-states (init-vector (graph-agents cg)))
           )
         )
        (t
         (setq multiagent nil)
         (setq bottom-state base-level-state)
         (setq delete-lower-states nil)
         )
        )
  (when operators
    (init-operators 'symbols operators) ; Defaults to detect-impasses nil
    )
  (system-predicate halt-predicate-name :world 'closed)
  (setf (graph-node-vector cg) nil)
  (setf (graph-goals-set cg) nil)
  (setq message-count 0)
  (setq decision-count 0)
  (setq cycle-message-counts nil)
  (setq impasse-regions nil)
  (setq perceive-list nil)
  (setq action-list nil)
  (setq pre-run nil)
  (setq post-run nil)
  (setq pre-d nil)
  (setq post-d nil)
  (setq pre-t nil)
  (setq post-t nil)
  (setq pre-ts nil)
  (setq post-automatic nil)
  (setq global-decision-statistics nil)
  (setq global-graph-messages nil)
  (setq have-run nil)
  (setq define-system-predicate nil)
  (setq attention-exponential-numerator (log (/ 10 epsilon)))
  t)

; Set WM for Halt to 1 so that halt
(defun halt nil
  (let ((pwm (predicate-wm (predicate-from-name halt-predicate-name))))
    (setf (node-function pwm) (make-constant-discrete-plm nil nil 1 0))
    (when save-message-state
      (setf (aref (graph-changes cg) (node-number pwm)) t)
      )
    )
  )

; Check if halt action executed
(defun haltp ()
  (not (plm-empty (node-function (predicate-wm (predicate-from-name halt-predicate-name)))))
  )


; Is link inactive?
(defun inactive-link (l)
  (and (not (link-out l))
       (not (link-in l))
       ) 
  )

; Excise all inactive links from graph
(defun excise-inactive-links nil
  (dolist (l (graph-links cg))
    (when (inactive-link l)
      (excise-link l)
      )
    )
  nil)

; Excise unneeded factor steps from a node
(defun excise-unneeded-factor-steps-node (n)
  ; Eliminate unnecessary product steps
  (dolist (l (node-links n))
    (unless (aref (link-contents l) var-index)
      (setf (node-factor-steps n)
            (remove (node-name (aref (link-nodes l) var-index)) (node-factor-steps n)
                    :key (lambda (fs) (if (eq (factor-step-type fs) 'product)
                                          (node-name (aref (link-nodes (factor-step-argument fs)) var-index))
                                        nil))))
      )
    )
  ; Eliminate unnecessary summary steps
  (let (v-used)
    (dotimes (i (length (node-variables n)))
      (setq v-used nil)
      (dolist (l (node-links n))
        (when (and (link-map l) ; There is a map on the link (otherwise no variables in variable node
                   (not (aref (smap-omitted (link-map l)) i)) ; Factor node variable is used in variable node
                   (aref (link-contents l) var-index)) ; The link is active from the variable to the factor node
          (return (setq v-used t))
          )
        )
      (unless v-used
        (setf (node-factor-steps n)
              (remove i (node-factor-steps n)
                      :key (lambda (fs) (if (not (eq (factor-step-type fs) 'product))
                                            (factor-step-argument fs)
                                          nil))))
        )
      )
    )
  )

; Excise unneeded factor steps from all nodes
(defun excise-unneeded-factor-steps nil
  (dolist (n (graph-nodes cg))
    (when (factor-nodep n)
      (excise-unneeded-factor-steps-node n)
      )
    )
  )

; Generate prediction links for diachronic processing
(defun include-prediction-links nil
  (let (ptn vars map link
        opnode ; Outgoing/shared WMVN for prediction predicate, if there is one
        pwm ; Predicate WM
        old-incoming-link
        plink
        )
    (dolist (pred (graph-predicates cg))
      ; Deal with prediction for persistent prediction predicates (when not already done)
      (when (and (predicate-predict pred) (not (predicate-prediction-link pred)))
        (setq opnode (predicate-outgoing-vn (predicate-predict pred)))
        (setq pwm (predicate-wm pred))
        (when (and (predicate-persistent pred) opnode)
          (when (predicate-incoming-vn pred)
            ; Link incoming WM variable node to shared prediction WMVN
            (setq vars (node-variables pwm))
            (setf ptn (init-factor-node (concat-symbols (list (predicate-name pred) 'predict) t)
                                        'pass-through vars
                                        (list (predicate-incoming-vn pred) opnode)
                                        nil t nil nil nil nil))
            (setf (node-function ptn) (full-plm vars))
            ; Deactive link direction from shared WMVN
            (setq plink (link-from-nodes ptn opnode))
            (setf (link-out plink) nil)
            (setf (aref (link-contents plink) var-index) nil)
            ; Activate links from original to prediction
            (dolist (l (node-links ptn))
              (if (= (node-number (aref (link-nodes l) var-index)) (node-number opnode))
                  (setf (aref (link-contents l) fact-index) (full-plm vars))
                (setf (aref (link-contents l) var-index) (full-plm vars)))
              )
            ; Remove the old link from the original predicate's incoming WMVN to its WMFN
            (setq old-incoming-link (link-from-numbers (node-number (predicate-incoming-vn pred)) (node-number pwm)))
            (setf (link-in old-incoming-link) nil)
            (setf (link-out old-incoming-link) nil)
            )
          ; Make shared prediction WMVN the incoming WMVN for the original predicate
          (setq map (build-smap (node-variables opnode) (node-variables pwm))) ; Build map from variable node variables to factor node variables
          (setq link (make-link :map map
                                :nodes (vector opnode pwm) :contents (vector nil nil)
                                :depths (vector nil nil)
                                :loop-depths (vector nil nil)
                                :inits (vector -1 -1)
                                :incoming (vector nil nil)
                                :in t
                                :out nil
                                :counts (vector 0 0)
                                :stale (vector nil nil)
                                :prequeue (vector nil nil)
                                )
                )
          (add-link link)
          (setf (predicate-prediction-link pred) link)
          (setf (predicate-incoming-vn pred) opnode)
          )
        )
      )
    )
  )

; Identify descendants of assumption nodes
(defun init-descendants ()
  ; These link decendants are needed if this form of state saving is specified or if automatically creating prediction conditionals
  (when (or save-message-state automatic-action-models automatic-perception-models)
    (init-link-descendants)
    )
  )

; Determine which arguments in a predicate are unique for gradient-descent learning
(defun predicate-function-unique-arguments nil
  (dolist (pred (graph-predicates cg))
    (let (unique condact cvars sv pfnode
                 (pname (predicate-name pred))
                 )
      (when (and (predicate-function pred)
                 (predicate-condact-conditionals pred)
                 )
        (dolist (c (predicate-condact-conditionals pred))
          (setq condact (find pname (conditional-condacts c) :key #'car))
          (when condact
            (setq cvars (conditional-variables c))
            (dolist (e (cdr condact))
              (setq sv (find (caadr e) cvars :key #'svariable-name))
              (when (and sv (svariable-unique sv))
                (setq unique (adjoin (car e) unique))
                )
              )
            )
          )
        (setf (predicate-unique-for-gdl pred) unique)
        (setq pfnode (predicate-function-node pred))
        (when pfnode
          (setf (node-unique-for-gdl pfnode) unique)
          )
        )
      )
    )
  )


; Determine when factor and variable node variables are same along links and store in list on 
(defun assign-variables-same nil
  (dolist (l (graph-links cg))
    (let ((vn (link-var-node l))
          (fn (link-fact-node l))
          )
      (when (variables-equal (node-variables vn) (node-variables fn))
        (setf (link-variables-same l) t)
        )
      )
    )
  )

; Processing to be done after all conditionals are defined
; Ideally this would be done incrementally, at least as much as possible, rather than redoing everything, but that is left to the future
(defun post-process-conditionals nil
  (let ((pre-time-init-node (get-internal-run-time))
        message-time
        )
    (include-prediction-links)
    (excise-inactive-links)
    (when max-messages-links
      (setq max-messages (* max-messages-links (length (graph-links cg))))
      )
    (expand-densely-connected-variable-nodes) ; Replace densely connected nodes with binary trees of nodes
    (init-messages t) ; Initialize messages and compute depths
    (setq message-time (/ (- (get-internal-run-time) pre-time-init-node) 1000))
    (when debug-init-descendants
      (format trace-stream "~&Message and Queue Initialization took ~f seconds" message-time)
      )
    (init-descendants)
    (when debug-init-descendants
      (format trace-stream "~&Descendant Initialization took ~f seconds"
              (- (/ (- (get-internal-run-time) pre-time-init-node) 1000) message-time))
      )
    (excise-unneeded-factor-steps)
    (init-node-vector)
    (predicate-function-unique-arguments)
    (assign-variables-same)
    )
  )

; Create vector of nodes from numbers
(defun init-node-vector nil
  (let (nv)
    (setq nv (init-vector (length (graph-nodes cg))))
    (dolist (n (graph-nodes cg))
      (setf (aref nv (node-number n)) n)
      )
    (setf (graph-node-vector cg) nv)
    )
  )

; Initialize a graph after it is defined
(defun init-graph nil
  (init-descendants)
  (when (or automatic-action-models automatic-perception-models automatic-reinforcement-learning)
    (create-models)
    (post-automatic)
    )
  (post-process-conditionals)
  (setf (graph-initialized cg) t)
  (init-link-counts)
  (when (get-state-predicate)
    (evidence '((state (state 0))))
    )
  )

(defun ig nil (init-graph))

; Limit state dimension in all predicate WMFNs to bottom state
(defun restrict-to-bottom-state ()
  (dolist (sp (graph-predicates cg))
    (when (state-predicate sp)
      (if multiagent
          (dotimes (ai (graph-agents cg))
            (delete-lower-states (1+ (aref bottom-state ai)) ai)
            )
        (delete-lower-states (1+ bottom-state))
        )
      )
    )
  )

;-----------------------------------------------------------
; action and perception models

; Determine which arguments are unique for the newly created model function predicate
(defun unique-model-arguments (pattern old-unique)
  (let (new-unique)
    (dolist (e (cdr pattern))
      (when (member (element-argument-name e) old-unique)
        (setq new-unique (cons (caadr e) new-unique))
        )
      )
    (reverse new-unique))
  )

; Determine which arguments of a predicate pattern are universal
(defun universal-arguments (pred pattern)
  (let ((unique (predicate-unique pred))
        uas)
    (dolist (arg pattern)
      (unless (member (argument-name arg) unique)
        (setq uas (cons arg uas))
        )
      )
    uas)
  )

; Create action models
(defun create-action-models nil
  (let (unique-state-predicates ; All of the unique close-world state predicates
        action-function-variables ; The variables to include in the action function
        condition-list ; List of conditions to be used in prediction
        variablization ; A list containing a pattern, a list of variables, and a list of types for a predicate
        action-type-list ; A list of the names of the types of the variables the perception predicate
        action-condact ; New condact for action function
        (action-variable-count 0) ; The count of how many variables have been created for the action conditional
        pred ; Predicate to use in conditional
        )
    ; Determine all of the closed world unique state predicates that aren't no-models
    (dolist (predicate (graph-predicates cg))
      (when (and (closed-world predicate)
                 (not (predicate-no-models predicate))
                 (predicate-unique predicate)
                 (state-predicate predicate)
                 (not (member (predicate-name predicate) '(selected impasse))) ; Ignore selected and impasse predicates
                 )
        (setq unique-state-predicates (cons predicate unique-state-predicates))
        )
      )
    ; Create condition lists plus the variables and types to be used in the conditionals
    (dolist (usp unique-state-predicates)
      (setq variablization (variablize-predicate usp action-variable-count))
      (setq condition-list (cons (car variablization) condition-list))
      (setq action-function-variables (append (cadr variablization) action-function-variables))
      (setq action-variable-count (+ (length (cadr variablization)) action-variable-count))
      (setq action-type-list (append (caddr variablization) action-type-list))
      )
    ; When it exists, add the selected predicate to the condition list
    (when (graph-selected-predicate cg)
      (setq variablization (variablize-predicate (predicate-from-name 'selected) action-variable-count))
      (setq condition-list (append condition-list (list (car variablization)))) ; Put selected pattern at end of condition list
      (setq action-function-variables (append (cadr variablization) action-function-variables)) ; Put operator variable after other condition variables (and before condact vars)
      (setq action-variable-count (+ (length (cadr variablization)) action-variable-count))
      (setq action-type-list (append (caddr variablization) action-type-list))
      )
    ; Create conditionals
    (dolist (usp unique-state-predicates)
;     (when (not (member (predicate-name usp) no-preds)) ; Don't create for dependent predicates
      (setq variablization (variablize-predicate usp action-variable-count (universal-arguments usp (cdr (assoc (predicate-name usp) condition-list)))))
      (setq pred (predicate (make-name-symbol 'action-)
                            :arguments (reverse (mapcar #'list
                                                        (append (cadr variablization) action-function-variables)
                                                        (append (caddr variablization) action-type-list)))
                            :unique (unique-model-arguments (car variablization) (predicate-unique usp))
                            :function (if (predicate-action-function usp) (predicate-action-function usp) 1)))
      (setf (graph-action-predicate cg) pred)
      (setq action-condact (cons (predicate-name pred) (reverse (mapcar #'(lambda (v) (list v (list v))) (append (cadr variablization) action-function-variables)))))
      (conditional (concat-symbols (list (predicate-name usp) 'prediction) t)
                   :conditions (if (predicate-from-name 'state t) (cons '(state (state (s))) condition-list) condition-list)
                   :condacts (append (list (cons (concat-symbols (list (caar variablization) prediction-suffix)) (cdar variablization))) (list action-condact))
                   )
;        )
      )
    t)
  )

; Create perception models
(defun create-perception-models nil
  (let (perception-function-variables ; The variables to include in the perception function
        condact-list ; List of condacts to be used in prediction (perception learning)
        variablization ; A list containing a pattern, a list of variables, and a list of types for a predicate
        perception-type-list ; A list of the names of the types of the variables the perception predicate
        perception-condact ; New condact for perception function
        (perception-variable-count 0) ; The count of how many variables have been created for the perception conditional
        pred ; Predicate to use in conditional
        )
    ; Create condition and condact lists plus the variables and types to be used in the conditionals
    (dolist (predicate (graph-predicates cg))
      (when (and (closed-world predicate)
                 (not (predicate-no-models predicate))
                 (predicate-unique predicate)
                 (state-predicate predicate)
                 (not (member (predicate-name predicate) '(selected impasse))) ; Ignore selected and impasse predicates
                 )
        (setq variablization (variablize-predicate (predicate-predict predicate) perception-variable-count))
        (setq condact-list (cons (car variablization) condact-list))
        (setq perception-function-variables (append (cadr variablization) perception-function-variables))
        (setq perception-variable-count (+ (length (cadr variablization)) perception-variable-count))
        (setq perception-type-list (append (caddr variablization) perception-type-list))
        )
      )
    ; Create conditionals, one for each perception predicate
    (dolist (p (graph-predicates cg))
      (when (and (predicate-perception p)
                 (not (member (predicate-name p) '(time state)))
                 (not (predicate-no-models p))
                 (not (closed-world p))
                 (not (predicate-prediction p))
                 )
        (setq variablization (variablize-predicate p perception-variable-count))
        (setq pred (predicate (make-name-symbol 'perception-)
                              :arguments (mapcar #'list
                                                 (append (cadr variablization) perception-function-variables)
                                                 (append (caddr variablization) perception-type-list))
                              :unique (unique-model-arguments (car variablization) (predicate-unique p))
                              :automated-perception t
                              :function (if (predicate-perception-function p) (predicate-perception-function p) 1)))
        (setf (graph-perception-predicate cg) pred)
        (setq perception-condact (cons (predicate-name pred) (mapcar #'(lambda (v) (list v (list v))) (append (cadr variablization) perception-function-variables))))
        (conditional (concat-symbols (list (predicate-name p) 'perception-prediction) t)
                     :conditions (if (predicate-from-name 'state t) '((state (state (s)))) nil)
                     :condacts (append (cons (cons (caar variablization) (cdar variablization)) condact-list) (list perception-condact))
                     )
        )
      )
    t)
  )

; Create an action-model conditional (and predicate) for each closed-world unique state predicate
; Create a perception-model conditional (and predicate) for each perceptual predicate
; Create reinforcement learning (RL) predicates and conditionals
(defun create-models nil
  (when automatic-action-models
    (create-action-models)
    )
  (when automatic-perception-models
    (create-perception-models)
    )
  (when automatic-reinforcement-learning
    (create-reinforcement-learning)
    )
  )

; -----------------------------------------------------------
; Interface and test stuff

; Extract (first) best domain element from a 1D PLM (or a 2D state PLM)
(defun best-in-plm (plm &optional state)
    (let ((pvs (plm-variables plm)) ; PLM variables
          vtype ; Type of variable
          vi ; Index of variable
          si ; State index
          ar ; Axial region of maximized PLM (for state)
          mp ; Maximized plm
          mprarray
          ir
          ril ; Index list
          mpsizev ; Sizes of dimensions of mprarray
          best) ; Best value
      (cond (state
             (unless (= (length pvs) 2)
               (pplm plm)
               (error ": BEST-IN-PLM cannot be applied to plm because does not have exactly one non-state dimension!")
               )
             (setq si (stype-index 'state pvs))
             (setq vi (if (= si 0) 1 0))
             )
            (t
             (unless (= (length pvs) 1)
               (pplm plm)
               (error ": BEST-IN-PLM cannot be applied to plm because does not have exactly one dimension!")
               )
             (setq vi 0)
             ))
      (setq vtype (svariable-type (aref pvs vi)))
      (setq mp (maximize-plm plm vi))
      (setq mprarray (plm-array mp))
      (setq mpsizev (array-dimensions-v mprarray))
      (setq ril (make-list (plm-rank plm) :initial-element 0))
      (setq ar (row-major-aref mprarray 0)) ; Origin region
      ; If state, find axial region for it
      (when state
        (do ((il ril (region-after-index-list il si (1- (aref mpsizev si)))))
            ((and (setq ir (apply #'aref mprarray il))
                  (<= (region-min ir si) state)
                  (> (region-max ir si) state)
                  )
             (setq ar ir)
             (return)
             )
          )
        )
      (setq best (car (aref (region-maximals ar) vi))) ; Best (sub)region
      (cond ((not (stype-discrete vtype)) ; Continuous
             (car best))
            ((stype-constants vtype) ; Symbolic
             (get-symbol-name (car best) vtype))
            (t ; Discrete
             (if center-discrete-numeric-on-integer
                 (+ (car best) 1/2)
               (car best)))
            )
      )
    )

; Extract unique discrete value from a 1D WM
(defun nonstate-value (pname)
  (let* ((pred (predicate-from-name pname))
         fn
         (args (predicate-arguments pred))
         (arg (car args))
         (aname (argument-name arg))
         (dim (position-of-predicate-argument aname pred))
         smp ; Smallest maximal point
         at ; argument type
         )
    (unless (predicate-wm pred)
      (error "Predicate ~S has no WMFN in NONSTATE-VALUE" pname)
      )
    (setq fn (node-function (predicate-wm pred)))
    (unless (= (length args) 1)
      (error "Predicate ~S is not 1D in NONSTATE-VALUE" pname)
      )
    (unless (and (= (length arg) 3) (unique-argument arg))
      (error "Argument ~S in Predicate ~S is not unique in NONSTATE-VALUE" aname pname)
      )
    (setq at (type-from-name (argument-type-name arg)))
    (unless (and at (stype-discrete at))
      (error "Argument ~S in Predicate ~S is not discrete in NONSTATE-VALUE" aname pname)
      )
    (setq smp (smallest-maximal-point fn dim))
    (if center-discrete-numeric-on-integer (+ smp 1/2) smp)
    )
  )

; Extract value of argument in state
; Assumes the argument is unique and that there are no other arguments in the predicate
(defun value-in-function-state (pred fn s aname &optional agent)
  (let* ((pname (predicate-name pred))
         (slices (plm-slices fn))
         (sd (position-of-predicate-argument 'state pred)) ; Position of state argument
         (argd (position-of-predicate-argument aname pred)) ; Position of argument of interest
         agentd
         (rarray (plm-array fn))
         (size-1 (1- (aref (array-dimensions-v rarray) argd)))
         (args (predicate-arguments pred))
         (arg (nth argd args))
         argt ; argument type
         il ; Index list for region
         ir ; Region
         )
    (when (and multiagent (not agent))
      (error "No agent argument provided to VALUE-IN-FUNCTION-STATE for multiagent state predicate ~S" pname)
      )
    (unless (= (length args) (if agent 3 2))
      (error "Predicate ~S is not ~SD in VALUE-IN-FUNCTION-STATE" pname (if agent 3 2))
      )
    (unless (and (= (length arg) 3) (unique-argument arg))
      (error "Argument ~S in Predicate ~S is not unique in VALUE-IN-FUNCTION-STATE" aname pname)
      )
    (unless sd
      (error "Predicate ~S has no state argument in VALUE-IN-FUNCTION-STATE" pname)
      )
    (unless argd
      (error "Predicate ~S has no ~S argument in VALUE-IN-FUNCTION-STATE" pname aname)
      )
    (setq argt (type-from-name (argument-type-name arg)))
    (unless (and argt (stype-discrete argt))
      (error "Argument ~S in Predicate ~S is not discrete in VALUE-IN-FUNCTION-STATE" aname pname)
      )
    (setq il (make-list (plm-rank fn) :initial-element 0)) ; Set index list to origin
    ; If there is an agent, find the index of the axial region for the agent of interest
    (when agent
      (when (symbolp agent)
        (setq agent (position agent (stype-constants (type-from-name 'agent)))) ; Get number from symbol
        )
      (setq agentd (position-of-predicate-argument 'agent pred))
      ; Set region index along agent dimension to agent's slice index
      (setf (nth agentd il) (find-region-slice-index (if (and center-discrete-numeric-on-integer (stype-numeric (graph-agent-type cg))) (- agent 1/2) agent) (aref slices agentd)))
      )
    ; Find the index of the axial region for the state of interest
    (setf (nth sd il) (find-region-slice-index (if center-discrete-numeric-on-integer (- s 1/2) s) (aref slices sd)))
    ; Find (first) region with a functional value of 1 along the argument dimension
    (do ((dil il (region-after-index-list dil argd size-1)))
        ((null dil) (return nil))
      (setq ir (apply #'aref rarray dil))
      (when (e= (region-constant ir) 1)
        (return (if (stype-numeric argt)
                    (region-min ir argd)
                  (get-symbol-name (region-min ir argd) argt))
                )
        )
      )
    )
  )

; Extract value of argument in state from predicate WMFN
; Assumes the argument is unique and that there are no other arguments in the predicate
(defun value-in-state (pname s aname &optional agent)
  (let ((pred (predicate-from-name pname)))
    (unless (predicate-wm pred)
      (error "Predicate ~S has no WMFN in VALUE-IN-STATE" pname)
      )
    (value-in-function-state pred (node-function (predicate-wm pred)) s aname agent)
    )
  )

; Return the operator in state s
(defun operator-in-state (s &optional agent)
  (unless (predicate-from-name 'selected t)
    (error "No selection predicate defined, so can't get the operator from the state.")
    )
  (value-in-state 'selected s 'operator agent)
  )

; Get symbol name from type
(defun get-symbol-name (num type)
  (elt (stype-constants type) num))

; Does a dimension cover the full scope of a type?
(defun dimension-full-scope (d-min d-max type)
  (and (e= d-min (stype-min type) t)
       (e= d-max (stype-max type) t)))

; Get the type of a variable when variable may be a single variable or a list
; If a list (from a factor vector of variables), just get type of first (both should be same)
(defun variable-types (v)
  (if (listp v)
      (svariable-type (car v))
    (svariable-type v)))


; Determine if region is within limits
; It is if it overlaps with limits, even if region extends outside of limits
(defun region-within-limits (r limits-v)
  (let ((within t)
        d)
    (dotimes (i (length limits-v))
      (setq d (aref (region-dimensions r) i))
      (when (or (e<= (slice-location (dimension-max-slice d)) (car (aref limits-v i)) t)
                (e>= (slice-location (dimension-min-slice d)) (cadr (aref limits-v i)) t)
                )
        (setq within nil)
        (return)
        )
      )
    within)
  )

; Compute a limit vector on the region of the PLM to print from a list with argument names and constant elements
(defun compute-limits (l vars)
  (let* ((rank (length vars))
         (v (init-vector rank))
         var type pos)
    ; Initialize limit vector to full span of each variable/dimension
    (dotimes (i rank)
      (setq var (aref vars i))
      (when (listp var) (setq var (car var))) ; For delta nodes
      (setq type (svariable-type var))
      (setf (aref v i) (list (stype-min type) (stype-max type)))
      )
    ; Restrict limit vector based on arguments specified
    (dolist (a l)
      (setq pos (position (car a) vars
                          :key #'(lambda (v) (if (listp v)
                                                 (svariable-name (car v))
                                               (svariable-name v))
                                   )
                          )
            )
      (when pos
        (setq var (aref vars pos))
        (when (listp var) (setq var (car var))) ; For delta nodes
        (setf (aref v pos) (compute-span (cadr a) (svariable-type var) t))
        )
      )
    v)
  )

; Check with a summarization list of find-plm has at most one arg-max, and it is last
(defun validate-summarize-list (summarize)
  (and (listp summarize)
       (or (= (length summarize) 0)
           (and 
            (not (find-if #'(lambda (x) (not (and (listp x) (or (= (length x) 2) (and (= (length x) 3) (eq (car x) 'constant)))))) summarize)) ; All elements are 2 element lists
            (not (find 'argmax summarize :key #'car :end (1- (length summarize)))) ; No use of summarize before last element
            )
           )
       )
  )

; Arguments for summarization
(defun apply-summarization-arguments (p d &optional location)
  (if location
      (list p d (car (compute-span location (svariable-type (aref (plm-variables p) d)) t)))
    (list p d))
  )

; Apply a summarization operation to a PLM (or a list of two PLMs)
(defun apply-summarization (pn s)
  (let (d op location ps)
    (setq op
          (case (car s)
            ((constant) #'extract-value-plm)
            ((expected) #'expected-value-plm)
            ((max argmax) #'maximize-plm)
            (t (error "Summarization operator ~S not one of CONSTANT, EXPECTED, MAX or ARGMAX in find-plm." (car s)))
            ))
    (when (eq (car s) 'constant)
      (if (cddr s)
          (setq location (caddr s))
        (error "No location provided for CONSTANT summarization in APPLY-SUMMARIZATION."))
;      (format trace-stream "~&~S: ~S~&" (cadr s) (caddr s))
      )
    (if (listp pn)
        (dolist (p pn)
          (setq d (position (cadr s) (plm-variables (cdr p)) :key #'svariable-name))
          (when d
            (setq ps (cons (apply op (apply-summarization-arguments (cdr p) d location)) ps))
            )
          )
      (progn
        (setq d (position (cadr s) (plm-variables pn) :key #'svariable-name))
        (unless d ; No position was found
          (error "Could not find dimension ~S to summarize over via ~A in ~S." (cadr s) op pn)
          )
        (setq pn (apply op (apply-summarization-arguments pn d location)))
        )
      )
    pn)
  )

; Apply a list of summarizations to a PLM
(defun apply-summarizations (p ss)
  (let ((np p))
    (dolist (s ss)
      (setq np (apply-summarization np s))
      )
    np)
  )

; Find plm to print if given a node number, a predicate name or a conditional name (or a PLM)
; Summarize is a list of lists, each one with a summarization operation ('constant 'expected or 'max [or 'argmax, which also yields a max here])
; and dimension along which to summarize
; There can be at most one argmax, and it must be last
; If pid is specified as a name, and there is both a predicate and a conditional by that name, return a list of both
(defun find-plm (pid &optional summarize)
  (unless (validate-summarize-list summarize)
    (error "Invalid summarization list (not list of 2-element lists with at most one argmax) in find-plm: ~S." summarize)
    )
  (let (pwmn pfn p c n cn pn)
    (cond ((typep pid 'plm)
           (setq pn pid)
           )
          ((numberp pid)
           (setq n (node-from-number pid))
           (if n
               (setq pn (if (variable-nodep n)
                            (variable-posterior n)
                          (node-function n)))
             (error "No node numbered ~S found in FIND-PLM for printing PLM" pid))
           )
          ((symbolp pid)
           (setq p (predicate-from-name pid t))
           (when p
             (setq n (predicate-wm p))
             (when n
               (setq pwmn (node-function n))
               (setq pn (cons (cons 'wm pwmn) pn))
               )
             (setq n (predicate-function-node p))
             (when n 
               (setq pfn (node-function n))
               (setq pn (cons (cons 'pfun pfn) pn))
               )
             )
           (setq c (conditional-from-name pid))
           (when c
             (setq n (conditional-function-node c))
             (when n
               (setq cn (node-function n))
               (setq pn (cons (cons 'cfun cn) pn))
               )
             )
           (unless (or pwmn pfn cn)
             (error "No predicate or conditional function named ~S found in FIND-PLM for printing PLM" pid)
             )
           )
          (t ; A list
           )
          )
    (setq pn (if (listp pn)
                 (mapcar #'(lambda (x) (cons (car x) (apply-summarizations (cdr x) summarize))) pn)
               (apply-summarizations pn summarize)))
    pn)
  )


; Return a region descriptor for a conditional function
(defun function-region (r p)
  (let (fun specs dims dim dt vars)
    (if (region-function-constantp r)
        (setq fun (region-constant r))
      (setq fun (coerce (extract-function r) 'list)))
    (setq dims (region-dimensions r))
    (setq vars (plm-variables p))
    (dotimes (d (region-rank r))
      (setq dim (aref dims d))
      (setq dt (svariable-type (aref vars d)))
      (if (dimension-full-scope (dimension-min dim) (dimension-max dim) dt)
          (push '* specs)
        (if (stype-constants dt)
            (if (= (region-span r d) 1)
                (push (get-symbol-name (dimension-min dim) dt) specs)
              (push (list (get-symbol-name (dimension-min dim) dt) (get-symbol-name (1- (dimension-max dim)) dt)) specs))
          (if (stype-discrete dt)
              (if (= (region-span r d) 1)
                  (push (if center-discrete-numeric-on-integer (+ (dimension-min dim) 1/2) (dimension-min dim)) specs)
                (push (list (if center-discrete-numeric-on-integer (+ (dimension-min dim) 1/2) (dimension-min dim))
                            (if center-discrete-numeric-on-integer (+ (dimension-max dim) 1/2) (dimension-max dim))) specs))
            (push (list (dimension-min dim) (dimension-max dim)) specs))))
      )
    (if (and (numberp fun) (= fun 0))
        nil
      (cons fun (reverse specs))))
  )

; Convert a PLM into a form that works for a function in a conditional
(defun plm-cpt (p)
  (unless (eq (type-of p) 'plm) (error "Attempt to print an object of type ~S as a PLM." (type-of p)))
  (let ((rarray (plm-array p))
        r rfun pfun)
    (dotimes (i (array-total-size rarray))
      (setq r (row-major-aref rarray i))
      (if (region-bad r)
          (setq rfun nil)
        (setq rfun (function-region r p)))
      (when rfun
        (push rfun pfun)
        )
      )
    (reverse pfun))
  )

; Provide conditional function in a form that can be reused on a conditional
(defun reusable-conditional-function-c (c)
  (let (cf)
    (unless c
      (error "No conditional named ~S in REUSABLE-CONDITIONAL-FUNCTION-C" (conditional-name c))
      )
    (setq cf (node-function (conditional-function-node c)))
    (unless cf
      (error "No function for conditional ~S in REUSABLE-CONDITIONAL-FUNCTION-C" (conditional-name c))
      )
    (if (numberp cf)
        cf
      (plm-cpt cf))
    )
  )

; Provide conditional function from name in a form that can be reused on a conditional
(defun reusable-conditional-function (cname)
  (reusable-conditional-function-c (conditional-from-name cname))
  )

; Find operator type from id of operator
(defun operator-predicate (id)
  (dolist (pred (graph-operator-predicates cg))
    (when (< id (+ (predicate-first-operator pred) (predicate-operators pred)))
      (return pred)
      )
    )
  )

; Print an operator based on its id
; Doesn't yet do the right thing, as it prints whole region, not just relevant values
(defun pid (id)
  (unless (type-from-name 'operator)
    (error "Can't print operator from id because there is no operator type.")
    )
  (let* ((op (operator-predicate id))
         (vs (aref (predicate-id-contents op) (- id (predicate-first-operator op)))))
    (format trace-stream "~S: (~S" (car (last vs)) (predicate-name op))
    (do ((vl vs (cdr vl))
         (al (predicate-arguments op) (cdr al)))
        ((or (null (cdr vl)) (null (cdr al))))
      (format trace-stream " (~S ~S)" (car (argument-name al)) (car vl))
      )
    (format trace-stream ")")
    ; If an evaluate-operator operator, print the operator being evaluated as well
    (when (eq (predicate-name op) 'evaluate-operator)
      (format trace-stream " [")
      (pid (car vs))
      (format trace-stream "]")
      )
    t)
  )

; Print all operators by their ids
(defun pids nil
  (let ((operator-type (type-from-name 'operator)))
    (when operator-type
      (dotimes (i (stype-max operator-type))
        (pid i)
        (format trace-stream "~&")
        )
      )
    t)
  )


; Count active variables in PLM
(defun active-variables (as)
  (let ((count 0))
    (dotimes (i (length as))
      (when (aref as i)
        (setq count (1+ count))
        )
      )
    count)
  )


; Determine active number of link directions in graph
(defun count-active-link-directions ()
  (let ((count 0))
    (dolist (l (graph-links cg))
      (when (link-fact-content l) (setq count (+ count 1)))
      (when (link-var-content l) (setq count (+ count 1)))
      )
    count)
  )

; Nodes with maximum variables, from graph-statistics
; Vector with variable and then factor nodes
(defvar max-node-variables)

; Determine numbers of nodes, average and maximum variables for variable and factor nodes
(defun count-node-variables ()
  (let ((nums (init-vector 2 0))
        (sums (init-vector 2 0))
        (maxs (init-vector 2 0))
        (maxns (init-vector 2 nil)) ; Lists of nodes with maximum variables
        vorf ; 0 for variable 1 for factor
        vars) ; Number of variables at node
    (dolist (n (graph-nodes cg))
      (if (factor-nodep n)
          (setq vorf 1)
        (setq vorf 0))
      (setf (aref nums vorf) (+ (aref nums vorf) 1))
      (setq vars (length (node-variables n)))
      (setf (aref sums vorf) (+ (aref sums vorf) vars))
      (when (= vars (aref maxs vorf))
        (setf (aref maxns vorf) (cons (node-name n) (aref maxns vorf)))
        )
      (when (> vars (aref maxs vorf))
        (setf (aref maxs vorf) vars)
        (setf (aref maxns vorf) (list (node-name n)))
        )
      )
    (dotimes (i 2)
      (setf (aref sums i)
            (coerce (/ (aref sums i) (aref nums i)) 'short-float)) ; Convert sums to averages
      )

    (setq max-node-variables maxns) ; Store maxes globally in case want to look at them
    (list nums sums maxs))
  )

; Determine links per nodes, average and maximum incoming and outgoing for variable and factor nodes
(defun count-node-links ()
  (let ((nums (init-vector 2 0)) ; Number of variable/factor nodes
        (insums (init-vector 2 0))
        (inmaxs (init-vector 2 0))
        (outsums (init-vector 2 0))
        (outmaxs (init-vector 2 0))
        vorf ; 0 for variable 1 for factor
        ins ; Number of incoming links at node
        outs) ; Number of outgoing links at node
    (dolist (n (graph-nodes cg))
      (setq ins 0)
      (setq outs 0)
      (if (factor-nodep n)
          (setq vorf 1)
        (setq vorf 0))
      (setf (aref nums vorf) (+ (aref nums vorf) 1))
      (dolist (l (node-links n))
        (when (aref (link-contents l) (- 1 vorf)) (setq ins (+ ins 1))); Incoming message
        (when (aref (link-contents l) vorf) (setq outs (+ outs 1))) ; Outgoing message
        )
      (setf (aref insums vorf) (+ (aref insums vorf) ins))
      (setf (aref outsums vorf) (+ (aref outsums vorf) outs))
      (when (> ins (aref inmaxs vorf)) (setf (aref inmaxs vorf) ins))
      (when (> outs (aref outmaxs vorf)) (setf (aref outmaxs vorf) outs))
      )
    ; Convert sums to averages
    (dotimes (i 2)
      (setf (aref insums i)
            (coerce (/ (aref insums i) (aref nums i)) 'short-float))
      (setf (aref outsums i)
            (coerce (/ (aref outsums i) (aref nums i)) 'short-float))
      )
    (list nums insums inmaxs outsums outmaxs))
  )


; Count the number of regions in a PLM and the number that are not empty
(defun count-plm-regions (p)
  (let ((total 0)
        (nonempty 0)
        (counts (init-vector 2))
        (rarray (plm-array p))
        (piecewise-constant (plm-piecewise-constant p)))
    (dotimes (i (plm-size p))
      (setq total (1+ total))
      (unless (region-e-empty (row-major-aref rarray i) piecewise-constant)
        (setq nonempty (1+ nonempty))
        )
      )
    (setf (aref counts 0) total)
    (setf (aref counts 1) nonempty)
    counts)
  )

; Short cut for counting regions of a plm
(defun cplmr (p) (count-plm-regions p ))

; Normalized variable posterior for shared WM VN node given predicate
(defun vn-posterior (pred)
  (variable-posterior (predicate-outgoing-vn pred))
  )
(defun vnp (pred-name)
  (vn-posterior (predicate-from-name pred-name))
  )


; Determine if a factor node has any outgoing links
(defun factor-outgoing-link (n)
  (let (out)
    (dolist (l (node-links n))
      (when (aref (link-contents l) fact-index)
        (return (setq out t))
        )
      )
    out)
  )


; Return list of WMVN nodes for a predicate
(defun predicate-wm-vns (pred)
  (let (wm-vns)
    (when (predicate-outgoing-vn pred)
      (setq wm-vns (cons (predicate-outgoing-vn pred) wm-vns))
      )
    (when (and (predicate-incoming-vn pred)
               (or (not wm-vns)
                   (not (= (node-number (car wm-vns)) (node-number (predicate-incoming-vn pred))))
                   )
               )
      (setq wm-vns (cons (predicate-incoming-vn pred) wm-vns))
      )
    (reverse wm-vns))
  )


; Function used in determining exponential prior for time
(defun exp-weights (n)
  (let ((weights (init-vector n 0))
        sum
        )
    (dotimes (i n)
      (setf (aref weights i) (exp (+ i 1))))
    (setq sum (reduce '+ weights))
    (dotimes (i n)
      (setf (aref weights i) (/ (aref weights i) sum)))
    weights)
  )

; Evaluate an expression while generating no result
(defun q (exp)
  exp
  nil
  )

; Evalaute a form n times and return after total time and msecs per message
(defun average-run (n form)
  (let ((total 0)
        (mpm 0)
        run-time decision-time messages
        )
    (dotimes (i n)
      (apply form nil)
      (setq run-time (sum-decision-statistics #'decision-statistics-run-time))
      (setq decision-time (sum-decision-statistics #'decision-statistics-decision-time))
      (setq messages (sum-decision-statistics #'decision-statistics-messages))
      (setq total (+ total run-time decision-time))
      (setq mpm (+ mpm (/ (* 1.0 run-time) messages)))
      )
    (list (/ (* .001 total) n) (/ mpm n))
    )
  )

; compile virtual robot functions NEED TO LOAD IN PKG
;(load (merge-pathnames virtualrobot-file (user-homedir-pathname)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; GET / SET Global variables
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defparameter *global-variables* '((ADAPTIVE-LEARNING-RATE . ("T or NIL (default NIL)" ("Dynamically determine learning rate at each node (when not" "overridden by learning rate on conditional) [Only one of this and" "LEARNING-RATE-FRACTION-OF-SMOOTHING-PARAMETER should set]" "[*** Not recommended at present ***]"))) 
                                   (ADAPTIVE-SMOOTHING . ("T or NIL (default T)" ("Dynamically determine smoothing (for learning) at each node")))
                                   (ALL-CONDACT-FILTERS-PAD-1 . ("T or NIL (default NIL)" ("Invert filter messages for condact messages moving away from WM")))
                                   (ALWAYS-MAX-OPERATORS . ("T or NIL (default NIL)"  ("If true, only use max when summarizing out operators")))
                                   (AROUSAL . ("Positive number or NIL (default NIL)"  "Level of arousal (set manually)"))
                                   (automatic-action-models . ("T or NIL (default NIL)"  ("Automatically create conditions for action modeling" "(aka learning of transition functions)")))
                                   (automatic-perception-models . ("T or NIL (default NIL)"  ("Automatically create conditions for perception modeling" "(including map learning)")))
                                   (AUTOMATICALLY-REORDER-CONDITIONS . ("T OR NIL (default T)"  ("Automatically reorder conditions in conditionals for efficiency")))
                                   (BIPARTITE-GRAPH-DISPLAY . ("T or NIL (default T)"  ("Use new form of factor graph display in graph/g")))
                                   (BREAK-ON-POSITIVE-MESSAGES . ("T or NIL (default NIL)"  ("A list of node-number pairs (each a list). Breaks before any decision" "with a non-empty message between those nodes at quiescence")))
                                   (CENTER-DISCRETE-NUMERIC-ON-INTEGER . ("T or NIL (default NIL)"  ("If true, center unit regions for discrete numbers around the integers" "rather than beginning the regions at the integers (needs to be set via" "optional argument to init rather than directly)")))
                                   (COMPUTE-ATTENTION . ("T or NIL (default NIL)" ("Compute attention")))
                                   (COMPUTE-PROGRESS . ("T or NIL (default NIL)" ("Compute progress for goals")))
                                   (COMPUTE-SURPRISE . ("T or NIL (default NIL)" ("Compute surprise for learned functions")))

                                   (DEBUG-DESCENDANTS . ("List of node numbers (default NIL)"  ("Trace descendant and message initialization computations for node" "numbers in list")))
                                   (DEBUG-INIT-DESCENDANTS . ("SUMMARY, ALL or NIL (default NIL)" ("Trace descendant initialization, either just summary statistics (\'summary)" "or also how many descendants each has (\'all)")))
                                   (DEFAULT-INTEGRAL . ("T or NIL (default T)" ("Use integral by default (rather than max) for unique variables")))
                                   (DETECT-IMPASSES . ("T or NIL (default NIL)" ("Whether to impasse on operator selection if tie (needs to be set via" "optional argument to init-operators rather than directly)")))
                                   (DIACHRONIC-PREDICTION . ("T or NIL (default NIL)" ("Predict results of actions/operators")))
                                   (DISCOUNT-WM . ("T or NIL (default T)" ("Discount (by wm-discount-factor) messages from WMFNs to" "FANs for selection predicates")))
                                   (EPISODIC-LEARNING . ("T, OPEN, CLOSED or NIL (default NIL)" ("Perform episodic learning Should use the function learn to set and" "unset this variable")))
                                   (EPSILON . ("positive float (default .0000001)" ("Accuracy within which to compute absolute value comparisons" "(when USE-RELATIVE-EPSILON is nil)")))
                                   (EPSILON2 . ("positive float (deafult .0001)" ("Span of continuous maximal regions")))
                                   (EXPONENTIAL-PRODUCT-GRADIENT . ("T or NIL (default T)" ("Use product of exponential gradient")))
                                   (EXTEND-TYPE-CONSTANTS-BY-EVIDENCE . ("T or NIL (default NIL)" ("Instead of signaling an error if a constant is used in evidence or" "perceive that isn\'t in the type, extend the type to include it")))
                                   (FAN-CONSTANT . ("positive float (default .001)" ("Constant at open-world FAN nodes so that lack of actions" "doesn't nullify WMVN")))
                                   (FEEDBACK-TO-FUNCTIONS . ("T or NIL (default T)" ("Send feedback messages to factor function nodes")))
                                   (FIELD-BEYOND-LABEL . ("positive integer (default 3)" ("Extent of field beyond length of largest label")))
                                   (FUNCTION-DEFAULT . ("non-negative number (default 0)" ("Value to use by default for unspecified regions of conditional" "functions")))
                                   (GDL-DIVIDE . ("NEW, NEWER, T or NIL (default NEWER)" ("Divide gradient by function-message product (new version" "uses a different divisor within each region of universal variable values)")))
                                   (GDL-SUBTRACTIVE-NORMALIZATION . ("T or NIL (default T)" ("Use subtractive rather than divisive normalization in" "gradient-descent learning")))
                                   (GRADIENT-SUBTRACT-AVERAGE . ("T or NIL (default T)" ("Subtract average of gradient before updating")))
                                   (INTEGRATE-UNIVERSAL-IN-UNIQUE . ("T or NIL (default NIL)" ("Integrate rather than max over universal variables in unique functions")))
                                   (LEARN-OPEN . ("T or NIL (default NIL" ("Learn for open-world predicates as well as closed-world ones")))
                                   (LEARN-VIA-GRADIENT-DESCENT . ("T or NIL (default NIL)" ("Use gradient descent on function factor functions Should use" "the function learn to set and unset this variable")))
                                   (LEARNING-RATE . ("positive float (default 0.5)" ("Learning rate for gradient descent")))
                                   (LEARNING-RATE-FRACTION-OF-SMOOTHING-PARAMETER . ("T or NIL (default NIL)" ("If a number, the learning rate is set to this times the smoothing parameter" "[Only one of this and adaptive-learning-rate should be set] [Intended to be" "used in conjunction with adaptive smoothing, and to be <1]")))
                                   (MAX-DECISIONS . ("positive integer (default 500)"  ("Maximum number of decisions to execute when no value specified")))
                                   (MAX-ELABORATION-CYCLES . ("positive integer (default 50)" ("Maximum number of (parallel) cycles per decision")))
                                   (MAX-FINAL-DISCRETE . ("positive integer (default 10)" ("Maximum number of items in the final region along a discrete numeric" "dimension to list explicitly")))
                                   (MAX-FRACTION-PA-REGIONS . ("in [0,1] (default .5)" ("Threshold for shifting from regions in parray within print-smart")))
                                   (MAX-GDL-INCREMENT . ("positive number or NIL (default NIL)" ("Maximum learning increment in gradient descent (if specified)")))
                                   (MAX-MESSAGES . ("positive integer (default 10000)" ("Default maximum number of messages (per decision)")))
                                   (MAX-MESSAGES-LINKS . ("positive integer (default 20)" ("When non-NIL, set max-messages to this times number of links")))
                                   (MAX-SPAN-PA . ("positive integer (default 10)" ("Threshold on size of symbolic dimension in shifting from parray in print-smart")))
                                   (MESSAGE-PROTOCOL . ("SERIAL or PARALLEL (default SERIAL)" ("Pass messages serially versus simulated parallel")))
                                   (MINIMAL-PARRAY-FIELD . ("positive integer (default 14)"  ("Minimum size of a field for a PLM array print")))
                                   (MULTIAGENT . ("T or NIL (default NIL)" ("Default to multiple agents (mostly set automatically within init)")))
                                   (NON-OPERATOR-BEST-SELECT . ("RANDOM or FIRST (default RANDOM)"  ("Choose randomly among maximals for regions in predicates other" "than selected (or first maximal)")))
                                   (ONE-WAY-C-A-BETAS . ("T or NIL (default T)" ("Use unidirectional beta networks within conditions and actions")))
                                   (OPEN-ACTIONS-LIKE-CONDACTS . ("T or NIL (default NIL)" ("Invert filter messages for open-world actions, and combine via product," "as normally do action part of condacts")))
                                   (OPEN-CONDITIONS-LIKE-CONDACTS . ("T or NIL (default NIL)" ("Connect outgoing message from WMFN directly to WMVN (via product)" "instead of going through a VAN/FAN (probabilistic or) path (and invert" "filter messages for open-world conditions if all-condact-filters-pad-1 is T)")))
                                   (OPEN-WORLD-WMFNS . ("T or NIL (default NIL)" ("Create WMFN nodes for open-world predicates")))
                                   (OPERATOR-BEST-SELECT . ("RANDOM or FIRST (default RANDOM)" ("Choose randomly among maximals for operator in selected predicate" "(or first maximal)")))
                                   (parameter-override-reset . ("List of global variables (default NIL)" ("Keep current values for these variables (i.e., don't reset)")))
                                   (PRINT-REGIONS-ON-SEPARATE-LINES . ("T or NIL (default NIL)" ("Print each region in a PLM on a separate line")))
                                   (RANGE-FIELD-BEYOND-LABEL . ("positive integer (default 3)" ("This is the description")))
                                   (SAVE-MESSAGE-STATE . ("T or NIL (default T)" ("Only reinitialize messages across decisions that depend on changed" "functions")))
                                   (SMOOTHING-PARAMETER . ("positive float (default .000001)" ("Minimum value in a learned function")))
;                                   (SPARSE-PRODUCT . ("T OR NIL (Default T)" ("Use optimization for multiplying a sparse function times another function")))
;                                   (SPARSE-PRODUCT-THRESHOLD . ("Number in [0,1]" ("When SPARSE-PRODUCT is T, use optimization when function density" "below threshold")))
                                   (SPECIFY-FUNCTION-VARIABLE-NAMES . ("T or NIL (default T)" ("Explicitly specify variables used in function")))
                                   (SYMBOLIC-TRACE . ("T or NIL (default T)" ("Traces should be symbolic")))
                                   (TEMPERATURE-MINIMUM . ("positive float (default 1/60)" ("Temperature remains above this to avoid overflow")))
                                   (THRESHOLD-FOR-DENSE-CONNECTION . ("positive integer (default 5)" ("If the number of bidirectional links at a variable node is more" "than this threshold, break up into a binary tree of nodes and links")))
                                   (TRACE-AFFINE . ("T or NIL (default NIL)" ("Trace computation at affine transform factor node")))
                                   (TRACE-ATTENTION . ("T or NIL (default NIL)" ("Trace computation in determining attention")))
                                   (TRACE-AVERAGE . ("T or NIL (default NIL)" ("Trace the processing that creates an averaged version of a PLM")))
                                   (TRACE-COMBINE . ("T or NIL (default NIL)" ("Trace combination (product/sum). Print individual region" "combinations if \'region")))
                                   (TRACE-CYCLES . ("T or NIL (default T)" ("Trace elaboration cycles")))
                                   (TRACE-DECISIONS . ("T or NIL (default T)" ("Trace decision cycles")))
                                   (TRACE-EL . ("T or NIL (default NIL)" ("Trace episodic learning")))
                                   (TRACE-EMPTY . ("T or NIL (default NIL)" ("Print regions in PLMs with 0 values"))) 
                                   (TRACE-FULL . ("T or NIL (default T)"  ("Print regions in PLMs with 1 values")))
                                   (TRACE-GDL . ("T, NIL or list of node num, node name or conditional names (default NIL)" ("Trace gradient-descent learning (for all nodes if T or just the" "specified function factor nodes)")))
                                   (TRACE-LINK-DEPTHS . ("T or NIL (default NIL)" ("Trace depths of links for messages")))
                                   (TRACE-MAXIMALS . ("T or NIL (default NIL)" ("Trace lists of maximal regions")))
                                   (TRACE-MESSAGE-TIMES . ("T or NIL (default NIL)" ("Trace times taken for messages")))
                                   (TRACE-MESSAGES . ("T or NIL (default NIL)" ("Trace messages (to and from nodes named/numbered)")))
                                   (TRACE-PERCEPTION . ("T or NIL (default NIL)" ("Trace perception")))
                                   (TRACE-PERFORMANCE . ("T or NIL (default T)" ("Trace performance data about decisions")))
                                   (TRACE-PREFERENCES . ("T or NIL (default NIL)" ("Trace preference messages for selected predicate"))) 
                                   (TRACE-QUEUE . ("T or NIL (default NIL)" ("Trace the queue to which each new message is added")))
                                   (TRACE-STATES . ("T or NIL (default T)" ("Trace addition and deletion of states from hierarchy")))
                                   (TRACE-SUMMARIZE . ("T or NIL (default NIL)" ("Trace summarization (integral/max)")))
                                   (TRACE-TRANSFORM . ("T or NIL (default NIL)" ("Trace transformations (including normalizations)")))
                                   (TRACE-TRIALS . ("T or NIL (default T)" ("Trace trials")))
                                   (TRACE-WM-CHANGES . ("T or NIL (default NIL)" ("Trace the process of deciding which WM changes to make (just" "for predicates listed if there is a list)")))
                                   (TRACE-WM-DRIVEN . ("T or NIL (default NIL)" ("Trace whether messages are wm-driven")))
                                   (TRACK-GRAPH-MESSAGES . ("T or NIL (default NIL)" ("Store messages at the end of each decision into a list")))
                                   (UNIQUE-WEIGHTS-ONLY . ("T or NIL (default T)" ("Generate error if region has a weight for a universal variable")))
                                   (UNSUP-CATEGORIES . ("positive integer (default 5)" ("Number of categories for unsupervised learning")))
                                   (USE-RELATIVE-EPSILON . ("T or NIL (default T)"  ("Use relative rather than absolute numeric comparisons")))
                                   (WM-DISCOUNT-FACTOR . ("positive float (default .01)" ("Factor to use when DISCOUNT-WM is T")))))

; Measure a memory program
(defun mm (program)
  (let ((tm trace-messages)
        (tc trace-cycles)
        )
    (setq trace-messages nil)
    (setq trace-cycles nil)
    (format trace-stream "~&Program ~S:~&" program)
    (eval program)
    (time (run 5000))
    (format trace-stream "~&Messages sent: ~S" message-count)
    (setq trace-messages tm)
    (setq trace-cycles tc)
    )
  )



; -----------------------------------------------------------
;; Bipartite Graph Display


;;; Reset all the global values;;;

(defun reset-gvalues()
  (setq bp-nodes nil)
  (setq bp-graph nil)
  (setq *bp-node-stream* nil)
  (setq *nodes-depth* 3)
  (setq *main-pinboard* nil)
  (setq *selected-node* nil)
;  (setq display-subgraph nil)  
)


; Print a node symbolically when single click on it
; This is a selection callback
(defun node-selection-callback (data interface)
  (declare (ignore interface))
  (print-node (node-from-name data)
              t
              *node-stream*
              )
  )

; Print a node non-symbolically when double click on it
; This is an action callback
(defun node-action-callback (data)
  (print-node (node-from-name data)
              nil
              *node-stream*
              )
  )

; Given a node and a link, find the other node in the link
(defun next-node (node link)
  (aref (link-nodes link)
        (if (variable-nodep node)
            1
          0)
        )
  )

; Return a list of the names of all of the neighbors of a node
; If graph-alpha is nil, doesn't include match delta nodes (and thus
; none of the alpha network since we start in the beta network)
(defun neighbor-name-list (nodename)
  (let ((node (node-from-name nodename))
        next
        namelist)
    (dolist (link (node-links node))
      (setq next (next-node node link))
      (when (or graph-alpha
                (not (eq (node-subtype next) 'delta))
                (not (eq (node-subsubtype next) 'match)))
        (setq namelist (cons (node-name next) namelist))
        )
      )
    (reverse namelist)
    )
  )
;add isolated nodes to graph
(defun add-isolated-nodes (roots)
  (dolist (n (graph-nodes cg))
    (unless (node-neighbors n)
      (setq roots (push (node-name n) roots))
      )
    )
  roots
  )

(defun add-remaining-nodes (roots)
  (dolist (n (graph-nodes cg))
      (setq roots (push (node-name n) roots))
    )
  roots
  )

; Generate a graphical representation of a graph starting at last node generated
(defun g (&optional size conditional-name)
  (when conditional-name (not (conditional-from-name conditional-name))
    (error "No conditional named ~S in (g)" conditional-name)
    )
  (reset-gvalues)
  (unless (graph-initialized cg)
    (init-graph)
    )
  (unless size (setq size 'medium))
  (if conditional-name
      (graph size (list (node-name (conditional-last-memory (conditional-from-name conditional-name)))))
    (graph size (add-remaining-nodes (mapcar #'(lambda (c) (node-name (conditional-last-memory c)))
                   (graph-conditionals cg)))))
  )

; Print a node non-symbolically when double click on it
; This is an action callback
(defun bp-node-action-callback (data interface)
  (declare (ignore interface))
  (print-node (node-from-name data)
              nil
              *node-stream*
              )
  (create-bipartite data)
  )

(defun bp-get-nodes (nodes)
  (setq bp-nodes nil)
  (let* ((factor nil) (variable nil) (wm nil) (alpha nil) (beta nil) (affine nil) (combine nil) (filter nil) (inversion nil) (transform nil) (perception nil) (function nil)
         )
    (dolist (n nodes)
      (when (factor-nodep n)  (push (node-name n) factor))
      (when (variable-nodep n) (push (node-name n) variable))
      (when (wm-nodep n) (push (node-name n) wm))
      (when (eq (node-subtype n) 'alpha) (push (node-name n) alpha))
      (when (eq (node-subtype n) 'beta) (push (node-name n) beta))
      (when (eq (node-subtype n) 'affine) (push (node-name n) affine))
      (when (eq (node-subtype n) 'combine) (push (node-name n) combine))
      (when (eq (node-subtype n) 'filter) (push (node-name n) filter))
      (when (eq (node-subtype n) 'inversion) (push (node-name n) inversion))
      (when (eq (node-subtype n) 'transform) (push (node-name n) transform))
      (when (eq (node-subtype n) 'perception) (push (node-name n) perception))
      (when (and (factor-nodep n) (eq (node-subtype n) 'function)) (push (node-name n) function))
      )
    (setq bp-nodes (list :factor factor :variable variable :wm wm :alpha alpha :beta beta
                         :affine affine :combine combine :filter filter :inversion inversion :transform transform :perception perception :function function)) 
    )
  )

; Find CF or WMFN node number from conditional or predicate name
(defun find-node-number (nid)
  (let (pred c)
    (when (symbolp nid)
      (setq pred (find nid (graph-predicates cg) :key #'predicate-name))
      (when (and pred (predicate-wm pred))
          (setq nid (node-number (predicate-wm pred)))
          )
      (setq c (conditional-from-name nid))
      (if c
        (if pred
            (format trace-stream "Found predicate WMFN (~S) and conditional function node (~S) by that name." nid (node-number (conditional-function-node c)))
          (setq nid (node-number (conditional-function-node c))))
        nil)
      )
    nid)
  )



(defun node-information (n)
  (let* ((node (node-from-name n)))    
    (format nil "Node name: ~S~%Node type: ~S~%Node Subtype: ~S~%" 
            (node-name node) (node-type node) (node-subtype node) ); (node-evidence node))
    )
  )

(defun get-bp-nodes (node)
  (setq bp-nodes (list node))
  
  ;append the neighbouring nodes
  (let* ((node-list (node-neighbors (node-from-name node))))
    (setq bp-nodes (append bp-nodes node-list))
    )

  ;iterate through all the nodes and get the respective neighbour nodes (3 iteration)
  (dotimes (i *nodes-depth*)
        (dolist (x bp-nodes)
          (let* ((y (node-neighbors (node-from-name x))))
            (setq bp-nodes (append y bp-nodes))
            )
          )
        )
  
  (setq bp-nodes (delete-duplicates bp-nodes))  
)

(defun bp-collector-stream (nodes)
  (dolist (node nodes)
    (print-node (node-from-name node)
                t
                *bp-node-stream*
                )
    )
  )

; Determine whether an edge should be a forward, backward, bidirectional or unpointed arrow
(defun link-direction (from-node to-node)
  (let (from-num to-num)
    (if (variable-nodep from-node)
        (progn
          (setq from-num 0)
          (setq to-num 1))
      (progn
        (setq from-num 1)
        (setq to-num 0)))
    (dolist (link (node-links from-node))
      (when (eq (aref (link-nodes link) to-num) to-node)
        (return (if (aref (link-contents link) from-num)
                    (if (aref (link-contents link) to-num)
                        ':both
                      ':forwards)
                  (if (aref (link-contents link) to-num)
                      ':backwards
                    ':neither)
                  )
                )
        )
      )
    )
  )


; Return node based on its number
(defun number-from-node (node)
  (dolist (n (graph-nodes cg))
    (when (eql node n)
      (return (node-number n)))))

(defun node-children-function (nodename)
  (let ((n nodename) name-list)
    (dolist (n2 bp-nodes)
       (when (eq (link-from-nodes-tf (node-from-name n) (node-from-name n2)) t)
         (setq name-list (cons n2 name-list))
         )       
       )
    (reverse name-list)
    )
  )

(defun link-from-nodes-tf (n1 n2)
  (let ((n2-name (node-name n2))
        (index (if (variable-nodep n2) 0 1))
        )
    (dolist (l (node-links n1))
      (when (eq (node-name (aref (link-nodes l) index)) n2-name)
        (return t)
        )
      )
    )
  )


; LOW LEVEL
; -----------------------------------------------------------
; Define graph structure

; Add a node to a graph
(defun add-node (node)
  (setf (node-number node) (graph-node-count cg))
  ; Tack node number onto front of name
  (setf (node-name node) (make-name-number-symbol (node-name node) (node-number node)))
  (setf (graph-last-node cg) node)
  (setf (graph-nodes cg) (cons node (graph-nodes cg)))
  (setf (graph-node-count cg) (+ (graph-node-count cg) 1))
  node)

; Determine if a node is a leaf (only linked to one other)
(defun leaf-node (n)
  (= (length (node-links n)) 1)
  )

; Add a link to a graph and to relevant nodes
(defun add-link (link)
  (setf (graph-links cg) (cons link (graph-links cg)))
  (dotimes (i 2)
    ; add- link to node in link
    (setf (node-links (link-node link i))
          (cons link (node-links (link-node link i))))
    )
  link)

; Make a new variable node for variables 'variables'
(defun init-variable-node (name subtype subsubtype action variables evidence &optional pattern-type)
  (let (vn)
    (setq vn (make-node :name name
                        :type 'variable
                        :subtype subtype
                        :action action
                        :subsubtype subsubtype
                        :evidence evidence
                        :variables variables
                        :pattern-type pattern-type))
    (add-node vn))
  )

; Is variable name in list of vectors?
(defun var-in-lov (v lov)
  (dolist (vs lov nil)
    (when (find v vs) (return t))
    )
  )

; Check one or more variables to see if they are in a list of vectors
; If only one, it will be by itself, otherwise a list
(defun vars-in-lov (vs lov)
  (if (listp vs)
      (dolist (v vs nil)
        (when (var-in-lov v lov) (return t))
        )
    (var-in-lov vs lov))
  )

; Create a map-vfactor
(defun build-smap-vfactor (vn-vars fn-vars)
  (let* ((rank (length vn-vars)) ; Number of variables in variable node
         (m-vfactor (init-vector rank)) ; Initial mapping from variable to factor node
         )
    ; Determine mapping from variable node variables to factor node variables
    (dotimes (i rank)
      (setf (aref m-vfactor i) (variable-number (aref vn-vars i) fn-vars))
      )
    m-vfactor)
  ) 

; Create a map-fvar.  For the vfactor, it provides an index that tells you how the fn variables that exist in the vn
; are ordered in the vn.  By using it, can cycle through the vn variables in the same order they are used in the fn.
(defun build-smap-fvar (v)
  (let* ((s (sort (copy-seq v) #'<))
         (d (length s))
         (o (init-vector d)))
    (dotimes (i d)
      (setf (aref o i) (position (aref s i) v))
      )
    o)
  )

; Create a vector of length corresponding to fn-vars, with a NIL when in vn-vars
; and how many vn-vars have already been seen otherwise
(defun build-smap-omitted (m-vfactor fn-vars)
  (let* ((rank (length fn-vars))
         (omitted (init-vector rank))
         (count 0)
         )
    (dotimes (i rank)
      (if (find i m-vfactor)
          (progn
            (setq count (+ count 1))
            (setf (aref omitted i) nil)
            )
        (setf (aref omitted i) count)
        )
      )
    omitted)
  )

; Build a map from a variable node to a factor node
(defun build-smap (vn-vars fn-vars)
  (if (= (length vn-vars) 0)
      nil
    (let ((m-vfactor (build-smap-vfactor vn-vars fn-vars)))
      (make-smap :vfactor m-vfactor
                 :fvar (build-smap-fvar m-vfactor)
                 :omitted (build-smap-omitted m-vfactor fn-vars))
      )
    )
  )

; Determine if variables in first vector exist in same order in second vector
; Used for determining if variables in variable nodes and factor nodes are order compatible
; If not, and can't reorder one or the other, need to add a dynamic reordering during execution
(defun variable-subset-order-compatible (vars1 vars2)
  (let ((vars2-rank (length vars2)) ; Length of second vector
        (vars2-i 0) ; Start search second vector from front
        vn1) ; Name of variable from first vector
    (dotimes (vars1-i (length vars1)) ; Iterate through first vector
      (setq vn1 (svariable-name (aref vars1 vars1-i))) ; Name of current variable in first vector
      (loop until (or (>= vars2-i vars2-rank) ; Quit when have finished search second vector or found name
                      (if (listp (aref vars2 vars2-i)) ; If this is a delta or transform factor with lists of variables
                          (member vn1 (aref vars2 vars2-i) :key #'svariable-name) ; See if name in list
                        (eq vn1 (svariable-name (aref vars2 vars2-i))))) ; See if same name
            do (setq vars2-i (+ vars2-i 1))) ; Increment pointer to second list
      )
    (if (>= vars2-i vars2-rank) nil t)) ; If have finished search of second, then not found
  )


(defvar reorder-factor-steps nil)

; Create a factor node
; Evidence is the variable node that provides evidence for this factor, or t if this is a WM factor or nil if there is none
; If in is true then messages flow from non-evidence variables and towards evidence variables (for actions and condacts)
; If out is true then messages flow from evidence variables and towards non-evidence variables (for conditions and condacts)
; If both in and out are true, messages flow to and from all variables
; If it is a beta node, then beta is true and in/out just reflect what happens for alpha-memory
; Doesn't initialize function.  Do this after so that the regions in the function can be grounded in this node.
(defun init-factor-node (name subtype variables var-nodes evidence in out beta action c &optional subsubtype)
  (let ((fn (make-node :name name :type 'factor :subtype subtype :variables variables
                       :evidence evidence :subsubtype subsubtype :action action)) ; Factor node
        step ; Maximization step
        steps ; Generic list of steps to be taken for this node, but modified by which output computing
        link ; Link between factor and variable node
        map ; Map from variable node variables to factor node variables
;        evnode ; Whether the current variable node is the evidence (alpha memory)
;        condactp ; Whether beta factor (if it is one) is for a condact
        alpha-mem new-beta-mem old-beta-mem ; Memory nodes tied to a beta factor
        vs-links ; Vector of lists of links whose variable nodes use particular factor variables
        vsl-i ; Index into vs-links
        link-product ; List of variable node names that have been included as product factor steps
        link-node-name ; Link node name for use in link-product
        fv ; Factor node variable
        reordered-variables ; Variables by increasing volume
        unique-variables ; There is at least one unique variable
        )
    ; Reorder variables so as to (hopefully) reduce cost of products
    (when (and reorder-factor-steps (not (find-if #'listp variables)))
      (setq reordered-variables (reorder-factor-variables variables))
      )
    (when c
      (setf (node-integral fn) (not (conditional-map c)))
      )
    (setq vs-links (init-vector (length variables)))
    (add-node fn)
    (when beta
;      (setq condactp (and in out))
      (setq alpha-mem (beta-memories-alpha beta))
      (setq old-beta-mem (beta-memories-old-beta beta))
      (setq new-beta-mem (beta-memories-new-beta beta))
      )
    ; Cycle through variable nodes, creating maps and links
    (dolist (vnode var-nodes)
      (setq map (build-smap (node-variables vnode) variables)) ; Build map from variable node variables to factor node variables
      (setq link (make-link :map map
                            :nodes (vector vnode fn) :contents (vector nil nil)
                            :depths (vector nil nil)
                            :loop-depths (vector nil nil)
                            :inits (vector -1 -1)
                            :incoming (vector nil nil)
                            :in (if beta
                                    (if one-way-c-a-betas
                                        (if (equal vnode alpha-mem) 
                                            in ; Connect alpha in its direction
                                           (if (equal vnode old-beta-mem) ; Always get input from old beta 
                                               t
                                             (if (equal vnode new-beta-mem)
                                                 (eq (node-pattern-type vnode) 'condact) ; Only get input from new beta if condact
                                               nil
                                               ))) 
                                      (or in (not (equal vnode alpha-mem)))) ; Bidirectional except for wrong way on alpha
                                  in )
                            :out (if beta
                                    (if one-way-c-a-betas
                                        (if (equal vnode alpha-mem) 
                                      out ; Connect alpha in its direction
                                           (if (equal vnode new-beta-mem) ; Always send output to new beta
                                               t
                                            (if (equal vnode old-beta-mem)
                                                 (eq (node-pattern-type vnode) 'condact)
                                              out
                                                 ))) ; Only send output to old beta if condact
                                      (or out (not (equal vnode alpha-mem)))) ; Bidirectional except for wrong way on alpha
                                  (and out (not (eq (node-subtype vnode) 'offset))))
                            :counts (vector 0 0)
                            :stale (vector nil nil)
                            :prequeue (vector nil nil)
                            )
            )
      ; Add link to graph
      (add-link link)
      ; Add link to lists for mapped factor variables when used in variable node
      (dotimes (i (length (node-variables vnode)))
        (setq vsl-i (aref (smap-vfactor map) i))
        (setf (aref vs-links vsl-i) (cons link (aref vs-links vsl-i)))
        )
      )
    (setf (node-links fn) (reverse (node-links fn))) ; Make link ordering the same as variable node ordering
    ; Cycle through unique variables in factor node, setting up products and summarizations
    (dotimes (i (length variables))
      (setq fv (aref (if reordered-variables reordered-variables variables) i))
      (unless (multiple-variable fv)
        (unless unique-variables (setq unique-variables t))
        (dolist (link (aref vs-links (if reordered-variables (position (svariable-name (aref reordered-variables i)) variables :key #'svariable-name) i)))
          (setq link-node-name (node-name (link-var-node link)))
          (unless (member link-node-name link-product) ; Not already added link product to factor steps
            (setq steps (append steps (list (make-factor-step :type 'product :argument link))))
            (setq link-product (cons link-node-name link-product))
            )
          )
        ; Set max by default and then switch to integral under the right circumstances
        (setq step (make-factor-step :type 'max :argument i))
        (when (and (node-integral fn) ; The summarization operator for this node is integral
                   default-integral ; Don't switch all integrals to maxes
                   c ; This use is part of a conditional rather than initializing WM
                   (or (not always-max-operators) ; Not always using max for operators/actions
                       (not (eq (stype-name (svariable-type fv))
                                (graph-operator-type-name cg))); Not operator variable
                       )
                   )
          (setf (factor-step-type step) 'integral))
        (setq steps (append steps (list step)))
        )
      )
    ; Cycle through universal variables in factor node, setting up products and summarizations
    (dotimes (i (length variables))
      (setq fv (aref (if reordered-variables reordered-variables variables) i))
      (when (multiple-variable fv)
        (dolist (link (aref vs-links (if reordered-variables (position (svariable-name (aref reordered-variables i)) variables :key #'svariable-name) i)))
          (setq link-node-name (node-name (link-var-node link)))
          (unless (member link-node-name link-product) ; Not already added link product to factor steps
            (setq steps (append steps (list (make-factor-step :type 'product :argument link))))
            (setq link-product (cons link-node-name link-product))
            )
          )
        ; Use max unless integrating universal in unique and there are unique variables
        (setq step (make-factor-step :type (if (and integrate-universal-in-unique unique-variables) 'integral 'max) :argument i))
        (setq steps (append steps (list step)))
        )
      )
    ; Cycle through variable nodes, setting up products for any that don't already have them
    ; This should only be variable nodes with no variables
    (dolist (vlink (node-links fn))
      (setq link-node-name (node-name (link-var-node vlink)))
      (unless (member link-node-name link-product)
        (setq steps (append steps (list (make-factor-step :type 'product :argument vlink))))
        )
      )
    (setf (node-factor-steps fn) steps)
    fn)
  )

; Create a graph
(defun create-graph ()
  (make-graph :node-count 0
              )
  )

; Get Node and Link info
; -----

; Return node based on its name
(defun node-from-name (name &optional type)
  (dolist (n (graph-nodes cg))
    (when (and (eq name (node-name n)) ; Node is of the right name
               (or (not type) ; Don't care what kind of node it is
                   (eq (node-type n) type))) ; Node is of right type
      (return n))))

; Return node based on its number
(defun node-from-number (number)
  (if (graph-node-vector cg)
      (aref (graph-node-vector cg) number)
    (dolist (n (graph-nodes cg))
      (when (= number (node-number n))
        (return n))))
  )
(defun nfn (number) (node-from-number number))

; Node function from number
(defun node-function-from-number (number)
  (node-function (node-from-number number))
  )
(defun nffn (number)
  (node-function-from-number number)
  )

; Retrieve a link based on the two nodes that participate in it
(defun link-from-nodes (n1 n2)
  (let ((n2-name (node-name n2))
        (index (if (variable-nodep n2) 0 1))
        )
    (dolist (l (node-links n1))
      (when (eq (node-name (aref (link-nodes l) index)) n2-name)
        (return l)
        )
      )
    )
  )

; Dimensions
; ----------

; Access dimension min and max from slices
(defun dimension-min (type) (slice-location (dimension-min-slice type)))
(defun dimension-max (type) (slice-location (dimension-max-slice type)))

; Access a dimension of a region
(defun dimension (r d)
  (aref (region-dimensions r) d))

; Span of a region's dimension
(defun dimension-span (d)
  (- (slice-location (dimension-max-slice d)) (slice-location (dimension-min-slice d)))
  )

; Retrieve a link boad on the numbers of the two nodes that participate in it
(defun link-from-numbers (num1 num2)
  (link-from-nodes (node-from-number num1) (node-from-number num2))
  )

; Return list of names of node's neighbors (in order of links)
(defun node-neighbors (n)
  (mapcar #'(lambda (l) (node-name (aref (link-nodes l) (if (variable-nodep n) 1 0)))) (node-links n))
  )

; Get node from a link based on index
(defun link-node (l i)
  (aref (link-nodes l) i))   

; Retrieve the variable and factor nodes from a link
(defun link-var-node (l)
  (link-node l var-index))
(defun link-fact-node (l)
  (link-node l fact-index))

; Get content from a link based on index
(defun link-content (l i)
  (aref (link-contents l) i))

; Retrieve the outgoing variable and factor contents from a link
(defun link-var-content (l)
  (link-content l var-index))
(defun link-fact-content (l)
  (link-content l fact-index))

; -----------------------------------------------------------
; Compute node dependencies

; Is node a WM node?
(defun wm-nodep (node)
  (eq (node-subtype node) 'wm)
  )

; Is node a WM FN node?
(defun wm-fnp (node)
  (and (factor-nodep node) (wm-nodep node))
  )

; Is node an ever, selection, state WM FN node?
(defun ess-wm-fnp (node)
  (let ((pred (node-predicate node)))
    (and (wm-fnp node)
         pred
         (predicate-persistent pred)
         (predicate-select pred)
         (state-predicate pred)
         )
    )
  )

; Is node a conditional function factor (CFF)?
(defun function-nodep (node)
  (and (factor-nodep node) (eq (node-subtype node) 'function))
  )

; Is node a perceptual function factor?
(defun perception-functionp (node)
  (and (factor-nodep node) (eq (node-subtype node) 'perception))
  )

; Recur on node-dependencies
(defun node-dependencies-recur (node dependencies)
  (let ((index (if (variable-nodep node) 1 0)) ; Index of incoming messages
        )
    (setq dependencies (adjoin node dependencies))
    (unless (wm-fnp node) ; Stop recursion at WMFN nodes
      (dolist (link (node-links node))
        (when (and
               (not (member (link-node link index) dependencies)) ; Haven't already processed linked node
               (link-content link index) ; There is a message from the linked node
               )
          (setq dependencies (node-dependencies-recur (link-node link index) dependencies))
          )
        )
      )
    dependencies)
  )

; Compute a list of nodes upon which the current node depends
; Follow links backwards that point to this node (uni or bidirectional)
(defun node-dependencies (node)
  (let ((index (if (variable-nodep node) 1 0)) ; Index of incoming messages
        dependencies
        )
  (dolist (link (node-links node))
    (when (link-content link index) ; There is a message from the linked node
      (setq dependencies (node-dependencies-recur (link-node link index) dependencies))
      )
    )
  dependencies)
  )

; List of assumption factor nodes upon which node depends
(defun function-dependencies (node)
  (let (fds)
    (dolist (dn (node-dependencies node))
      (when (node-assumption dn)
        (setq fds (cons dn fds))
        )
      )
    fds)
  )

; List of WM factor nodes upon which node depends
(defun wm-dependencies (node)
  (let (fds)
    (dolist (dn (node-dependencies node))
      (when (wm-fnp dn)
        (setq fds (cons dn fds))
        )
      )
    fds)
  )

; List of ever, selection, state WM factor nodes upon which node depends
(defun ess-wm-dependencies (node)
  (let (fds)
    (dolist (dn (node-dependencies node))
      (when (ess-wm-fnp dn)
        (setq fds (cons dn fds))
        )
      )
    fds)
  )

; Add node (with number of parent) to descendants list if not there
; If there already, augment its list of parents
(defun add-node-descendant (node old-descendant parent-number desc)
  (if old-descendant
      (if (member parent-number (descendant-parents old-descendant)) ; This parent is already included
          desc
        (progn
          (setf (descendant-parents old-descendant)
                (cons parent-number (descendant-parents old-descendant))
                )
          desc)
        )
    (cons (make-descendant :node node :parents (list parent-number)) desc)
    )
  )

; Copy a list of descendants
(defun copy-descendants (dl)
  (mapcar #'(lambda (d) (make-descendant :node (descendant-node d) :parents (descendant-parents d))) dl)
  )

; Union two lists of descendants
(defun union-descendants (l1 l2)
  (let ((ul (copy-descendants l1))
        ud
        d2node)
    (dolist (d2 l2)
      (setq d2node (descendant-node d2))
      (setq ud (find (node-name d2node) ul :key #'(lambda (x) (node-name (descendant-node x)))))
      (if ud ; There is already a node in the list of the same name
          (setf (descendant-parents ud)
                (union (descendant-parents ud) (descendant-parents d2)))
        (setq ul (cons d2 ul)) ; Add new node to list of nodes
        )
      )
    ul)
  )

; Recur on descendants
; desc is current list of descendants
(defun descendants-recur (grandparent-number node desc)
  (let ((index (if (variable-nodep node) 1 0)) ; Index of outgoing messages
        (parent-number (node-number node))
        child-node
        old-descendant
        )
    (dolist (link (node-links node))
      (setq child-node (link-node link index))
      (when (and (link-content link (- 1 index)) ; There is a message to the linked node
                 (not (= grandparent-number (node-number child-node))) ; The child is not the grandparent
                 )
        (setq old-descendant
              (find (node-name child-node) desc
                    :key #'(lambda (nl) (node-name (descendant-node nl))))) ; Previous entry for node if there is one
        (setq desc (add-node-descendant child-node old-descendant parent-number desc))
        (when (and (not (wm-fnp child-node)) ; Don't recur at WMFN nodes
                   (not old-descendant) ; Don't recur if already processed node
                   )
          (setq desc (descendants-recur parent-number child-node desc))
          )
        )
      )
    desc)
  )

; Recur on descendants
; desc is current list of descendants
; aht is the hash table where info on nodes with known descendants is stored
; common-descendants is a list that keeps the node-numbers of the nodes that have the same descendants with the original assumption node 
; This test function combines recursion with dynamic programming to speed up the process
; NO PARENTS CASE (Full parents case is in sigma1_vu_overlay10.lisp)
; (grid2) if you don't sort the parents you don't get the same number of messages for (d 2) even if the parents are the same.

(defun descendants-recur-no-parents (grandparent-number node desc aht common-descendants)
  (let ((index (if (variable-nodep node) 1 0)) ; Index of outgoing messages
        (parent-number (node-number node))
        child-node
        old-descendant 
        known-descendants
        )
    (dolist (link (node-links node))  
      (setq child-node (link-node link index))
      (when (link-content link (- 1 index)) ; There is a message to the linked node
        ; If the child is a grandparent, set common-descendants. If the link is bidirectional (being grandparent one direction, being child is another direction and hence the link is bidirectional) the parent has the same descendants as the grandparent. 
        ;This propagates back to the original node of consideration in init-node-descendants-no-parents
        (if  (= grandparent-number (node-number child-node))          
            (setf (gethash grandparent-number common-descendants) (cons (node-number node) (gethash grandparent-number common-descendants))) 
          (progn; The child is not the grandparent so find descendants
            (setq old-descendant
                  (find (node-name child-node) desc
                        :key #'(lambda (nl) (node-name nl)))) ; Previous entry for node if there is one
            (if (not (wm-fnp child-node)) (setf known-descendants (gethash (node-number child-node) aht)) (setf known-descendants nil)) ;don't check the descendants of the child-node, if the child-node is a WMFN node
            (if known-descendants 
                (setf desc (union desc known-descendants :key #'(lambda (x) (node-number x)))) ;union current list of descendants with already known descendants
              (progn  
                (setf desc (if old-descendant desc (cons child-node desc)))
                (if (and (not (wm-fnp child-node)) ; Don't recur at WMFN nodes
                         (not old-descendant) ; Don't recur if already processed node
                         )
                    (setf desc (multiple-value-setq (desc aht common-descendants) (descendants-recur-no-parents parent-number child-node desc aht common-descendants)))
                  )
                )
              )
            )   
          )
        )
      )
    (values desc aht common-descendants)
    )  
  )

; Compute a list of nodes dependent upon (descended from) the current node 
; Follow links forwards from point this node (uni or bidirectional)
(defun descendants (node)
  (descendants-recur -1 node (list (make-descendant :node node :parents nil)))
  )

; Determine node descendants for assumption FNs
(defun init-node-descendants ()
  (let (temp-desc
        )
    (dolist (node (graph-nodes cg))
      (when (node-assumption node)
        (setf temp-desc (descendants node))
        (setf (node-descendants node) temp-desc)
        ;(setf (node-descendants node) (sort temp-desc #'< :key #'(lambda (x) (node-number (descendant-node x))))); sorting mostly for debugging purposes 
        (when (eq debug-init-descendants 'all)
          (format trace-stream "~&Node ~S: ~S descendants" (node-number node) (length (node-descendants node)))
          )
        )
      )
    (dolist (d debug-descendants)
      (format trace-stream "~&~S: " (node-name (node-from-number d)))
      (print-node-progenitors d)
      )
    )
  )

; Init-node-descendants-no-parents uses this function as part of the dynamic programming approach
; This function stores descendant lists in a hash table for future use.
(defun common-descendants-recur (parent-number aht common-descendants descen) 
  (let (tempo
        ) 
    (setf tempo (gethash parent-number common-descendants))
    (if (not tempo) ; if a leaf node for the current wm-cff node, store the descendants (with the correct parents) in the hash table. 
        (setf (gethash parent-number  aht) descen) )
    (dolist (te tempo)
      (if (not (= parent-number te)) 
          (common-descendants-recur te aht common-descendants descen) )
      )
    aht)
  )

; Version of init-node-descendants wihtout parents
(defun init-node-descendants-no-parents ()
  (let ((common-descendants (make-hash-table))
        (aht (make-hash-table))
        temp-desc
        temp-node
        )
    (dolist (node (graph-nodes cg))
      (when (node-assumption node)
        (setf temp-node (gethash (node-number node) aht))
        (if temp-node  (setf (node-descendants node) temp-node) 
          (progn
            (multiple-value-setq (temp-desc aht common-descendants) (descendants-recur-no-parents -1 node (list node) aht common-descendants))
            ;(setf (node-descendants node) (sort temp-desc #'< :key #'(lambda (x) (node-number x)))); sorting is mostly for debugging purposes
            (setf (node-descendants node) temp-desc)
            (setf (gethash (node-number node) aht) (node-descendants node))
            (setf aht (common-descendants-recur (node-number node) aht common-descendants (node-descendants node)))
            (setf common-descendants (make-hash-table))
            ))
        (when (eq debug-init-descendants 'all)
          (format trace-stream "~&Node ~S: ~S descendants" (node-number node) (length (node-descendants node)))
          )
        )
      )
    (dolist (d debug-descendants)
      (format trace-stream "~&~S: " (node-name (node-from-number d)))
      (print-node-progenitors d)
      )
    )
  )

; List of node names from list of nodes
; Used in debugging
(defun node-name-list (nodes)
  (mapcar #'node-name nodes)
  )

(defun link-recur (in-link parent-links lht)
  (let ( 
        node index des-link temp old-desc-link
             (current-links (list in-link))          
        )
    (setf node (link-node (descendant-link-link in-link) (descendant-link-direction in-link))) 
    (setf index (if (variable-nodep node) 1 0))  
    (dolist (link (node-links node))
      (setf temp '())
      (when (not (eq (descendant-link-link in-link) link)) ; don't recur on the incoming link     
        (when (link-content link (- 1 index)) ;if the link is active
          ;check if this link has an entry in link hash table, if not go with regular recur
          (unless (gethash (intern (concatenate 'string (princ-to-string (node-number node))"-" 
                                                   (princ-to-string (node-number (link-node link index))))) lht)
            (setq old-desc-link
                  (find-if  #'(lambda (nl) (and (eq (descendant-link-from nl) (node-number node)) 
                                                (eq (descendant-link-to nl) (node-number (link-node link index)))
                                                )
                                ) 
                            parent-links
                            ))
            (unless old-desc-link   ; don't recur if the link is visited before (prevent cycles)           
              (setf des-link (make-descendant-link :link link :direction index :from (node-number node) :to (node-number (link-node link index))))              
              (setf parent-links (cons des-link parent-links))              
              (unless (wm-fnp (link-node link index))
                (multiple-value-setq (temp lht) (link-recur des-link parent-links lht))
                ;(setf current-links (append temp current-links))
                (setf current-links (union current-links temp :test #'(lambda (x y) 
                                                                       (and (eq (descendant-link-from x) (descendant-link-from y)) 
                                                                            (eq (descendant-link-to x) (descendant-link-to y))
                                                                            (eq (descendant-link-direction x) (descendant-link-direction y))
                                                                            ))
                                       ))
                ;(setf parent-links (append temp parent-links)) 
                (setf parent-links (union parent-links temp :test #'(lambda (x y) 
                                                                      (and (eq (descendant-link-from x) (descendant-link-from y)) 
                                                                           (eq (descendant-link-to x) (descendant-link-to y))
                                                                           (eq (descendant-link-direction x) (descendant-link-direction y))                                                                                                                  ))
                                          ))
                )
              ;; add the link to the wm-fn node to the descendant-links list
              (when (wm-fnp (link-node link index)) 
                (setf current-links (append current-links (list des-link)))
                ) 
              )
            )
          ;check if this link has an entry in link hash table, if so append the links found there to the current list of links
          (when (gethash (intern (concatenate 'string (princ-to-string (node-number node))"-"
                                               (princ-to-string (node-number (link-node link index))))) lht)
            (setf temp (gethash (intern (concatenate 'string (princ-to-string (node-number node))"-"
                                                     (princ-to-string (node-number (link-node link index))))) lht))           
            ;(setf current-links (append temp current-links))
            (setf current-links (union current-links temp :test #'(lambda (x y) 
                                                                       (and (eq (descendant-link-from x) (descendant-link-from y)) 
                                                                            (eq (descendant-link-to x) (descendant-link-to y))
                                                                            (eq (descendant-link-direction x) (descendant-link-direction y))
                                                                            ))
                                       ))
            )
          )
        ;create an entry in the links hash table for the recently calculated link
        (setf (gethash (intern (concatenate 'string (princ-to-string (node-number node))"-"
                                             (princ-to-string (node-number (link-node link index))))) lht) temp)    
        )
      )
    (values current-links lht)
    )
  )

; Assign link descendants to assumption fn nodes
(defun init-link-descendants ()
  (let (
        lht index parent-links des-link current-links temp
        ) 
    ;keep a links hashtable for storage in dynamic programming. Key is the string "10-5", where 10 is the 'from' node-number and 5 is the 'to' node-number
    (setf lht (make-hash-table))    
    (dolist (node (graph-nodes cg))  
      (when (node-assumption node)        
        (setf index (if (variable-nodep node) 1 0))
        ;parent-links is used to detect cycles (not to recur from previously process link)
        (setf parent-links '()) 
        ;temp stores the combined descendant-link list starting from each outgoing node
        (setf current-links '())
        (dolist (link (node-links node))  
          (when (link-content link (- 1 index))            
            (setf des-link (make-descendant-link :link link :direction index :from (node-number node) :to (node-number (link-node link index)))) 
            (setf parent-links (append (list des-link) parent-links))
            ;get the descendant-link list for this starting link and the updated link hash-table.
            (multiple-value-setq (temp lht) (link-recur des-link parent-links lht))
            ;(setf current-links (append current-links temp))    
            (setf current-links (union current-links temp :test #'(lambda (x y) 
                                                                       (and (eq (descendant-link-from x) (descendant-link-from y)) 
                                                                            (eq (descendant-link-to x) (descendant-link-to y))
                                                                            (eq (descendant-link-direction x) (descendant-link-direction y))
                                                                            ))
                                       ))

            )                                      
          )   
        (setf (node-descendant-links node) current-links)
        )
      )
    )
  )


;-----------------------------------------------------------
; Densely connected subgraphs 

; A binary tree is created as a subgraph and placed between the densely connected variable node and the factor nodes connected to this variable node
; Each layer of the binary tree is either beta-factor nodes or variable nodes
; Each beta factor node connects exactly two variable nodes in the lower layer to a variable node in the upper layer
; All the variable nodes and beta-factor nodes used in the subgraph are created in this function.
(defun create-subgraph-for-densely-connected-variable-nodes (node)
  (let (temp
        links-to-factor-nodes
        unmodified-links
        subgraph-variable-nodes
        subgraph-variable-nodes-temp
        beta-node
        beta-function
        l
        temp-vn
        )
    (dolist (temp (node-links node))
      ; affine delta factor nodes were creating problems but it is solved by updating the evidence list of the adf nodes
      ; there might be other types of factor nodes problematic, haven't tested for everything
      ; constant and filter nodes are working fine
      (if (and (link-in temp) (link-out temp))
        (setf links-to-factor-nodes (cons temp links-to-factor-nodes)) (setf unmodified-links (cons temp unmodified-links))
        )
      )
    (setq l (floor (/ (length links-to-factor-nodes) 2)))
    (when (< l (/ threshold-for-dense-connection 2))
      (return-from create-subgraph-for-densely-connected-variable-nodes) ; return if there are not enough factor nodes to make a difference
      )
    ; Create a variable node for every two factor nodes connected to the original variable node
    (dotimes (i l)
      (setq temp (nth (* i 2) links-to-factor-nodes))
      (setf temp-vn (init-variable-node 'Subgraph-VN (node-subtype node) 'subgraph (node-action node) (node-variables node) nil 'condact)) ; assigning the subsubtype as subgraph-need to check on this
      (setf (node-normalize temp-vn) (node-normalize node)) ;Subgraph variable nodes are extension of wmwn so they need to be normalized if wmwn is normalized
      (setq subgraph-variable-nodes 
            (cons temp-vn
                  subgraph-variable-nodes))
      (setf (aref (link-nodes temp) var-index) ; Update the variable node end of the link; replace the original variable node (wm-vn) with the recently created variable node
            (car subgraph-variable-nodes))
      (when (member node (node-evidence (aref (link-nodes temp) 1)))
        (setf (node-evidence (aref (link-nodes temp) 1)) ; add the recently created variable to the list of evidence nodes for the factor node
              (cons (car subgraph-variable-nodes)
                    (node-evidence (aref (link-nodes temp) 1))))
        )
      (setf (node-links (car subgraph-variable-nodes))
            (cons temp (node-links (car subgraph-variable-nodes))))
      (setq temp (nth (+ (* i 2) 1) links-to-factor-nodes))
      (setf (aref (link-nodes temp) var-index) ; Update the variable node end of the link; replace the original variable node (wm-vn) with the recently created variable node
            (car subgraph-variable-nodes))
      (when (member node (node-evidence (aref (link-nodes temp) 1)))
        (setf (node-evidence (aref (link-nodes temp) 1)) ; add the recently created variable to the list of evidence nodes for the factor node
              (cons (car subgraph-variable-nodes)
                    (node-evidence (aref (link-nodes temp) 1))))
        )
      (setf (node-links (car subgraph-variable-nodes))
            (cons temp (node-links (car subgraph-variable-nodes))))
      )
    (setq temp (nth  (* l 2) links-to-factor-nodes)) ; the last factor node if there are odd number of factor-nodes
    (when temp ; if there exists an unprocessed factor node, create a variable node and connect the factor node to the variable node created
      (setf temp-vn (init-variable-node 'Subgraph-VN (node-subtype node) 'subgraph (node-action node) (node-variables node) nil 'condact)); assigning the subsubtype as subgraph-need to check on this
      (setf (node-normalize temp-vn) (node-normalize node)) ;Subgraph variable nodes are extension of wmwn so they need to be normalized if wmwn is normalized
      (setf subgraph-variable-nodes 
            (cons temp-vn
                  subgraph-variable-nodes))
      (setf (aref (link-nodes temp) var-index) ;Update the variable node end of the link; replace the original variable node (wm-vn) with the recently created variable node
            (car subgraph-variable-nodes))
      (when (member node (node-evidence (aref (link-nodes temp) 1)))
        (setf (node-evidence (aref (link-nodes temp) 1)) ; add the recently created variable to the list of evidence nodes for the factor node
              (cons (car subgraph-variable-nodes)
                    (node-evidence (aref (link-nodes temp) 1)))))
      (setf (node-links (car subgraph-variable-nodes)) (cons temp (node-links (car subgraph-variable-nodes))))
      )                                                
    (setf (node-links node) unmodified-links)
    (loop
     (setq subgraph-variable-nodes-temp nil)
     (when (eql (length subgraph-variable-nodes) 2)
       (return) ; connect the last two to the original variable node via the final beta factor node after this loop
       )
     (loop for i from 0 to (- (length subgraph-variable-nodes) 1) by 2 do ; create new variable node and connect it to two previous variable nodes via a beta factor node
           (if (nth (+ i 1) subgraph-variable-nodes) 
               (progn
                 (setf temp-vn (init-variable-node 'Subgraph-VN (node-subtype node) 'subgraph (node-action node) (node-variables node) nil 'condact)) ; assigning the subsubtype as subgraph-need to check on this
                 (setf (node-normalize temp-vn) (node-normalize node)) ;Subgraph variable nodes are extension of wmwn so they need to be normalized if wmwn is normalized
                 (setf subgraph-variable-nodes-temp 
                       (cons temp-vn
                             subgraph-variable-nodes-temp))        
                 (setq beta-node
                       (init-factor-node 'Subgraph-BF 'beta (node-variables node)
                                         (list (car subgraph-variable-nodes-temp) (nth i subgraph-variable-nodes) (nth (+ i 1) subgraph-variable-nodes))
                                         nil t t 
                                         (make-beta-memories :alpha (nth i subgraph-variable-nodes) :old-beta (nth (+ i 1) subgraph-variable-nodes) :new-beta (car subgraph-variable-nodes-temp)) 
                                         nil nil))
                 (setq beta-function (full-plm (node-variables node)))
                 (setf (node-function beta-node) beta-function)
                 )
             (setq subgraph-variable-nodes-temp ; variable node without a pair should be processed in the next sweep
                   (cons (nth i subgraph-variable-nodes)subgraph-variable-nodes-temp))
             )
           )
     (setq subgraph-variable-nodes subgraph-variable-nodes-temp) ; re-initialization of the variable-node list
     )
    ; Connect final two variable nodes to the original variable node via the beta factor node-the root of the subgraph created
    (setq beta-node
          (init-factor-node 'Subgraph-Root-BF 'beta (node-variables node)
                            (list  (nth 0 subgraph-variable-nodes) (nth 1 subgraph-variable-nodes) node)
                            (node-evidence node)  t t 
                            (make-beta-memories :alpha (nth 0 subgraph-variable-nodes) :old-beta (nth 1 subgraph-variable-nodes) :new-beta node) 
                            nil nil))
    (setq beta-function (full-plm (node-variables node)))
    (setf (node-function beta-node) beta-function)
    )
  )

; Expand densely connected variable nodes to binary trees of nodes
(defun expand-densely-connected-variable-nodes nil
  (dolist (node (graph-nodes cg))
    (when (and (variable-nodep node) (> (length (node-links node)) threshold-for-dense-connection))
      (create-subgraph-for-densely-connected-variable-nodes node))   
    )
  )

;---------------------------------------------------
; Create a predicate function
(defun compile-predicate-function (pred)
  (let* ((wmfn (predicate-wm pred)) ; WMFN node
         (wmvs-v (predicate-wm-variables pred)) ; Vector of variables in predicate
         (wmvs-l (coerce wmvs-v 'list)) ; List of variables in predicate
         (wmv-names (mapcar #'svariable-name wmvs-l)) ; Variable names in WMFN node
         (fun (predicate-function pred)) ; Specified CPT for function
         row-major ; Whether should use special row-major initialization (an all discrete function with a full set of values)
         (pname (predicate-name pred))
         fun-node ; Predicate function factor node
         other-p ; Predicate to which are tied
         other-fn ; Factor node to which are tied
         p-norm ; Normal/unique variables
         p-fun ; Function stored in predicate function factor node
         (normalize-function (not (predicate-no-normalize pred))) ; Whether to normalize function
         (wmvn (predicate-outgoing-vn pred)) ; Shared WMVN node
         (share (or (not (predicate-persistent pred)) ; Conditions for sharing VN from conditions/condacts with actions
                    (and (not (predicate-select pred))
                         (or (predicate-universal pred)
                             (predicate-cumulative pred)
                             )
                         )
                    ))
         (connect-directly-to-shared-vn (or (not (predicate-persistent pred)) ; Connect directly from FN to VN
                                            (and (predicate-persistent pred)
                                                 (predicate-unique pred)
                                                 (or (predicate-select pred)
                                                     (predicate-replace pred)
                                                     )
                                                 (not (predicate-perception pred))
                                                 )
                                            ))
         )
    ; Check for special case of a row-major function
    (when (and (consp fun) (eq (car fun) 'row-major))
      (setq fun (cdr fun))
      (setq row-major t)
      )
    (setf (predicate-function-variable-names pred) wmv-names)
    ; Shared WMVN that connects the function to the rest of the graph
    ; If there is not an outgoing WM VN, use incoming if shared with it and it exists, or create it
    (unless wmvn
      (if (and share (predicate-incoming-vn pred))
          (progn
            (setq wmvn (predicate-incoming-vn pred))
            (setf (node-pattern-type wmvn) 'condact) ; Mark WMVN as bidirectional
            )
        (setq wmvn (create-wm-variable-node pred wmfn ; Create a new variable node
                                            (concat-symbols `(,pname shared wm-vn) t)
                                            nil wmvs-v nil t nil connect-directly-to-shared-vn nil))
        )
      (setf (predicate-outgoing-vn pred) wmvn)
      )
    ; Create predicate function factor node
    (setq fun-node
          (init-factor-node (concat-symbols (cons pname (cons 'PFF wmv-names)) t)
                            'function
                            wmvs-v
                            (list wmvn)
                            t feedback-to-functions t nil nil nil))
    (setf (node-assumption fun-node) t)
    (setf (node-function-name fun-node) pname)
    (cond ((numberp fun)
           (setq p-fun (init-plm wmvs-v fun 0 (init-vector (length wmvs-v) t)))
           (setf (plm-piecewise-constant p-fun) t)
           )
          ((symbolp fun) ; Copy function from another predicate
           (setq normalize-function nil) ; Don't need to normalize function, as already normalized
           (setq other-p (predicate-from-name fun))
           (unless other-p
             (error "No predicate named ~S, as specified in the :FUNCTION for predicate ~S" fun pname)
             )
           (unless (equal wmv-names (predicate-function-variable-names other-p))
             (error "Function variable names ~S in predicate ~S not the same as ~S in predicate to which function is to be tied ~S"
                    wmv-names pname (predicate-function-variable-names other-p) (predicate-name other-p))
             )
           (unless (equal (predicate-unique pred) (predicate-unique other-p)) ; This may need to be changed as work out different forms of uniqueness for predicate functions
             (error "Function normal ~S in conditional ~S not the same as ~S in conditional to which function is to be tied ~S"
                    (predicate-unique pred) pname (predicate-unique other-p) (predicate-name other-p))
             )
           (setq other-fn (predicate-function-node other-p))
           (unless other-fn
             (error "No function node for predicate ~S as needed given specification in predicate ~S" (predicate-name other-p) pname)
             )
                ; Add shared function node, and all nodes it shares with to list of shared function nodes
           (setf (node-shared-functions fun-node) (cons other-fn (node-shared-functions other-fn)))
                ; Add current node to list of shared function nodes for node shared and everyone it shares with
           (setf (node-shared-functions other-fn) (cons fun-node (node-shared-functions other-fn)))
           (dolist (cousin (node-shared-functions other-fn))
             (setf (node-shared-functions cousin) (cons fun-node (node-shared-functions cousin)))
             )
           (setq p-fun (copy-conditional-function (node-function other-fn) wmvs-v))
           )
          (row-major
           (setq p-fun (rml-plm fun wmvs-v t))
           (setf (plm-piecewise-constant p-fun) t)
           )
          (t
           (setq p-fun (cpt-function-array-plm wmv-names fun wmvs-v
                                               (if (predicate-function-default pred) (predicate-function-default pred) function-default) t))
           (setf (plm-piecewise-constant p-fun) (notany #'(lambda (x) (consp (car x))) fun)) ; No linear regions in specification
           )
          )
    (setf (predicate-function-node pred) fun-node)
    (setf (node-predicate fun-node) pred)
    (setf (node-normal fun-node) nil)
    (setq p-norm (mapcar #'convert-to-wm-variable-name (predicate-unique pred)))
    (when p-norm ; This may need to be changed as work out different forms of uniqueness for predicate functions
      (setf (node-normal fun-node) (if (symbolp p-norm)
                                       (position p-norm wmv-names)
                                     (mapcar #'(lambda (px) (position px wmv-names)) p-norm)))
      (when normalize-function ; Avoid renormalizing when it is a function copied from another conditional
        (setq p-fun (normalize-plm p-fun (node-normal fun-node) t))
        )
      )
    (setf (node-function fun-node) p-fun)
    (setf (node-restriction fun-node) (transform-plm #'boolean-function p-fun))
    (setf (node-changes fun-node) 1) ; Initialize number of changes made to fucntion via learning to 0
    ; Set the node's learning rate
    (if (predicate-learning-rate pred) ; Use value specified in predicate if specified
        (progn
          (unless (numberp (predicate-learning-rate pred))
            (error "Learning rate specified for predicate ~S is not a number" pname)
            )
          (if (not (or (node-normal fun-node) learn-no-normal (e= (predicate-learning-rate pred) 0)))
              (error "Learning rate specified for a predicate with no normal variable when learn-no-normal not T: ~S" pname)
            (setf (node-learning-rate fun-node) (predicate-learning-rate pred)))
          )
      (when adaptive-learning-rate ; Otherwise use the adaptive rate if active
        (setf (node-learning-rate fun-node) (/ 0.3 (function-span fun-node)))
        ))
    ; Set the node's smoothing parameter
    (when (predicate-smoothing-parameter pred) ; Use value specified in predicate if specified
      (unless (numberp (predicate-smoothing-parameter pred))
        (error "Learning rate specified for predicate ~S is not a number" pname)
        )
      (setf (node-smoothing-parameter fun-node) (predicate-smoothing-parameter pred))
      )
    fun-node)
  )

; -----------------------------------------------------------
; Compile conditional

; Make a new unique symbol based on a string
(defun make-name-string (string)
  (intern (symbol-name (gensym string))))

; Make a new unique symbol based on a symbol
(defun make-name-symbol (symbol)
  (intern (symbol-name (gensym (symbol-name symbol)))))

; Make a new symbol based on a symbol and a number
(defun make-name-number-symbol (symbol number)
  (intern (format nil "[~S_~S]" number symbol))
  )

; An element is a list whose car is the argument name
; and the cadr is either * (for all constants),
; a list with a beginning and ending of a numeric range
; or a list of a variable (which is itself a list with the variable's name)
; The caddr, should it exist, is is a list of the value for the constant
; and a value for other elements of the domain (defaults to (1 0))
(defun element-argument-name (e) (car e))
(defun element-content (e) (cadr e))
(defun element-rest (e) (cddr e)) ; Used to determining if there is extra stuff (syntax error)
(defun element-value (e) (if (caddr e) (caddr e) '(1 0)))

; Determine if something is a constant region (a list with two numbers)
(defun constant-element-regionp (x)
  (and (consp x) (numberp (car x)) (equal (length x) 2) (numberp (cadr x)))
  )

; Determine if an element's contents is a constant or variable
; Currently differentiated by variables being in sublists
(defun constant-element (ec) (or (symbolp ec)
                                 (numberp ec)
                                 (constant-element-regionp ec)
                                 (filter-listp ec)
                                 )
  )
(defun variable-element (ec) (and (listp ec) (symbolp (car ec)) (not (equal (car ec) filter-symbol))))

; When the element content is an asterisk (*) it is all constants
(defun star-element (ec) (eq ec '*))

; Get the variable index corresponding to an element
(defun element-wm-index (e pred)
  (position (element-argument-name e) (predicate-arguments pred) :key #'argument-name))

; Get index for a constant from a type
(defun constant-index (constant type)
  (position constant (stype-constants type)))

; Compute the element span for a constant test or a wme
; Half open interval from (and including) min to (and not including) max
(defun compute-span (content type &optional shift-discrete-lists)
  (let ((min (stype-min type))
        (max (stype-max type))
        span-min ; Minimum of numeric span
        span-max ; Maximum of numeric span
        )
    (cond ((and (listp content) (numberp (car content))) ; Case where given begin and end as numbers
           (setq span-min (car content))
           (setq span-max (cadr content))
           (when (or (not (numberp span-min)) (not (numberp span-max)))
             (error "Specified span [~S,~S> not numeric for type ~S in COMPUTE-SPAN" span-min span-max (stype-name type))
             )
           (when (and (stype-discrete type) (stype-numeric type) center-discrete-numeric-on-integer shift-discrete-lists)
             (setq span-min (- span-min 1/2))
             (setq span-max (- span-max 1/2))
             )
           (unless (and (>= span-min min) (<= span-min max) (>= span-max min) (<= span-max max))
             (error "Span [~S,~S> is not within domain of type ~S: [~S,~S>!" (car content) (cadr content) (stype-name type) min max)
             )
           (list span-min span-max))
          ((listp content) ; Case where have a list of symbols
           (let ((ci-min (constant-index (car content) type))
                 (ci-max (constant-index (car (last content)) type)))
             (unless ci-min
               (error "Constant ~S not defined as part of type ~S: ~S" (car content) (stype-name type) (stype-constants type))
               )
             (unless ci-max
               (error "Constant ~S not defined as part of type ~S: ~S" (car (last content)) (stype-name type) (stype-constants type))
               )
             (list ci-min (+ ci-max 1))
             )
           )
          ((star-element content) ; Cover whole type for a star
           (list (stype-min type) (stype-max type)))
          ((stype-numeric type) ; If number but content isn't a list
           (unless (numberp content)
             (error "Specified constant ~S not numeric for type ~S in COMPUTE-SPAN" content (stype-name type))
             )
           (cond ((and (stype-discrete type) center-discrete-numeric-on-integer shift-discrete-lists) ; Discrete type that is to be centered around integers
                  (setq span-min (- content 1/2))
                  (setq span-max (+ content 1/2))
                  )
                 (t
                  (setq span-min content)
                  (setq span-max (+ content 1))
                  )
                 )
           (unless (and (>= span-min min) (<= span-max max) (>= span-max min) (<= span-max max))
             (error "Specified value of ~S [~S,~S> is not within domain of type ~S: [~S,~S>!" content span-min span-max (stype-name type) min max)
             )
           (list span-min span-max))
          (t ; For constants, find index and include from there to +1     
           (let ((ci (constant-index content type)))
             (unless ci
               (error "Constant ~S not defined as part of type ~S: ~S" content (stype-name type) (stype-constants type))
               )
             (list ci (+ ci 1))
             )
           )
          ) 
    )
  )

; Convert one entry in a cpt table to a region
; Added the optional input ordered-variable. If the variables are aligned with variable names, no need to find the variable indices
(defun cpt-region (cpt-var-names entry variables &optional shift-discrete-lists ordered-variables)
  (let* ((fun (car entry)) ; Entry function (either a constant or a list of a constant and dimension weights)
         (dns (cdr entry)) ; List of dimension spans
         (r (make-spanning-region variables nil 0 0)) ; New region
         (dvector (region-dimensions r)) ; Vector of region's dimensions (including min, max, before, after, and weight)
         dim ; One dimensional structure in iteration
         dvar ; Variable in dimension in iteration
         dspan) ; List of min and max for dimension in iteration
    (cond ((numberp fun) ; Function is a single constant weight
           (setf (region-constant r) (car entry))
           (setq fun nil) ; Signal for rest of processing that there are no weights
           )
          ((listp fun) ; Function is a list of constant and weights
           (setf (region-constant r) (car fun))
           (setq fun (cdr fun)) ; Weights on dimensions
           )
          (t (error "Function specification ~S is neither a number or a list of numbers." fun))
          )
    (do ((dinfo-l dns (cdr dinfo-l)) ; Cdr through list of dimensions
         (cvn-l cpt-var-names (cdr cvn-l)) ; Cdr through list of variable names
         (f-l fun (if fun (cdr f-l) nil)) ; Cdr though list of dimension weights if there are any
         (i 0 (1+ i))
         )
        ((null dinfo-l)) ; Done with iteration when no more dimensions
      (if ordered-variables
          (setq dvar (aref variables i))
        (setq dvar (variable-from-name (car cvn-l) variables)) ; Variable for dimension
        )
      (unless dvar (error "Variable not found for name ~S in list ~S in cpt-region." (car cvn-l) variables))
      (if ordered-variables
          (setf dim (aref dvector i))
          (setf dim (aref dvector (variable-number dvar variables))) ; Dimensional structure for variable
          )
      (setq dspan (compute-span (car dinfo-l) (svariable-type dvar) shift-discrete-lists)) ; Span (min and max) of dimension
      (setf (dimension-min-slice dim) (make-slice :location (car dspan))) ; Set dimension min based on CPT
      (setf (dimension-max-slice dim) (make-slice :location (cadr dspan))) ; Set dimension max based on CPT
      (if f-l ; If there are dimension weights
          (setf (dimension-weight dim) (car f-l)) ; Set weight of current dimension to first element
        (setf (dimension-weight dim) 0)) ; Else set  the weight to 0
      )
    r) ; Return r
  )

; Convert a cpt table into a PLM
; A table is a list of entries, each of which is a list for a function (a constant or a list of a constant and dimension weights)
; followed by dimension spans, each of which is a constant, a region or *
(defun cpt-plm (cpt-var-names table variables default &optional shift-discrete-lists)
  (let ((plm (init-plm variables default 0 (init-vector (length variables) t)))
        )
    (dolist (entry table)
      (setq plm (update-region (cpt-region cpt-var-names entry variables shift-discrete-lists) plm t))
      )
    (remove-unneeded-slices plm))
  )

; Create a random CPT for a list of discrete types
; Incomplete.  Incorporate in stuff froom unsupervised learning initialization, and then use this there
(defun random-cpt (var-names type-names)
  (let ((types (mapcar #'type-from-name type-names)))
    (dolist (type types)
      (unless (stype-discrete type)
        (error "Cannot create a random CPT with a continuous dimension")
        )
      )
    (do ((vns var-names (cdr vns))
         (tns type-names (cdr tns))
         )
        ((or (null vns) (null tns)) t)
      )
   )
  )

; Is cpt constant (no dimension weights?)
(defun cpt-constantp (table)
  (not (find-if #'(lambda (entry) (consp (car entry))) table))
  )

; Are variables all discrete
(defun variables-discretep (variables)
  (not (find-if #'(lambda (v) (not (stype-discrete (svariable-type v)))) variables))
  )

; Create a list of dimensions for a vector of variables
(defun variable-dimensions (variables)
  (let (dims)
    (dotimes (i (length variables))
      (setq dims (cons (stype-span (svariable-type (aref variables i))) dims))
      )
    (reverse dims))
  )

; Create a discrete array
(defun init-farray (variables default)
  (make-array (variable-dimensions variables) :initial-element default)
  )

; Increment an index to an array of regions, reinitializing later columns according to minsi
; Destructively update setf for update-array-region
(defun inc-index (minsi index maxsi)
  (cond ((null index) nil) ; Beyond end of list
        ((inc-index (cdr minsi) (cdr index) (cdr maxsi)) t) ; Could increment a later index
        ((= (car index) (car maxsi)) (rplaca index (car minsi)) nil)
        ((< (car index) (car maxsi)) (rplaca index (1+ (car index)))) ; Can increment current index
        (t nil)
        )
  )

; Lists of region mins and maxs
(defun region-mins-l (region)
  (let (m
        (rds (region-dimensions region)))
    (dotimes (i (length rds))
      (setq m (cons (region-min region i) m))
      )
    (reverse m))
  )
(defun region-maxs-l (region)
  (let (m
        (rds (region-dimensions region)))
    (dotimes (i (length rds))
      (setq m (cons (region-max region i) m))
      )
    (reverse m))
  )

; Delete duplicates (based on location) from a list of slices
(defun delete-duplicates-slice-list (slices)
  (delete-duplicates slices :key #'slice-location)
  )

; Delete duplicates (based on location) from an array of slice lists
(defun delete-duplicates-slice-list-array (sla)
  (dotimes (i (length sla))
    (setf (aref sla i) (delete-duplicates-slice-list (aref sla i)))
    )
  sla)

; Sort a list of slices
(defun sort-slice-list (slices)
  (sort slices #'< :key #'slice-location)
  )

; Sort an array of slice lists
(defun sort-slice-list-array (sla)
  (dotimes (i (length sla))
    (sort-slice-list (aref sla i))
    )
  sla)

; Index a list of slices
(defun index-slice-list (slices)
  (let ((count 0))
    (dolist (sl slices)
      (setf (slice-index sl) count)
      (setq count (1+ count))
      )
    slices)
  )

; Index an array of slice lists
(defun index-slice-list-array (sla)
  (dotimes (i (length sla))
    (index-slice-list (aref sla i))
    )
  sla)

; List of minimum slice locations for a region
(defun region-min-slice-indexes-l (r)
  (let (ms
        (rds (region-dimensions r))
        )
    (dotimes (i (length rds))
      (setq ms (cons (slice-index (dimension-min-slice (aref rds i))) ms))
      )
    (reverse ms))
  )

; List of maximum slice locations for a region
(defun region-max-slice-indexes-l (r)
  (let (ms
        (rds (region-dimensions r))
        )
    (dotimes (i (length rds))
      (setq ms (cons (slice-index (dimension-max-slice (aref rds i))) ms)) 
      )
    (reverse ms))
  )

; Update a region array based on a region from a cpt entry
(defun update-function-array-region (region farray)
  (let* ((minsi (region-min-slice-indexes-l region))
         (minsi-iterate (copy-list minsi))
         (maxsi (mapcar #'1- (region-max-slice-indexes-l region)))
         )
    (do ((i minsi-iterate (progn (inc-index minsi minsi-iterate maxsi) minsi-iterate))) ; Inc-index destructively modifies its argument and doesn't return it
        ((equal i maxsi) (setf (apply #'aref farray i) (if (region-function-constantp region) (region-constant region) (extract-function region))))
      (setf (apply #'aref farray i) (if (region-function-constantp region) (region-constant region) (extract-function region)))
      )
    )
  )

; Create an array of functions based on entries
(defun cpt-function-array (rlist default slices)
  (let ((farray (make-array (mapcar #'1- (mapcar #'length (coerce slices 'list))) :initial-element default))
        )
    (dolist (r rlist)
       (update-function-array-region r farray)
      )
    farray)
  )



; Convert a cpt to a PLM
(defun cpt-function-array-plm (cpt-var-names table variables default &optional shift-discrete-lists ordered-variables)
  (let* ((rank (length variables))
         farray ; Array of functions
         rarray ; Array of regions
         region ; A region to be added to the PLM
         rlist ; List of regions
         dimensions ; Dimensions of region
         dim ; Current dimension
         vt ; Current variable type
         sl ; slice
         plm
         (slices (init-vector rank)) ; Slices to be applied to the PLM
        )
    ; Determine slices for entries
    (dolist (entry table)
      (setq region (cpt-region cpt-var-names entry variables shift-discrete-lists ordered-variables))
      (setq rlist (cons region rlist))
      (setq dimensions (region-dimensions region))
      ; Determine slices for region
      (dotimes (d rank)
        (setq dim (aref dimensions d))
        (setq sl (find (dimension-min dim) (aref slices d) :key #'slice-location :test #'ae=))
        (if sl
            (setf (dimension-min-slice dim) sl)
          (setf (aref slices d) (cons (dimension-min-slice dim) (aref slices d))))
        (setq sl (find (dimension-max dim) (aref slices d) :key #'slice-location :test #'ae=))
        (if sl
            (setf (dimension-max-slice dim) sl)
          (setf (aref slices d) (cons (dimension-max-slice dim) (aref slices d))))
        )
      )
    ; Determine slices for ends of dimensions
    (dotimes (d rank)
      (setq vt (svariable-type (aref variables d)))
      (setq sl (find (stype-min vt) (aref slices d) :key #'slice-location :test #'ae=))
      (unless sl
        (setf (aref slices d) (cons (make-slice :location (stype-min vt)) (aref slices d)))
        )
      (setq sl (find (stype-max vt) (aref slices d) :key #'slice-location :test #'ae=))
      (unless sl
        (setf (aref slices d) (cons (make-slice :location (stype-max vt)) (aref slices d)))
        )
      )
    (sort-slice-list-array slices) ; Sort slices lists
    (index-slice-list-array slices) ; Add indices to slices
    (setq plm (init-plm-with-slices variables nil 0 (init-vector rank t) slices))
    (setq rarray (plm-array plm))
    (setq farray (cpt-function-array (reverse rlist) default slices)) ; Create function array from list of update regions (from cpts)
    ; Copy functions from function array into PLM
    (dotimes (i (array-total-size rarray))
      (let ((fun (row-major-aref farray i)))
        (if (numberp fun)
            (setf (region-constant (row-major-aref rarray i)) fun)
          (assign-function fun (row-major-aref rarray i)))
        )
      )
    plm)
  )

; Convert a row-major list of constant numbers to a PLM
; Only works for fully discrete PLMs where values are specified for all of the unit-sized regions
(defun rml-plm (rml variables &optional shift-discrete-lists)
  (let* ((rank (length variables))
         rarray ; Array of regions
         rarray-size ; Total size of array rarray
         plm ; New PLM
         dim-type ; Type of the dimension
         dim-size ; Size of a dimension
         dim-size+1 ; Number of slices in dimension
         dim-sizes ; List of sizes of dimensions
         dim-slice-vector ; A vector of slices for a dimension
         (dim-slice-vectors (init-vector rank)) ; A vector of dimension slice vectors
         (slices (init-vector rank)) ; Slices to be applied to the PLM
        )
    ; Determine sizes and slices of each of the dimensions
    (dotimes (i rank)
      (setq dim-type (svariable-type (aref variables i)))
      (unless (stype-discrete dim-type)
        (error "Attempt to compile a row-major function with a non-discrete variable type ~S(~S)" (svariable-name (aref variables i)) (stype-name dim-type))
        )
      (setq dim-size (stype-span dim-type))
      (setq dim-size+1 (1+ dim-size))
      (setq dim-sizes (cons dim-size dim-sizes))
      (setq dim-slice-vector (init-vector dim-size+1))
      (dotimes (j dim-size+1)
        (setf (aref dim-slice-vector j) (make-slice :location (if (and shift-discrete-lists center-discrete-numeric-on-integer) (- j 1/2) j) :index j))
        )
      (setf (aref dim-slice-vectors i) dim-slice-vector)
      (setf (aref slices i) (coerce dim-slice-vector 'list))
      )
    (setq plm (init-plm-with-slices variables nil 0 (init-vector rank t) slices))
    (setq rarray (plm-array plm))
    (setq rarray-size (array-total-size rarray))
    (unless (= rarray-size (length rml))
      (error "Number of constants provided (~S) not the same as the size of the array (~S) to be filled in a row-major fashion" (length rml) rarray-size)
      )
    ; Copy row-major list of numbers into the region array
    (dotimes (i rarray-size)
      (setf (region-constant (row-major-aref rarray i)) (pop rml))
      )
  plm)
  )

; Find first region in list that covers span of specified region
(defun find-region (r regions)
  (let (fr)
    (dolist (ir regions)
      (when (within-region r nil ir)
        (return (setq fr ir))
        )
      )
    fr)
  )

; Recur on create-assign-id-function, going down one variable at a time
(defun create-assign-id-function-recur (predicate idp id-num d vs vns entry ev-op)
  (let* ((rank (length vs))
         (rank-1 (1- rank))
         (v (aref vs d))
         (vt (svariable-type v))
         (constants (stype-constants vt))
         vtmin ; Minimum of type (up by 1/2 if centering)
         new-entry
         rne
         )
    (setq vtmin (stype-min vt))
    (when (and center-discrete-numeric-on-integer (not constants))
      (setq vtmin (+ vtmin 1/2))
      )
    (if (and (eq (stype-name (svariable-type v)) 'operator)
             (not (and ev-op (eq (svariable-name v) 'wm-evaluate))) ; Not the evaluate argument of evaluate-operator
             )
        (progn
          (setq new-entry (cons id-num entry))
          (if (= d rank-1) ; At leaf
              (progn
                (setq rne (reverse new-entry))
                (setq idp (update-region (cpt-region vns rne vs) idp))
                (setf (aref (predicate-id-contents predicate) (- id-num (predicate-first-operator predicate))) (cdr rne))
                (setq id-num (1+ id-num))
                )
            (multiple-value-setq (id-num idp) (create-assign-id-function-recur predicate idp id-num (+ d 1) vs vns new-entry ev-op))
            )
          )
      (dotimes (i (if (and ev-op (eq (svariable-name v) 'wm-evaluate))
                      (/ (stype-span vt) 2)
                    (stype-span vt)))
        (setq new-entry (cons (if constants
                                  (nth (+ i vtmin) constants)
                                (+ i vtmin))
                              entry))
        (if (= d rank-1) ; At leaf
            (progn
              (setq rne (reverse new-entry))
              (setq idp (update-region (cpt-region vns rne vs) idp))
              (setf (aref (predicate-id-contents predicate) (- id-num (predicate-first-operator predicate))) (cdr rne))
              (setq id-num (1+ id-num))
              )
          (multiple-value-setq (id-num idp) (create-assign-id-function-recur predicate idp id-num (+ d 1) vs vns new-entry ev-op))
          )
        ))
    (values id-num idp))
  )

; Create a function that assigns operator id's to all combinations of values of the other argument types
(defun create-assign-id-function (predicate)
  (let* ((vs (predicate-wm-variables predicate))
         (idp (init-plm vs 0 0 (init-vector (length vs) t))) ; Delta function for assigning ids
         id-num
         )
    (multiple-value-setq (id-num idp) (create-assign-id-function-recur predicate idp (predicate-first-operator predicate) 0 vs (variable-names vs) '(1)
                                                                       (eq (predicate-name predicate) 'evaluate-operator)))
    id-num ; Just included so that no warning is generated for not using
    idp)
  )

; Create factor node that assigns ids to a predicate and attach to the WMVN
(defun assign-ids-to-predicate (predicate wmvn)
  (let (idn)
    (setq idn (init-factor-node (concat-symbols (list (predicate-name predicate) 'wm 'ids) t)
                    'ids (predicate-wm-variables predicate) (list wmvn) nil nil t nil
                     nil nil))
    (setf (node-function idn) (predicate-assign-ids predicate))
    t)
  )

; Eliminate any variable from the second argument (a vector) if not named in the first
; argument (a list)
(defun eliminate-vars-if-not-named (name-l var-v)
  (let* ((rank (length var-v))
         new-var-l)
    (dotimes (i rank)
      (when (member (svariable-name (aref var-v i)) name-l)
        (setq new-var-l (cons (aref var-v i) new-var-l))))
    (coerce (reverse new-var-l) 'vector)
    )
  )

; Put symbol between each pair of list entries
(defun insert-symbol-list (l sym)
  (let (nl)
    (do ((l-l l (cdr l-l)))
        ((null l-l))
      (setq nl (cons (car l-l) nl))
      (when (cdr l-l)
        (setq nl (cons sym nl))))
    (reverse nl))
  )

; Return variable name if variable otherwise combination if a list
(defun variable-list-name (vs)
  (if (listp vs)
      (concat-symbols (insert-symbol-list (variable-names vs) '*))
    (svariable-name vs))
  )

; Return list of variable names from a vector of variables
(defun variable-names (variables)
  (map 'list #'variable-list-name variables)
  )

; Is vector not empty?
(defun not-empty-vector (vector)
  (> (length vector) 0))

; Recur on merge-variable-vectors
(defun merge-variable-vectors-recur (vs1 vs1i vs2 vs2i)
  (cond ((>= vs1i (length vs1)) ; Nothing left in first vector
         (if (>= vs2i (length vs2)) ; Nothing left in second vector
             nil
           (coerce (subseq vs2 vs2i) 'list))) ; Create list for ending subsequence of second vector
        ((>= vs2i (length vs2)) ; Nothing left in second vector
         (coerce (subseq vs1 vs1i) 'list)) ; Create list for ending subsequence of first vector
        ((eq (svariable-name (aref vs1 vs1i)) ; First element of first vector also first of second
             (svariable-name (aref vs2 vs2i)))
         (cons (aref vs1 vs1i) (merge-variable-vectors-recur vs1 (+ vs1i 1) vs2 (+ vs2i 1))))
        ((not (find (svariable-name (aref vs1 vs1i)) vs2
                    :start vs2i :key #'svariable-name)) ; First element of first vector not in rest of second
         (cons (aref vs1 vs1i) (merge-variable-vectors-recur vs1 (+ vs1i 1) vs2 vs2i)))
        ((not (find (svariable-name (aref vs2 vs2i)) vs1
                    :start vs2i :key #'svariable-name)) ; First element of second vector not in rest of first
         (cons (aref vs2 vs2i) (merge-variable-vectors-recur vs1 vs1i vs2 (+ vs2i 1))))
        (t ; Cannot order merged variables so as to satisfy both existing orders
         (error "No compatible ordering for variable vectors ~S and ~S." vs1 vs2))
        )
  )

; Merge two vectors of variables from variable nodes into a new vector,
; preserving order of variables across two vectors
; Genererates an error if it isn't possible (and will require dynamic dimension reording)
(defun merge-variable-vectors (vs1 vs2)
;  (coerce (merge-variable-vectors-recur vs1 0 vs2 0) 'vector)
  (union-two-variables vs1 vs2)
  )

; Create the variables for a delta node
; numvs is the number of variables in each of the variable nodes connected to the delta
; pvs is a Boolean vector with T where a predicate/WM variable is used in delta
; cvsi points from positions in wmvs to corresponding conditional variables
; wmvs is a full vector of working memory variables for the predicate
; Resulting vector should have WM variables in each position, doubled up with
; conditional variables when correspond
(defun delta-variables (numvs pvs cvsi wmvs)
  (let ((dvs (init-vector numvs))
        (k 0) ; Index into dvs
        )
  (dotimes (i (length wmvs))
    (when (aref pvs i)
      (if (aref cvsi i)
          (setf (aref dvs k) (list (aref wmvs i) (aref cvsi i)))
        (setf (aref dvs k) (aref wmvs i)))
      (setq k (+ k 1))
      )
    )
  dvs)
  )

; Create a list of 1 through N
(defun number-list (n)
  (let (l)
    (dotimes (i n)
      (setq l (cons i l))
      )
    (reverse l))
  )

; Create a delta factor
(defun create-delta-factor (c delta-vs c-varns alpha-memory previous-vn evidence-vn in out subsubtype pred not-equals)
  (let (split-delta-vs ; Rather than pairs of variables in each slot, a single vector with all variables
        vars ; List for split-delta-vs
        delta-node ; Delta node
        affines ; List of affine transforms from variable pairs
        v ; variable
        (v-count 0) ; variable count
        affine ; Affine used at position (may be a reused one from an earlier position)
        ai ; Index of reused from/pattern variable
        )
    (dotimes (i (length delta-vs))
      (setq v (aref delta-vs i))
      (when v
        (cond ((listp v)
               (cond ((symbolp (cadr v)) ; Reuse of a variable in a pattern
                      (when in
                        (error "Reuse of variables within a single condact or action, as in conditional ~S, is not currently allowed." (conditional-name c))
                        )
                      (setq vars (cons (car v) vars))
                      (setq ai (- v-count (position (cadr v) vars :key #'svariable-name)))
                      (dolist (a affines)
                        (when (= (affine-from a) ai)
                          (setq affine a)
                          )
                        )
                      (setf (affine-to affine) ; Add new WM/predicate variable to the "to" list (which is the predicate/WM variable)
                            (if (numberp (affine-to affine))
                                (list v-count (affine-to affine))
                              (cons v-count (affine-to affine)))
                            )
                      (setq v-count (+ v-count 1))
                      )
                     (t ; Map variable
                      (setq vars (cons (car v) (cons (cadr v) vars)))
                      (setq affines (cons (setq affine (make-affine :from v-count :to (+ v-count 1))) affines))
                      (setq v-count (+ v-count 2))
                      )
                     )
               )
              (t ; Variable stays the same
               (setq vars (cons v vars))
               (setq affines (cons (make-affine :to v-count) affines))
               (setq v-count (+ v-count 1))
               )
              )
        (when (aref not-equals i)
          (setf (affine-not-equal affine) (position (aref not-equals i) c-varns))
          )
        )
      )
    ; Add WM variables that aren't in patterns to list of variables (will be in variable node before delta)
;    (dotimes (i (length wmvs))
;      (unless (aref pattern-vs i)
;        (setq vars (cons (aref wmvs i) vars))
;        (setq affines (cons 
;        )
;      )
    (setq split-delta-vs (coerce (reverse vars) 'vector))
    ; Create delta factor for predicate pattern
    (when (or in out)
      (setq delta-node
            (init-factor-node (concat-symbols (cons (conditional-name c) (cons 'ADF c-varns)) t)
                              'affine
                              split-delta-vs
                              (list previous-vn alpha-memory)
                              (list evidence-vn) in out nil nil c subsubtype))
      (setf (node-region-pad delta-node) (if (open-world pred) 1 0))
      (setf (node-function delta-node) affines)
      )
    delta-node)
  )

; From a vector of WM variables create a vector of transformed WM variables
(defun transform-variables (vs)
  (let* ((vsl (length vs))
         (nvs (init-vector vsl))
         v)
    (dotimes (i vsl)
      (setq v (aref vs i))
      (setf (aref nvs i) (make-svariable :name (concat-symbols (list (svariable-name v) '-i))
                                         :type (svariable-type v)
                                         :unique (svariable-unique v)
                                         :select (svariable-select v)
                                         ))
      )
    nvs)
  )

; Create double up variable vectors for transform factor
(defun transform-factor-variables (vs1 vs2)
    (let* ((vsl (length vs1))
         (nvs (init-vector vsl)))
    (dotimes (i vsl)
      (setf (aref nvs i) (list (aref vs1 i) (aref vs2 i)))
      )
    nvs)
  )

; Create a transform factor (must be an inverse at this point)
(defun create-transform-factor (c type t-vars previous-vars next-vn previous-vn evidence-vn in out subsubtype)
  (unless (member type '(invert negate exponentiate))
    (error "Unknown transform type ~S in conditional ~S." type (conditional-name c))
    )
  (let (transform-node)
    (when (or in out)
      (setq transform-node
            (init-factor-node (concat-symbols (list (conditional-name c) (case type ((invert) 'IF) ((negate) 'NF) ((exponentiate) 'EF))) t)
                              'transform
                              (transform-factor-variables previous-vars t-vars)
                              (if (consp previous-vn)
                                  (append previous-vn (list next-vn))
                                (list previous-vn next-vn))
                              (if (consp evidence-vn)
                                  evidence-vn
                                (list evidence-vn))
                              in out nil nil c subsubtype))
      (setf (node-function transform-node) (case type
                                             ((invert) #'invert-function)
                                             ((negate) #'negate-function)
                                             ((exponentiate) #'exponentiate-constant-times10-function)))
      )
    ; For an exponential transform, normalize the result
; To work, needs some way of saying which variable to normalize over if there are only multiple variables.
;    (setf (node-normalize transform-node) (case type ((invert) nil) ((exponentiate) t)) )
    transform-node)
  )

; A weight list is a list with two numbers
(defun weight-list (candidate)
  (and (listp candidate)
       (numberp (car candidate))
       (cdr candidate)
       (numberp (cadr candidate))))

; Determine if two spans are e=
(defun span-e= (s1 s2)
  (and
   (e= (car s1) (car s2) t)
   (e= (cadr s1) (cadr s2) t)
   )
  )

; Check if two lists of predicate arguments are compatible
; Constants should be the same, and should be variables in the same place
(defun compatible-constants (elements1 elements2 pred)
  (let ((compatible t)
        ec1 element2 ec2 e-type)
    (dolist (element1 elements1)
      (setq e-type (type-from-predicate-argument (element-argument-name element1) pred))
      (setq ec1 (element-content element1))
      (setq element2 (assoc (element-argument-name element1) elements2))
      (if element2
          (setq ec2 (element-content element2))
        (error "In compatible-constants, argument name ~S not found in argument list ~S." (element-argument-name element1) elements2)
        )
      (when (or (and (listp ec1) (symbolp ec2))
                (and (symbolp ec1) (listp ec2))
                (and (symbolp ec1) (symbolp ec2) (not (span-e= (compute-span ec1 e-type) (compute-span ec2 e-type))))
                )
        (setq compatible nil)
        (return nil))
      )
    compatible)
  )

(defun create-wm-variable-node (pred wm node-name action wmvs vn-in vn-out l-in l-out exponential)
  (let (wmvn link)
    (setq wmvn ; Create new WM variable node for predicate
          (init-variable-node node-name 'wm 'positive action wmvs t))
    (setf (node-pattern-type wmvn) (pattern-type vn-in vn-out)) ; For use when connected directly to a beta factor
    (setf (node-exponential wmvn) exponential)
    (setf (node-normalize wmvn) (and (not (predicate-no-normalize pred))
                                     (predicate-unique pred)
                                     ))
    (if (predicate-vector pred)  (setf (node-vector wmvn) t)) 
    (setf (node-predicate wmvn) pred)
    (setf (node-wmvn wmvn) t)
    ; Link WM variable node to WM factor node when there is one and an active direction
    (when (and wm
               (or l-in l-out)
               )
      (setq link (make-link :map (build-smap wmvs wmvs)
                            :nodes (vector wmvn wm)
                            :contents (vector nil nil)
                            :depths (vector nil nil)
                            :loop-depths (vector nil nil)
                            :inits (vector -1 -1)
                            :incoming (vector nil nil)
                            :in l-in
                            ; (if condacts-change-wm l-in (and l-in (not l-out)))
                            :out l-out
                            :counts (vector 0 0)
                            :stale (vector nil nil)
                            :prequeue (vector nil nil)))
      (add-link link)
      )
    ; Link incoming WM variable node to perception factor node when there is one
    (when (and (predicate-perception pred)
               (or vn-in
                   (and (open-world pred) (not (predicate-select pred)))
                   )
               )
      (setq link (make-link :map (build-smap wmvs wmvs)
                            :nodes (vector wmvn (predicate-perception pred))
                            :contents (vector nil nil)
                            :depths (vector nil nil)
                            :loop-depths (vector nil nil)
                            :inits (vector -1 -1)
                            :incoming (vector nil nil)
                            :in nil
                            :out t
                            :counts (vector 0 0)
                            :stale (vector nil nil)
                            :prequeue (vector nil nil)))
      (add-link link)
      )
    (when vn-out
      (setf (predicate-outgoing-vn pred) wmvn)
      )
    (when (and vn-in (not (predicate-prediction pred))) ; Avoid overwriting this information for prediction predicates
      (setf (predicate-incoming-vn pred) wmvn)
      )
    ; If the predicate defines operators, set up its ids
    (when (predicate-assign-ids pred)
      (assign-ids-to-predicate pred wmvn)
      )
    wmvn)
  )

; Return constant names from element list for use in WM variable node name
(defun elements-constants (elements)
  (let (constants)
    (dolist (e elements)
      (when (symbolp (element-content e))
        (setq constants (cons (element-content e) constants)))
      )
    (reverse constants))
  )

; Return condition variable node (WM VAN) for including contents of WM FN in WM FAN
(defun condition-variable-node (wm)
  (let (vn)
    (dolist (l (node-links wm))
      (setq vn (link-var-node l))
      (if (and (eq (node-subsubtype vn) 'van) (not (link-in l)) (link-out l))
          (return vn)
        (setq vn nil)
        )
      )
    vn)
  )

; Add an action to an alpha network
; Returns variable node to be hooked to pattern's delta node
(defun add-action (pred wm vn-type name constants negated exponential wmvs c shared persistent open)
  (let (outgoing-vn
        incoming-vn
        wmvn ; WM VN for combined actions
        wmvan ; VN for uncombined action
        wmfnvan ; VN for connecting WM FN to WM FAN
        wmfan ; Combining factor node
        selection-pred ; Selection predicate
        (pred-name (predicate-name pred))
        direct-vn-fn-link
        (perfn (predicate-perception pred)) ; Perception factor node
        direct-vn-per-link
        pervan
        wm-discount-node ; Function to use in discounting contents of the WMFN at the VAN
        )
    ; Find the link to the WM VN (action combination variable node)
    (setq incoming-vn (predicate-incoming-vn pred))
    ; Find the shared outgoing WM VN if sharing this action
    (when shared
      (setq outgoing-vn (predicate-outgoing-vn pred))
      )
    ; Retrieve the action/incoming WM VN if it exists, otherwise create
    (if incoming-vn ; There is already an action/incoming VN
        (setq wmvn incoming-vn)
      (if (and shared outgoing-vn) ; Use the outgoing VN
          (progn
            (setf (node-action outgoing-vn) t)
            (setf (node-pattern-type outgoing-vn) 'condact) ; Mark node as bidirectional
            (when wm
              (setq direct-vn-fn-link (link-from-numbers (node-number outgoing-vn) (node-number wm)))
              )
            (if direct-vn-fn-link ; There is already a direct link
                (when persistent
                  (setf (link-in direct-vn-fn-link) t) ; Ensure that it is marked as coming in
                  )
              (progn
                (when wm
                  (add-link (make-link :map nil ; Create link from VN to FN
                                       :nodes (vector outgoing-vn wm) :contents (vector nil nil)
                                       :depths (vector nil nil)
                                       :loop-depths (vector nil nil)
                                       :inits (vector -1 -1) :incoming (vector nil nil)
                                       :in persistent :out nil :counts (vector 0 0)
                                       :stale (vector nil nil)
                                       :prequeue (vector nil nil)))
                  )
                ; Add link between perception FN and outgoing/shared VN when perception predicate and link doesn't already exist
                (when (and perfn (not (link-from-numbers (node-number outgoing-vn) (node-number perfn))))
                  (add-link (make-link :map nil ; Create link from VN to FN
                                     :nodes (vector outgoing-vn perfn) :contents (vector nil nil)
                                     :depths (vector nil nil)
                                     :loop-depths (vector nil nil)
                                     :inits (vector -1 -1) :incoming (vector nil nil)
                                     :in nil :out t :counts (vector 0 0)
                                     :stale (vector nil nil)
                                     :prequeue (vector nil nil)))
                  )
                ))
            (setf (predicate-incoming-vn pred) outgoing-vn)
            (setq wmvn outgoing-vn)
            )
        (progn
          (setq wmvn (create-wm-variable-node pred wm ; Create a new action/incoming combination variable node
                                              (concat-symbols (list pred-name vn-type 'wm-vn) t)
                                              t wmvs t shared persistent nil exponential))
          )))
    (cond ((or (and negated (not (or (predicate-vector pred) (predicate-no-normalize pred)))) ; Negated normalized action 
               (and open open-actions-like-condacts) ; An open world action that is treated like half of a condact
               )
           wmvn) ; Just connect to wmvn
          (t ; Positive action to be disjunctively combined
            ; Create a new WM VAN (uncombined action variable node)
            ; Will link via WM FAN to WM VN (combined action variable node)
            (setq wmvan (init-variable-node (concat-symbols (if (eq constants '||) (list name 'wm-van) (list name constants 'wm-van)) t)
                                          'wm 'van nil wmvs t 'action))
            ; Get action combination factor node if exists
            (setq wmfan (predicate-fan pred))
            (cond (wmfan ; There is already an action/incoming FAN, so link to it
                   (add-link (make-link :map nil ; Link new variable node to combination factor node
                                        :nodes (vector wmvan wmfan) :contents (vector nil nil)
                                        :depths (vector nil nil)
                                        :loop-depths (vector nil nil)
                                        :inits (vector -1 -1) :incoming (vector nil nil)
                                        :in t :out nil :counts (vector 0 0)
                                        :stale (vector nil nil)
                                        :prequeue (vector nil nil)))
                   )
                  (t ; There is not an action/incoming WM FAN, so create and link to WM VAN and WM VN
                   (setq wmfan                  
                         (init-factor-node (concat-symbols (list pred-name 'wm-fan) t)
                                           'combine wmvs
                                           (list wmvan wmvn) (list wmvn) t nil nil t c
                                           (if (predicate-universal pred)
                                               'max
                                             (if (or (predicate-no-normalize pred) (predicate-vector pred)) 
                                                   'sum
                                                 'por)))) ; Probabalistic or (assuming independence)                          
                   (setf (node-predicate wmfan) pred)
                   (setf (predicate-fan pred) wmfan)
                   (setf (node-function wmfan) (init-plm wmvs (if (and (not open-world-wmfns) (open-world pred)) fan-constant 0) 0 (init-vector (length wmvs) t)))
                   ; Conditionally create WM VAN path from WM FN to incoming WM FAN
                   (when (or (and (not open)
                                  (or (predicate-select pred)
                                      (predicate-universal pred)
                                      (predicate-cumulative pred)
                                      )
                                  )
                             (and open open-world-wmfns (not open-actions-like-condacts)
                                  (or (predicate-cumulative pred) (predicate-universal pred))
                                  )
                             )
                     (setq wmfnvan (init-variable-node (concat-symbols (if (eq constants '||) (list name 'cond-wm-van) (list name constants 'cond-wm-van)) t)
                                      'wm 'van nil wmvs t 'condition))
                     ; Conditionally add discount node for WM through VAN to FAN
                     (when (and discount-wm (predicate-select pred))
                       (setq wm-discount-node (init-factor-node (concat-symbols (list pred-name 'wm-discount) t)
                                                                'discount wmvs
                                                                (list wmfnvan) nil nil t nil t c))
                       (setf (node-function wm-discount-node) (init-plm wmvs wm-discount-factor 0 (init-vector (length wmvs) t)))
                       (setf (node-assumption wm-discount-node) t)
                       )
                     (add-link (make-link :map nil ; Link new variable node to FAN
                                          :nodes (vector wmfnvan wmfan) :contents (vector nil nil)
                                          :depths (vector nil nil)
                                          :loop-depths (vector nil nil)
                                          :inits (vector -1 -1) :incoming (vector nil nil)
                                          :in t :out nil :counts (vector 0 0)
                                          :stale (vector nil nil)
                                          :prequeue (vector nil nil)))
                     (add-link (make-link :map nil ; Link new variable node to predicate WM FN
                                          :nodes (vector wmfnvan wm) :contents (vector nil nil)
                                          :depths (vector nil nil)
                                          :loop-depths (vector nil nil)
                                          :inits (vector -1 -1) :incoming (vector nil nil)
                                          :in nil :out t :counts (vector 0 0)
                                          :stale (vector nil nil)
                                          :prequeue (vector nil nil)))
                     ; Delete direct link from FN to outgoing/shared VN if sharing and they exist
                     (when (and shared (predicate-outgoing-vn pred) wm)
                       (setq direct-vn-fn-link (link-from-numbers (node-number (predicate-outgoing-vn pred)) (node-number wm)))
                       (when direct-vn-fn-link
                         (setf (link-out direct-vn-fn-link) nil)
                         )
                       )
                     ; Conditionally create WM VAN path from PER to WM FAN
                     (when (and perfn (closed-world pred))
                       (setq pervan (init-variable-node (concat-symbols (if (eq constants '||) (list name 'per-van) (list name constants 'per-van)) t)
                                                         'wm 'van nil wmvs t 'condition))
                       (add-link (make-link :map nil ; Link new variable node to FAN
                                            :nodes (vector pervan wmfan) :contents (vector nil nil)
                                            :depths (vector nil nil)
                                            :loop-depths (vector nil nil)
                                            :inits (vector -1 -1) :incoming (vector nil nil)
                                            :in t :out nil :counts (vector 0 0)
                                            :stale (vector nil nil)
                                            :prequeue (vector nil nil)))
                       (add-link (make-link :map nil ; Link new variable node to predicate PER FN
                                            :nodes (vector pervan perfn) :contents (vector nil nil)
                                            :depths (vector nil nil)
                                            :loop-depths (vector nil nil)
                                            :inits (vector -1 -1) :incoming (vector nil nil)
                                            :in nil :out t :counts (vector 0 0)
                                            :stale (vector nil nil)
                                            :prequeue (vector nil nil)))
                       (when (predicate-incoming-vn pred)
                         (setq direct-vn-per-link (link-from-numbers (node-number (predicate-incoming-vn pred)) (node-number perfn)))
                         (when direct-vn-per-link
                           (setf (link-out direct-vn-per-link) nil)
                           )
                         )
                       )
                     )
                   (setq selection-pred (predicate-from-name 'selected t))
                   (when (and selection-pred wm (eq (node-name wm) (node-name (predicate-wm selection-pred)))) ; Action for selected
                     (setf (graph-positive-preferences cg) (cons wmfan (graph-positive-preferences cg)))
                     )
                   )
                  )
            wmvan)
          )
    )
  )

; Excise a link from the graph
(defun excise-link (l)
  (setf (node-links (aref (link-nodes l) 0)) (remove l (node-links (aref (link-nodes l) 0))))
  (setf (node-links (aref (link-nodes l) 1)) (remove l (node-links (aref (link-nodes l) 1))))
  (setf (graph-links cg) (remove l (graph-links cg)))
  t)

; Add a condition to an alpha network
(defun add-condition (pred wm vn-name name constants wmvs c exponential shared-with-actions)
  (let ((wmvn (predicate-outgoing-vn pred)) ; Outgoing WM VN
        (wmvan (when wm (condition-variable-node wm))) ; Variable node for including contents of WM FN in WM FAN
        pervan ; Variable node for including contents of PER in WM FAN
        (perfn (predicate-perception pred)) ; Perception factor node
        wmfan ; Factor node for combining actions and WM
        wm-discount-node ; Function to use in discounting contents of the WMFN at the VAN
        incoming-vn ; Incoming variable node, if there is one
        (connect-directly-to-shared-vn (or (not (predicate-persistent pred)) ; Connect directly from FN to VN
                                           (and (predicate-persistent pred)
                                                (predicate-unique pred)
                                                (or (predicate-select pred)
                                                    (predicate-replace pred)
                                                    )
                                                (not (predicate-perception pred))
                                                )
                                           ))
        )
    ; If there is not an outgoing WM VN, use incoming if shared with it and it exists, or create it
    (unless wmvn
      (setq incoming-vn (predicate-incoming-vn pred))
      (if (and shared-with-actions incoming-vn)
          (progn
            (setq wmvn incoming-vn)
            (setf (node-pattern-type incoming-vn) 'condact) ; Mark node as bidirectional
            )
        (setq wmvn (create-wm-variable-node pred wm ; Create a new variable node
                                            vn-name
                                            nil wmvs nil t nil connect-directly-to-shared-vn exponential))
        )
      (setf (predicate-outgoing-vn pred) wmvn)
      )
    ; If there is a WM and not a WM VAN for including the contents of WM FN in the WM FAN, create it when doesn't connect directly
    ; Do the same for PER as well
    (when (and wm ; There is a WM FN node
               (not wmvan) ; There is not already a WM VAN node
               (not connect-directly-to-shared-vn) ; Connect via VAN/FAN rather than directly
               )
      (setq wmvan (init-variable-node (concat-symbols (if (eq constants '||) (list name 'cond-wm-van) (list name constants 'cond-wm-van)) t)
                                      'wm 'van nil wmvs t 'condition))
      ; Conditionally add discount node for WM through VAN to FAN
      (when (and discount-wm (predicate-select pred))
              (setq wm-discount-node (init-factor-node (concat-symbols (list (predicate-name pred) 'wm-discount) t)
                                                       'discount wmvs
                                                       (list wmvan) nil nil t nil t c))
              (setf (node-assumption wm-discount-node) t)
              (setf (node-function wm-discount-node) (init-plm wmvs wm-discount-factor 0 (init-vector (length wmvs) t)))
              )
      (add-link (make-link :map nil ; Link WM FN to new WM VAN
                           :nodes (vector wmvan wm) :contents (vector nil nil)
                           :depths (vector nil nil)
                           :loop-depths (vector nil nil)
                           :inits (vector -1 -1) :incoming (vector nil nil)
                           :in nil :out t :counts (vector 0 0)
                           :stale (vector nil nil)
                           :prequeue (vector nil nil)))
      (when (and perfn (closed-world pred)) ; Handle perception FN when there is one
        (setq pervan (init-variable-node (concat-symbols (if (eq constants '||) (list name 'per-van) (list name constants 'per-van)) t)
                                         'wm 'van nil wmvs t 'condition))
        (add-link (make-link :map nil ; Link PER to new PER VAN
                             :nodes (vector pervan perfn) :contents (vector nil nil)
                             :depths (vector nil nil)
                             :loop-depths (vector nil nil)
                             :inits (vector -1 -1) :incoming (vector nil nil)
                             :in nil :out t :counts (vector 0 0)
                             :stale (vector nil nil)
                             :prequeue (vector nil nil)))
        )
      (setq wmfan (predicate-fan pred))
      ; If there is not a WM FAN for this predicate, create one; otherwise hook WM VAN (and PER VAN) to it
      (cond (wmfan
             (unless (link-from-numbers (node-number wmfan) (node-number wmvan)) ; Only add link if doesn't already exist
               (add-link (make-link :map nil ; Link new variable node to FAN
                                    :nodes (vector wmvan wmfan) :contents (vector nil nil)
                                    :depths (vector nil nil)
                                    :loop-depths (vector nil nil)
                                    :inits (vector -1 -1) :incoming (vector nil nil)
                                    :in nil :out t :counts (vector 0 0)
                                    :stale (vector nil nil)
                                    :prequeue (vector nil nil)))
               (setf (node-evidence wmfan) (cons wmvan (node-evidence wmfan)))
               )
             (when (and pervan (not (link-from-numbers (node-number wmfan) (node-number pervan)))) ; Only add link if doesn't already exist
               (add-link (make-link :map nil ; Link new variable node to FAN
                                    :nodes (vector pervan wmfan) :contents (vector nil nil)
                                    :depths (vector nil nil)
                                    :loop-depths (vector nil nil)
                                    :inits (vector -1 -1) :incoming (vector nil nil)
                                    :in nil :out t :counts (vector 0 0)
                                    :stale (vector nil nil)
                                    :prequeue (vector nil nil)))
               )
             )
            (t
             (setq wmfan
                   (init-factor-node (concat-symbols (list name 'wm-fan) t)
                                     'combine wmvs
                                     (if pervan (list wmvan wmvn pervan) (list wmvan wmvn))
                                     (if pervan (list wmvan pervan) (list wmvan))
                                     nil t nil t c
                                     (if (predicate-universal pred)
                                               'max
                                               (if (or (predicate-vector pred) (predicate-no-normalize pred)) 
                                                   'sum
                                                 'por)) ; Probabalistic OR (assuming independence)
                                     ))
             (setf (node-predicate wmfan) pred)
             (setf (predicate-fan pred) wmfan)
             (setf (node-function wmfan) (init-plm wmvs (if (and (not open-world-wmfns) (open-world pred)) fan-constant 0) 0 (init-vector (length wmvs) t)))
             )
            )
      )
    wmvn)
  )

;compute the gradient for vector learning 
(defun compute-vector-gradient (node smooth)
  (let* ((link (car (node-links node)))
         (update (link-var-content link)) ; Feedback to use in updating
         (map (link-map link))
         ;(normal (node-normal node)) ; Index of the variable to normalize over, if any
         (nf (node-function node)) ; Previous factor function
         (vs (plm-variables nf))
         (tgdl (trace-gdl node))
         (lr (if (node-learning-rate node)
                 (node-learning-rate node)
               (if learning-rate-fraction-of-smoothing-parameter
                   (* learning-rate-fraction-of-smoothing-parameter smooth)
                 learning-rate)))
         (alr (if arousal (* arousal lr) lr))
         (wg (initialize-weighted-gradient vs alr))  ; Initialize plm with learning rate       
         ;(predicate-argument-unique-positions (init-vector (length vs))) ; Which variables (by position) are unique arguments for GDL in predicate
         ;(pred (node-predicate node)) ; Predicate for node
         )

     ; Multiply gradient by learning rate
    (setq update (combine-plms update map wg 'product)) 
  
    (when tgdl
      (format trace-stream "~&Vectors-Update function discounted by learning rate of ~S: " alr)
      (pplm update)
      )
    update
    )
)

; Determine if a PLM has any selection variables
; Variable must be declared unique/expected and be active in the PLM
(defun selection-variables (plm)
  (let ((pvs (plm-variables plm))
        (as (plm-active plm))
        selection)
    (dotimes (i (plm-rank plm))
      (when (and (selection-variable (aref pvs i))
                 (aref as i))
        (setq selection (cons i selection))
        )
      )
    selection)
  )

; A negated constant (as part of a variable list) is a list (- <constant>)
(defun negated-constant (item)
  (and (listp item)
       (eq (car item) '-)
       (equal (length item) 2)
       (constant-element (cadr item))
       )
  )

; Create a PLM for the constant/filter aspect of a pattern element
(defun create-element-plm (variable data &optional default-value)
  (let ((p (init-plm (vector variable) (if default-value default-value 0) 0 (vector t)))
        (type (svariable-type variable))
        r span constant weight dimension
        )
    (setf (plm-piecewise-constant p) t)
    (dolist (datum data)
      (setq span (compute-span (car datum) type t))
      (setq constant (cadr datum))
      (setq weight (caddr datum))
      (unless (zerop weight)
        (setf (plm-piecewise-constant p) nil)
        )
      (setq dimension (make-dimension :min-slice (make-slice :location (car span)) :max-slice (make-slice :location (cadr span))
                                      :weight weight :discrete (stype-discrete type)))
      (setq r (make-region :constant constant :dimensions (vector dimension) :maximals (init-vector 1)))
      (setq p (update-region r p))
      )
    p)
  )

; Extend vector with specified value at end
(defun extend-vector (vector value)
  (let* ((vr (length vector))
         (nvector (init-vector (+ vr 1)))
         )
    (dotimes (i vr)
      (setf (aref nvector i) (aref vector i))
      )
    (setf (aref nvector vr) value)
    nvector)
  )

; Determine if a list specifies a filter
(defun filter-listp (l)
  (and (consp l) (equal (car l) filter-symbol))
  )
; Access parts of a filter
(defun filter-span (l) (cadr l))
(defun filter-constant (l) (caddr l))
(defun filter-coef (l) (cadddr l))

; Create a filter function from individual filters
(defun create-filter-function (vs filters)
  (let ((rank (length vs))
        filter-fn)
    ; Add full (all 1) filters for variables not explicitly mentioned
    (dotimes (i rank)
      (unless (aref filters i)
        (setf (aref filters i) (make-constant-discrete-plm '(0) (vector (aref vs i)) 1 0))
        )
      )
      ; Create a PLM by outer product of all of the filters
    (setq filter-fn (aref filters 0))
    (dotimes (i (- rank 1))
      (setq filter-fn (product-outer-plms filter-fn (aref filters (+ i 1))))
      )
    filter-fn)
  )

; Determine if a list after a variable name in a pattern specifies an affine-transform
(defun affine-listp (l)
  (and (consp l) (symbolp (car l)) (not (equal (car l) filter-symbol)) (not (equal (car l) not-equal-symbol)))
  )

; Determine if a list after a variable name is a not-equal test on another variable
(defun not-equal-listp (l)
  (and (consp l) (equal (car l) not-equal-symbol))
  )

; Determine pattern type
(defun pattern-type (in out)
  (if in (if out 'condact 'action) (if out 'condition nil))
  )

; Is variable used uniquely in pattern?
(defun variable-unique-in-pattern (vn pp)
  (let* ((pred (predicate-from-name (car pp)))
         (uan (predicate-unique pred))
         unique ec)
    (when uan
      (setq pp (cdr pp)) ; Skip over predicate name
      (unless (listp (car pp)) ; Skip over negation/exponentiation
        (setq pp (cdr pp))
        )
      (dolist (e pp)
        (when (and (or (and (symbolp uan) (eq (element-argument-name e) uan)) ; Same argument name
                       (member (element-argument-name e) uan) ; Argument name is part of unique list
                       )
                   (variable-element (setq ec (element-content e))) ; It is a variable
                   (eq (car ec) vn) ; Same variable name
                   )
          (return (setq unique t))
          )
        )
      )
    unique)
  )

; Is variable used uniquely in a list of patterns?
(defun variable-unique-in-patterns (vn pps)
  (let (unique)
    (dolist (pp pps)
      (when (variable-unique-in-pattern vn pp)
        (return (setq unique t))
        )
      )
    unique)
  )

; Is variable used uniquely in conditional?
(defun variable-unique-in-conditional (vn c)
  (let (unique)
    (setq unique (variable-unique-in-patterns vn (conditional-conditions c)))
    (unless unique
      (setq unique (variable-unique-in-patterns vn (conditional-condacts c)))
      )
    unique)
  )

; Two vectors of variables (at most one from a factor node) are equal
(defun variables-equal (vs1 vs2)
  (let ((same (= (length vs1) (length vs2))))
    (when same
      (dotimes (i (length vs1))
        (when (or (listp (aref vs1 i))
                  (listp (aref vs2 i))
                  (not (eq (svariable-name (aref vs1 i)) (svariable-name (aref vs2 i))))
                  )
          (return (setq same nil))
          )
        )
      )
    same)
  )

; Return variable node after filter for a filter that can be shared
; Only for conditions
(defun shared-filter-wmvn (previous-wmvn filter-fn reduced-vs)
  (let (fnode old-wmvn new-wmvn)
    (dolist (l (node-links previous-wmvn))
      (setq fnode (link-fact-node l))
      (when (and (not (link-in l)) ; Not an action or a condact
                 (eq (node-subtype fnode) 'filter) ; The factor node is a filter
                 (plm-e= filter-fn (node-function fnode)) ; The new filter function is the same as the existing ones
                 (variables-equal reduced-vs (node-variables (setq old-wmvn (link-var-node (other-link fnode l))))) ; Variables are the same in resulting vn
                 )
        (return (setq new-wmvn old-wmvn))
        )
      )
    new-wmvn)
  )

; Return variable node after negation for a negation that can be shared
; Only for conditions
(defun shared-negation-wmvn (previous-wmvn)
  (let (fnode new-wmvn)
    (dolist (l (node-links previous-wmvn))
      (setq fnode (link-fact-node l))
      (when (and (not (link-in l)) ; Not an action or a condact
                 (eq (node-subtype fnode) 'transform) ; The factor node is a filter
                 (eq #'invert-function (node-function fnode)) ; The transform node is an inversion
                 )
        (return (setq new-wmvn (link-var-node (other-link fnode l))))
        )
      )
    new-wmvn)
  )

; A pair of delta variables are equal
(defun delta-variables-equal (v1 v2)
  (or (and (not (consp v1)) (not (consp v2))
           (or (and (not v1) (not v2))
               (and v1 v2 (eq (svariable-name v1) (svariable-name v2)))
               )
           ) ; Single elements (nil or variable) identical
      (and (consp v1) (consp v2)
           (eq (svariable-name (car v1)) (svariable-name (car v2))) 
           (eq (svariable-name (cadr v1)) (svariable-name (cadr v2)))
           )
      )
  )

; Two vectors of delta variables are equal
(defun delta-variable-vectors-equal (vv1 vv2)
  (let ((same (eq (length vv1) (length vv2))))
    (dotimes (i (length vv1))
      (unless (delta-variables-equal (aref vv1 i) (aref vv2 i))
        (return (setq same nil))
        )
      )
    same)
  )

; Return variable node after delta for a delta that can be shared
; Only for conditions
(defun shared-delta-wmvn (previous-wmvn new-delta-vs)
  (let (fnode new-wmvn)
    (dolist (l (node-links previous-wmvn))
      (setq fnode (link-fact-node l))
      (when (and (not (link-in l)) ; Not an action or a condact
                 (eq (node-subtype fnode) 'affine) ; The factor node is a filter
                 (delta-variable-vectors-equal (node-variables (link-var-node (other-link fnode l))) new-delta-vs) ; The transform node is an inversion
                 )
        (return (setq new-wmvn (link-var-node (other-link fnode l))))
        )
      )
    new-wmvn)
  )

(defvar share-condition-tests t)

; Get argument-name corresponding to variable use in predicate pattern
(defun argument-from-variable (v pp)
  (car (find v pp :key #'caadr))
  )

; Create an alpha network for a pattern
(defun create-alpha-network (pp c in out)
  (let* ((p-name (car pp)) ; Predicate name for pattern
         (cond-name (conditional-name c))
         (pred (predicate-from-name p-name)) ; Predicate for pattern
         (open (open-world pred))
         (p-args (predicate-arguments pred)) ; Arguments of the predicate
         (wmfn (predicate-wm pred)) ; Predicate WM FN
         (wmvs (predicate-wm-variables pred)) ; Vector of predicate WM's variables
         iwmvs ; Vector of variables to use in a transformed alpha path
         wmvn ; Starts with WM VN, updated to variable node after constant tests
         reduced-wmvn ; Variable node at the output of a constant test
         shared-wmvn ; VN to share after a filter function
         offset-vn ;Volkan
         wmvn-vs ; Variables in variable node prior to constant test
         (reduced-vs (copy-seq wmvs)) ; Copy of predicate WM's variables, to be updated as go through elements
         (wmvs-rank (length wmvs)) ; Rank of predicate
         evnum ; Index of element in WM FN
         ev ; WM variable corresponding to the element
         e-arg-name ; Argument name
         e-content ; Argument contents
         e-type ; Argument type
         e-rest ; Stuff after arguent name and content
         c-vn ; Name of variable in element, if it is a variable test
         c-v ; Variable for element, if it is a variable test
         c-varns ; List of variable names in pattern
         c-vars ; List of variables in pattern
         c-vars-v ; Vector of variables in pattern
         o-vars-v ;Volkan Vector of variables for the offset variable node
         (c-vars-i (init-vector wmvs-rank)) ; Vector for mapping from predicate variables to conditional variables
         (c-vars-d (init-vector wmvs-rank)) ; Boolean vector for which predicate variables used in delta factor
         (c-vars-e (init-vector wmvs-rank)) ; Boolean vector for which predicate variables have pattern elements (nil means ignored by pattern)
         (original-pp pp) ; Used for error message
         negated ; Whether pattern is negated
         delta-vs ; Variables for delta node
         aff
         affines
         affine-node
         action-offset-variable
         action-from-variable;VOLKAN
         coef coef-position
         (filters (init-vector wmvs-rank)) ; Filters on elements of pattern
         (not-equals (init-vector wmvs-rank)) ; Not-equal tests on elements of pattern
         (variable-exists (init-vector wmvs-rank)) ; Which WM variables have conditional variables
         filter-fn filter-node
         afilter ; There is a filter along at least one dimension
         linear-filter ; There is a linear filter
         transform-node ; Transform factor node (for negated actions)
         explicit-node ; Explicit factor node (for making function explicit along a dimension in an action)
         outgoing-vn ; Shared link for finding WM VN for condacts
         share ; Conditions for sharing VN from conditions/condacts with actions
         exponential ; Whether this is an exponential condition
         action ; Whether pattern is for an action
         new-action-var ; Whether variable is a newly introduced action variable
         explicit-var ; Name of variable that is newly introduced in action (and not used elsewhere in action) and marked as :explicit
         beta-not-equal-vars ; Not-equal variable pairs when other variable is in a previous condition
         )
    ; Generate error if can't find predicate name among predicates
    (unless pred (error "Predicate ~S in conditional ~S is undefined." p-name cond-name))
    ; Strip off predicate name from predicate pattern
    (setq pp (cdr pp))
    ; Determine if pattern is negated (negation must come before alpha variable if exists)
    (when (and (listp pp) (eq (car pp) negation-symbol))
      (setq negated t)
      (setq pp (cdr pp))
      )
    ; Determine if pattern is an exponentiated condition
    (when (and (listp pp) (eq (car pp) exponential-symbol)
               out (not in))
      (setq exponential t)
      (setq pp (cdr pp))
      )
    (setq share (or (not (predicate-persistent pred)) ; Conditions for sharing VN from conditions/condacts with actions
                    (and (not (predicate-select pred))
                         (or (predicate-universal pred)
                             (predicate-cumulative pred)
                             )
                         )
                    ))
    ; Deal with sharing
    (cond ((or (and in
                    (or out ; Condact sharing
                        (and open-actions-like-condacts open) ; Sharing open-world actions when behave like condacts
                        )
                    )
               (and out open-conditions-like-condacts) ; Treat open-world conditions like condacts for connectivity
               )
           ; If there is a WM VN attached to the WM FN, use it; otherwise create a new one
           (setq outgoing-vn (predicate-outgoing-vn pred))
           (if outgoing-vn
               (progn
                 (setq wmvn outgoing-vn)
                 (setf (node-pattern-type outgoing-vn) 'condact)
                 )
             (progn
               (setq wmvn (create-wm-variable-node pred wmfn
                                                   (concat-symbols `(,p-name shared wm-vn) t)
                                                   ; condacts-change-wm
                                                   nil
                                                   wmvs t t nil out (predicate-exponential pred))
                     )
               )
             )
           )
          ((and in (not out)) ; Actions
           (setq wmvn (add-action pred wmfn ; Will return a list of two nodes for closed-world selection predicate
                                  (if share 'shared 'action)
                                  (concat-symbols (list cond-name p-name) t)
                                  (concat-symbols (elements-constants pp) t)
                                  negated (predicate-exponential pred) wmvs c
                                  share
                                  (predicate-persistent pred)
                                  open))
           (setq action t)
           )
          ((and (not in) out) ; Conditions
           (setq wmvn (add-condition pred wmfn
                                             (concat-symbols `(,p-name shared wm-vn) t)
                                             (concat-symbols (list cond-name p-name) t)
                                             (concat-symbols (elements-constants pp) t)
                                             wmvs c (predicate-exponential pred)
                                             share)
                 )
           )
          )
    ; If condact is negated, error
    (when (and in out negated)
      (error "Negation is not allowed in condacts, as used in pattern ~S of conditional ~S." pp (conditional-name c))
      )
    ; If action is negated, insert transform (inversion or negation) factor and variable node
    (when (and in (not out) negated)
      (setq iwmvs (transform-variables wmvs)) ; Replace WM vars with transformed/inverse vars
      (setq reduced-wmvn
            (init-variable-node
             (concat-symbols (list cond-name p-name 'action-neg-wm-vn) t)
             'inversion nil nil iwmvs t (pattern-type in out)))
      (setq transform-node (create-transform-factor c (if (or (predicate-vector pred) (predicate-no-normalize pred)) 'negate 'invert) iwmvs wmvs reduced-wmvn wmvn wmvn in out nil))
      (when (and (eq p-name 'selected) ; Action for selected
                 in ; With next, detect that this is an action
                 (not out)
                 )
        (setf (graph-negative-preferences cg) (cons transform-node (graph-negative-preferences cg)))
        )
      (setq wmvn reduced-wmvn) ; Make new variable node the one to build on for rest of alpha path
      (setq wmvs iwmvs) ; Use inverted vars for rest of alpha path
      (setq reduced-vs (copy-seq iwmvs)) ; Copy negated vars for use in alpha path
      )
    ; If pattern is exponentiated, insert transform/exponentiate factor and variable node
    (when exponential
      (setq iwmvs (transform-variables reduced-vs)) ; Replace WM vars with transformed vars
      (setq reduced-wmvn
            (init-variable-node
             (concat-symbols (list cond-name p-name 'EV) t)
             'exponential nil nil iwmvs t (pattern-type in out)))
      (setq transform-node (create-transform-factor c 'exponentiate iwmvs reduced-vs reduced-wmvn wmvn wmvn in out nil))
      (when (predicate-unique pred)
        (setf (node-normalize transform-node) t)
        )
      (setq wmvn reduced-wmvn) ; Make new variable node the one to build on for rest of alpha path
      (setq wmvs iwmvs)
;      (setq wmvs (transform-variables wmvs)) ; Use transformed vars for rest of alpha path [Use this form rather than previous if after dolist on elements]
      (setq reduced-vs iwmvs) ; Transformed vars for use in rest of alpha path
      )
    ; Process elements of pattern, handling constant and variable tests (and affine transforms)
    (dolist (element pp)
      (setq e-rest (element-rest element)) ; Stuff after element argument and content
      (when (and e-rest ; Syntax error if stuff after argument and content, and
                 (or (not (weight-list (car e-rest))) ; First part of rest is not a weight vector, or
                     (cdr e-rest))) ; There is even more after the weight vector
        (error "Extra stuff in element ~S of pattern ~S in conditional ~S"
               element original-pp (conditional-name c)))
      (setq evnum (element-wm-index element pred)) ; Index of element in predicate WM
      (unless evnum
        (error "Argument ~S not defined in predicate ~S, but used in conditional ~S"
               (car element) p-name (conditional-name c))
        )
      (setq ev (aref wmvs evnum)) ; WM variable corresponding to the element
      (setq wmvn-vs (node-variables wmvn)) ; Variables in variable node prior to constant test
      (setq e-arg-name (element-argument-name element)) ; Argument name
      (setq e-content (element-content element)) ; Argument contents
      (setq e-type (type-from-predicate-argument e-arg-name pred)) ; Argument type
      (cond ((variable-element e-content) ; Process a variable element
             (setf (aref variable-exists evnum) t)
             ; Get name of variable from element
             (setq c-vn (car e-content))
             ; Get existing conditional variable for name if it exists
             (setq c-v (variable-from-name c-vn (conditional-variables c)))
             ; Signal error if type of condtional variable not same as type of pattern argument
             (when (and c-v (not (equal (stype-name e-type) (stype-name (svariable-type c-v)))))
               (error "Type mismatch in conditional ~S; Variable ~S used for both types ~S and ~S!"
                      cond-name (svariable-name c-v) (stype-name e-type) (stype-name (svariable-type c-v)))
               )
             (unless c-v ; Conditional variable does not already exist, so create it
               (setq c-v (make-svariable :name c-vn
                                         :type e-type
                                         :unique (variable-unique-in-conditional c-vn c)
                                         ))
               (setf (conditional-variables c) (cons c-v (conditional-variables c)))
               (when action
                 (setq new-action-var t)
                 )
               )
             (cond ((member c-vn c-varns) ; Conditional variable already used in pattern (within pattern variable equality testing)
                    (setf (aref c-vars-i (position e-arg-name p-args :key #'car)) c-vn) ; Signal that predicate variable maps to existing pattern variable
                    (setq new-action-var nil)
                    )
                   (t ; Conditional variable is new for this pattern
                    (setq c-varns (cons c-vn c-varns)) ; List of conditional variable names in pattern
                    (setq c-vars (cons c-v c-vars)) ; List of conditional variables in pattern 
                    (setf (aref c-vars-i (position e-arg-name p-args :key #'car)) c-v)
                    )
                   )
             (setf (aref c-vars-d evnum) t)
             (setf (aref c-vars-e evnum) t)
             (dolist (variable-modifier (cdr e-content))
               (cond ((numberp variable-modifier) ; There is an offset (special case of an affine transform)
                      ; Convert offset into affine
                      (setq aff (make-affine :offset variable-modifier :to c-vn :from c-vn))
                      (setq affines (cons aff affines))
                      )
                     ((affine-listp variable-modifier) ; An affine transform
                      (setq coef-position (position ':coefficient variable-modifier))
                      (when coef-position
                        (setq coef (nth (+ coef-position 1) variable-modifier))
                        (when (= coef 0)
                          (error "Coefficient in affine transform in conditional ~S must not be 0."
                                 (conditional-name c))
                          )
                        )
                      (setq aff (apply #'make-affine variable-modifier))
                      (setf (affine-to aff) c-vn)
                     
                     (if (affine-from aff)
                          ;(when (and in (not out)) ; An action
                         (when in ;not condition
                            (error "Use the condact/condition variable ~S directly in condact/action ~S of conditional ~S instead of using a new condact/action variable (~S) in conjunction with :FROM ~S."
                                   (affine-from aff) pp (conditional-name c) (affine-to aff) (affine-from aff))      ;  Volkan: Allowing different :from and :to variables create problems while applying coefficients                              
                            )
                        (setf (affine-from aff) (affine-to aff)) ; "From" defaults to "to"
                        )
                      (unless (eq e-type ; Type of :to variable
                                  (svariable-type (variable-from-name (affine-to aff) c-vars))
                                  )
                        (error "Mismatched variable types ~S and ~S in affine transform ~S in conditional ~S."
                               (stype-name e-type)
                               (stype-name (svariable-type (variable-from-name (affine-to aff) c-vars)))
                               aff (conditional-name c))
                        )
                       (when (and (affine-offset aff) (symbolp (affine-offset aff))) ; A variable is used as the offset
                        (if (and (not in) out) ; This is a condition ;VOLKAN
                            (error "Variables not currently allowed as offsets in conditions: Pattern ~A in conditional ~S." original-pp (conditional-name c))
                          (progn  
                            (setq action-offset-variable (variable-from-name (affine-offset aff) (conditional-variables c)))
                            (setq action-from-variable (variable-from-name (affine-from aff) (conditional-variables c)))
                            )                                              
                          )
                        ) 
                       
                       (setq affines (cons aff affines))
                      )
                     ((filter-listp variable-modifier) ; A filter on the variable
                      (setf (aref filters evnum) (create-element-plm ev (cdr variable-modifier) 0)) ; Add filter in its place in the vector
                      (setq afilter t)
                      (unless (e= (filter-coef variable-modifier) 0)
                        (setq linear-filter t)
                        )
                      )
                     ((eq variable-modifier ':explicit)
                      (if new-action-var
                          (setq explicit-var (svariable-name ev))
                        (error "Attempt to generate an explicit distribution over variable (~S) that isn't a new action variable in pattern ~S of conditional ~S"
                               c-vn original-pp (conditional-name c))
                        )
                      )
                     ((not-equal-listp variable-modifier) ; A not-equal (<>) test on a prior variable
                      (unless (stype-discrete e-type)
                        (error "Argument ~S is not discrete in a not-equal (<>) test in pattern ~S in conditional ~S"
                               e-arg-name original-pp cond-name)
                        )
                      (when (member (cadr variable-modifier) c-varns) ; This is a within-pattern not-equal (<>) test
                        (unless (eq e-type (type-from-predicate-argument (argument-from-variable (cadr variable-modifier) pp) pred))
                          (error "Variables ~S (~S) and ~S (~S) are not of the same type in a not-equal (<>) test in pattern ~S in conditional ~S"
                                 c-vn (stype-name e-type) (cadr variable-modifier)
                                 (stype-name (type-from-predicate-argument (argument-from-variable (cadr variable-modifier) pp) pred))
                                 original-pp cond-name)
                          )
                        (unless (not in)
                          (error "Within-pattern not-equal (<>) test in an action or condact (~S) in conditional ~S"
                                 original-pp cond-name)
                          )
                        )
                      (if (member (cadr variable-modifier) c-varns)
                          (setf (aref not-equals evnum) (cadr variable-modifier)) ; Unequal to a variable in the same pattern
                        (setq beta-not-equal-vars (cons (list c-vn (cadr variable-modifier)) beta-not-equal-vars))) ; Unequal to a variable in a previous pattern
                      )
                     ((eq variable-modifier not-equal-symbol)
                      (error "Not-equal symbol (<>) is not first element of a list after variable ~S in pattern ~S of conditional ~S" c-vn original-pp cond-name)
                      )
                     )
               )
             )
            ((and (or in out) (constant-element e-content)) ; Process a constant/filter element if messages are passing
             (setf (aref filters evnum) (create-element-plm ev (if (filter-listp e-content) ; A filter
                                                                   (cdr e-content) ; Remove :filter from front
                                                                 (list (list e-content 1 0))) ; Turn into filter data
                                                            )
                   )
             (setf (aref c-vars-e evnum) t)
             (setq afilter t)
             (when (and (filter-listp e-content)
                        (not (e= (filter-coef e-content) 0)))
               (setq linear-filter t)
               )
             ; Remove WM variable for current constant from list
             (setq reduced-vs (remove ev reduced-vs))
             )
            )
      )
    (when (or afilter ; There is at least one variable with a filter
              (position nil c-vars-e)) ; or there is at least one WM variable not mentioned in the pattern
      (setq filter-fn (create-filter-function wmvs filters)) ; Create filter function
      (dotimes (i wmvs-rank)
        (unless (aref variable-exists i) ; There is no conditional variable for this WM variable
          (setq reduced-vs (remove (aref wmvs i) reduced-vs)) ; Don't include variable in resulting variable node
          )
        )
      ; If sharing filters, and this is a condition, see if there is an existing one to share
      (when (and share-condition-tests out (not in))
        (setq shared-wmvn (shared-filter-wmvn wmvn filter-fn reduced-vs))
        )
      ; If there is a shared filter, simply pick up with its subsequent variable node
      (if shared-wmvn
          (setq wmvn shared-wmvn)
        (progn
          ; Create variable node for output from filter test (and make it WM variable for next iteration)
          (setq reduced-wmvn
                (init-variable-node
                 (concat-symbols (list cond-name p-name 'fiv) t)
                 'filter nil nil reduced-vs t (pattern-type in out)))
          ; Create factor node for filter test
          (setq filter-node
                (init-factor-node (concat-symbols (list cond-name p-name 'fif) t)
                                  'filter
                                  wmvn-vs                  
                                  (list wmvn reduced-wmvn)
                                  (list wmvn) in out nil nil c))
          (setf (node-function filter-node) filter-fn)
          ; Mark node has having a linear filter if linear-filter is true
          (when linear-filter
            (setf (node-linear-filter filter-node) t)
            )
          ; Set things up to invert open-world predicates through filters
          ; Always do for messages through condacts to WM
          ; Do for open-world actions if open-actions-like-condacts it T
          ; Do for messages through condacts from WM if all-condact-filters-pad-1 is T
          ; Do for open-world conditions of open-conditions-like-condacts and all-condact-filters-pad-1 are both T   
          (when (and open ; Open world
                     (or (and in out) ; condact
                         (and in open-actions-like-condacts) ; Open-world action to be treated like incoming part of condact
                         (and out open-conditions-like-condacts) ; Open-world condition to be treated like outgoing part of condact
                         )
                     )
            (setf (node-inverse-function filter-node) (transform-plm #'invert-function-variant filter-fn))
            (setf (node-subsubtype filter-node)
                  (cond ((and in out) ; condact
                         (if all-condact-filters-pad-1 'inverse-both 'inverse-in))
                        ((and in open-actions-like-condacts) ; Open-world action to be treated like incoming part of condact
                         'inverse-in)
                        ((and out open-conditions-like-condacts) ; Open-world condition to be treated like outgoing part of condact
                         'inverse-out)))
            )
          ; Set things up for processing after filter test(s)
          (setq wmvn reduced-wmvn)
          ))
      )
    ; If condition is negated, insert transform/inversion factor and variable node
    (when (and out (not in) negated)
      (setq iwmvs (transform-variables reduced-vs)) ; Replace WM vars with transformed/inverse vars
      (setq shared-wmvn (if share-condition-tests (shared-negation-wmvn wmvn) nil))
      (if shared-wmvn
          (setq wmvn shared-wmvn)
        (progn
          (setq reduced-wmvn
                (init-variable-node
                 (concat-symbols (list cond-name p-name 'wm-neg-vn) t)
                 'inversion nil nil iwmvs t (pattern-type in out)))
          (setq transform-node (create-transform-factor c 'invert iwmvs reduced-vs reduced-wmvn wmvn wmvn in out nil))
          (setq wmvn reduced-wmvn) ; Make new variable node the one to build on for rest of alpha path
          ))
      (setq wmvs (transform-variables wmvs)) ; Use inverted vars for rest of alpha path
      (setq reduced-vs iwmvs) ; Negated vars for use in rest of alpha path
      )
    (when explicit-var
      (setq reduced-wmvn
            (init-variable-node (concat-symbols (cons (conditional-name c) (cons p-name (cons 'XV c-varns))) t)
                                'explicit nil nil reduced-vs t (pattern-type in out)))
      (setq explicit-node (init-factor-node (concat-symbols (cons (conditional-name c) (cons p-name (cons 'XF c-varns))) t)
                                              'explicit reduced-vs (list wmvn reduced-wmvn) (list wmvn) in out nil t c))
      (setf (node-function explicit-node) (list ':explicit (position explicit-var reduced-vs :key #'svariable-name)))
      (setq wmvn reduced-wmvn)
      )
    (when c-vars ; If there are any variables create a delta factor
      ; Reverse the lists so get in good reading order for people (original order)
      (setq c-varns (reverse c-varns))
      (setq c-vars (reverse c-vars))
      ; Convert list of variables to vector of variables
      (setq c-vars-v (coerce c-vars 'vector))
      ; Create variables for delta node (paired previous/WM and pattern vars)
      (setq delta-vs (delta-variables (length (node-variables wmvn)) c-vars-d c-vars-i wmvs))
      (setq shared-wmvn (if (and share-condition-tests out (not in)) (shared-delta-wmvn wmvn c-vars-v) nil))
      (if shared-wmvn
          (setq wmvn shared-wmvn)
        (progn
          ; Create new memory for pattern after delta
          (setq reduced-wmvn
                (init-variable-node (concat-symbols (cons (conditional-name c) (cons p-name (cons 'ADV c-varns))) t)
                                    'delta nil nil c-vars-v t (pattern-type in out)))
          ; The new memory is currently the last memory in the conditional
          (setf (conditional-last-memory c) reduced-wmvn)
          ; Create delta factor
          (create-delta-factor c delta-vs c-varns reduced-wmvn wmvn wmvn in out 'match pred not-equals)
          (setq wmvn reduced-wmvn)
          ))
      )
    (when affines ; There is at least one variable with a transform
      
      ; If there is a separate from variable in an action, add it to the variables
       ; (when action-from-variable
      (when (not (eql (affine-from aff) (affine-to aff))) ; when there is a separate to affine-from variable, add it to the variables
        (setq c-vars-v (extend-vector c-vars-v action-from-variable))
        ;(setf (aref c-vars-v (position (affine-to aff) c-vars-v :key #'svariable-name)) action-from-variable)
        )

       ; If there is an offset variable in an action, add it to the variables
      (when action-offset-variable
        (setq c-vars-v (extend-vector c-vars-v action-offset-variable))
        )
    
      ; Convert :from and :to fields from pattern variable name to pattern variable numbers
      (dolist (aff affines)
        (setf (affine-from aff) (position (affine-from aff) c-vars-v :key #'svariable-name))
        (setf (affine-to aff) (position (affine-to aff) c-vars-v :key #'svariable-name))
        )
     
      ; Create variable node after transform factor node
      (setq reduced-wmvn
            (init-variable-node
             (concat-symbols (list cond-name p-name 'av) t)
             'affine nil nil 
             (if (eq (affine-to aff) (affine-from aff)) c-vars-v (reduce-vector c-vars-v (aref c-vars-v (affine-to aff))))
             t (pattern-type in out)))

      ;Volkan offset-variable node
      (when action-offset-variable
        (setq o-vars-v (reduce-vector c-vars-v (aref c-vars-v (affine-to aff))))
        (setq o-vars-v (reduce-vector o-vars-v (aref c-vars-v (affine-from aff)))) ;VOLKAN need to check whether this works all the time.
        ;(setq o-vars-v  (coerce (list action-offset-variable) 'vector))
        (setq offset-vn 
            (init-variable-node
             (concat-symbols (list cond-name p-name 'ov) t)
             'offset nil nil o-vars-v t (pattern-type t nil)))
        (setf (node-normalize offset-vn) t)
      )
      
             
      ; Create transform factor node
      (setq affine-node
            (init-factor-node (concat-symbols (list cond-name p-name 'af) t)
                              'affine
                              c-vars-v
                              (if action-offset-variable (list wmvn reduced-wmvn offset-vn) (list wmvn reduced-wmvn)) ;Volkan
                              (list wmvn) in out nil nil c))
      (setf (node-region-pad affine-node) (if (affine-pad aff) (affine-pad aff) (if open 1 0)))
      (when (predicate-unique pred)
        (setf (node-normalize affine-node) t)
        )
      (setf (node-function affine-node) affines)
      (setq wmvn reduced-wmvn)
      )
    (unless (eq (node-subtype wmvn) 'wm)
      (setf (node-subtype wmvn) 'alpha)
      )
    (setf (node-subsubtype wmvn) (if in (if out 'condact 'action) 'condition))
    (setf (conditional-alpha-memories c) (cons wmvn (conditional-alpha-memories c)))
    (values (cons wmvn beta-not-equal-vars) offset-vn)) ;Volkan
  )


; Create portion of the beta network for a pattern
(defun create-beta-network (c later-vars alpha-memory previous-beta-memory create-new-beta next-action out in &optional beta-not-equal-vars offset-vn)
  (let (beta-vars ; Variables used in the beta memory
        beta-var-names ; Names of beta variables
        new-beta-memory ; Memory after beta factor
        beta-node-vs ; Variables used in the beta factor
        beta-function ; Function in beta factor
        beta-neighbors ; Neighbors of beta factor
        beta-node ; Beta factor node
        (alpha-vars (node-variables alpha-memory)) ; Variables in alpha memory
        beta-memories
        same-neighbor ; There is a neighbor with same variables (in same order)
        same-length-neighbor ; Neighbor with same variables but different order
        beta-ne-vns ; List of pairs of not-equal variable numbers (from the names in beta-not-equal-vars)
        )
    ; The variables used in the beta-memory are from the alpha and the previous beta,
    ; omitting those not used later
    (setq beta-vars
          (if previous-beta-memory
              (merge-variable-vectors (node-variables previous-beta-memory) alpha-vars)
            alpha-vars))
    ; Eliminate any variables from the list that aren't used later
    (setq beta-vars (eliminate-vars-if-not-named later-vars beta-vars))
    ; Create a new beta memory for linear chain of patterns
    (when create-new-beta
      (setq beta-var-names (variable-names beta-vars))
      (setq new-beta-memory
            (init-variable-node (concat-symbols (cons (conditional-name c)
                                                      (cons 'BM beta-var-names)) t)
                                'beta nil nil beta-vars nil (node-pattern-type alpha-memory)))
      ; The following is used to optimize out link directions coming out of BFs
      (setf (node-subsubtype new-beta-memory) (if next-action 'action (if in 'condact 'condition)))
      (when next-action
        (setf (conditional-shared-action-beta c) new-beta-memory)
        )
      )
    ; Set last memory in conditional
    (setf (conditional-last-memory c)
          (if new-beta-memory
              new-beta-memory
            (if previous-beta-memory
                previous-beta-memory
              alpha-memory)
            ))
    ; The variables used in the beta factor are from the alpha, the previous beta
    ; and the next beta if there should be one
    ; Start merging with next beta if it exists so that hopefully get variables in the right order
    (if (not-empty-vector beta-vars)
        (setq beta-node-vs (merge-variable-vectors beta-vars (node-variables alpha-memory)))
      (setq beta-node-vs (node-variables alpha-memory)))
    (when previous-beta-memory
      (setq beta-node-vs (merge-variable-vectors beta-node-vs
                                                 (node-variables previous-beta-memory))))
    ; Specify nodes that are neighbors of the beta factor node
    (setf beta-memories (make-beta-memories :alpha alpha-memory :old-beta previous-beta-memory :new-beta new-beta-memory))
    (if offset-vn (setq beta-neighbors (list alpha-memory offset-vn)) (setq beta-neighbors (list alpha-memory)))
    (when previous-beta-memory (setq beta-neighbors (cons previous-beta-memory beta-neighbors)))
    (when new-beta-memory (setq beta-neighbors (cons new-beta-memory beta-neighbors)))
    ; Reorder variables in beta factor according to first neighbor with same number of variables
    ; This is an attempt to encourage the optimization that skips the first product when the variables align
    ; It doesn't check that the neighbor actually sends messages in direction of factor.  Should it?
    (dolist (bn beta-neighbors)
      (when (= (length beta-node-vs) (length (node-variables bn)))
        (if (variables-equal beta-node-vs (node-variables bn))
            (setq same-neighbor t)
          (setq same-length-neighbor bn))
        )
      )
    (when (and same-length-neighbor (not same-neighbor))
      (setf beta-node-vs (copy-seq (node-variables same-length-neighbor)))
      )
    ; Create a beta node
    (setq beta-node (init-factor-node (concat-symbols (cons (conditional-name c)
                                                                (cons 'BF (variable-names beta-node-vs))) t)
                                        'beta
                                        beta-node-vs
                                        beta-neighbors
                                        (list alpha-memory) in out beta-memories nil c))
    ; A beta function just has a constant function of 1 unless there are not-equal (<>) tests
    (setq beta-function (full-plm beta-node-vs))
    (setq beta-ne-vns (beta-not-equal-vars-nums beta-not-equal-vars beta-node-vs))
    (dolist (bnv beta-ne-vns) ; Check that variable types match up
      (unless (eq (svariable-type (aref beta-node-vs (car bnv)))
                  (svariable-type (aref beta-node-vs (cadr bnv))))
        (error "Variables ~S (~S) and ~S (~S) are not of the same type in a not-equal (<>) test in conditional ~S"
               (svariable-name (aref beta-node-vs (car bnv))) (stype-name (aref beta-node-vs (car bnv)))
               (svariable-name (aref beta-node-vs (cadr bnv))) (stype-name (aref beta-node-vs (cadr bnv)))
               (conditional-name c))
        )
      )
    (when beta-not-equal-vars ; There are across-pattern not-equal (<>) tests
      (setq beta-function (create-beta-not-equal-function beta-function beta-ne-vns))
      (setf (node-beta-non-full beta-node) t)
      )
    (setf (node-function beta-node) beta-function)
    ; Deactivate link direction from condact beta factor to previous condition beta (or alpha) memory
    (when (and (eq (node-subsubtype (if previous-beta-memory previous-beta-memory alpha-memory)) 'condition)
               new-beta-memory
               (eq (node-subsubtype new-beta-memory) 'condact)
               )
      (setf (link-out (link-from-nodes beta-node (if previous-beta-memory previous-beta-memory alpha-memory))) nil)
      )
    beta-node)
  )


; Create a list of lists of variable numbers from names for beta not-equal (<>) tests
(defun beta-not-equal-vars-nums (ne-vars vars)
  (let (nums)
    (dolist (vpair ne-vars)
      (setq nums (cons (list (variable-number (car vpair) vars) (variable-number (cadr vpair) vars)) nums))
      )
    nums)
  )

; Create a function with 0 diagonals for a beta node based on not-equal (<>) tests
(defun create-beta-not-equal-function (p ne-vnums)
  (dolist (d (if (> (length ne-vnums) 1) (apply #'union ne-vnums) (if ne-vnums (car ne-vnums) ne-vnums))) ; Shatter each dimension involved in diagonalization
    (setq p (shatter-plm p d))
    )
  (dolist (ne-vp ne-vnums)
    (setq p (zero-diagonal p ne-vp))
    )
  p
  )

; Is node a beta factor?
(defun beta-factor (n)
  (and (factor-nodep n) (eq (node-subtype n) 'beta))
  )

; Retrieve pattern variable data given name of variable
(defun pattern-variable-data (pv)
  (find pv (graph-pattern-vars cg) :key #'pattern-variable-name))

; Retrieve alpha memory for existing pattern variable if there is one (otherwise nil)
(defun get-pattern-variable-wm-memory (pv)
  (let ((pvd (pattern-variable-data pv)))
    (if pvd (pattern-variable-wm-memory pvd) nil)
    )
  )

; Find link on graph based on variable and factor nodes
(defun find-link (vn fn)
  (dolist (link (graph-links cg))
    (when (and (eq vn (link-var-node link))
               (eq fn (link-fact-node link)))
      (return link)
      )
    )
  )

; Generate a message from first node to second node (specified as numbers)
; Used in testing message generation from nodes
(defun create-message (n1 n2 wm-driven)
  (let ((node1 (node-from-number n1))
        (node2 (node-from-number n2))
        )
    (unless node1 (error "No node corresponding to number ~S." n1))
    (unless node2 (error "No node corresponding to number ~S." n2))
    (make-message :index (if (variable-nodep node1) 0 1)
                  :link (if (variable-nodep node1)
                            (find-link node1 node2)
                          (find-link node2 node1))
                  :wm-driven wm-driven
                  )
    )
  )

; Remove links based on out and in
(defun remove-links (alpha-memory beta-factor out in)
  (let ((link (find-link alpha-memory beta-factor)))
    (unless out (setf (aref (link-contents link) var-index) nil))
    (unless in (setf (aref (link-contents link) fact-index) nil))
    )
  )

; Get pattern/alpha variable name, if it exists, from pattern; otherwise nil
(defun get-pattern-variable-name (pp)
  (setq pp (cdr pp)) ; Strip off predicate name
  (if (eq (car pp) negation-symbol) ; Strip off negation symbol if it is there
      (setq pp (cdr pp)))
  (if (listp (car pp)) ; If symbol, return, otherwise nil
      nil
    (car pp))
  )

; Return first predicate argument missing from pattern, or nil if none are missing
(defun argument-missing (pattern predicate)
  (let (missing
        (pattern-arguments (cdr pattern))
        )
    ; Strip off negation and alpha variable if they are there
    (unless (listp (car pattern-arguments))
      (setq pattern-arguments (cdr pattern-arguments)))
    (unless (listp (car pattern-arguments))
      (setq pattern-arguments (cdr pattern-arguments)))
    (dolist (arg (predicate-arguments predicate))
      (unless (member (argument-name arg) pattern-arguments :key #'car)
        (return (setq missing (argument-name arg)))
        )
      )
    missing)
  )

; Compile a pattern of a conditional.
; g is a graph, pp is the predicate pattern,
; later-vars are variables used later in the conditional, c is the conditional,
; and out and in specify whether the links out from the alpha to the beta or in
; from the beta to the alpha should be active
(defun compile-predicate-pattern (pattern-type pp later-vars create-beta-memory next-action c out in)
  (let ((previous-beta-memory (if (conditional-shared-action-beta c)
                                  (conditional-shared-action-beta c) ; Shared beta memory to which to connect all action beta factors
                                (conditional-last-memory c))) ; Last beta memory (or alpha if not beta)
        alpha-results
        alpha-memory
        predicate
        offset-vn;Volkan
;        missing-argument
        )
    ; Check if predicate is defined
    (setq predicate (predicate-from-name (car pp) t))
    (unless predicate
      (error "Undefined predicate ~S in pattern ~S of conditional ~S." (car pp) pp (conditional-name c))
      )
    ; Check if there are any predicate arguments not included in pattern (return first missing one or nil)
;    (setq missing-argument (argument-missing pp predicate))
;    (when missing-argument
;      (error "Predicate argument ~S missing from pattern ~S in conditional ~S."
;             missing-argument pp (conditional-name c))
;      )
    ; List conditional in predicate when learn for predicate and pattern is a condact
    (when (and (eq pattern-type 'condacts)
               (predicate-function predicate)
               (not (equal (predicate-learning-rate predicate) 0))
               )
      (setf (predicate-condact-conditionals predicate) (cons c (predicate-condact-conditionals predicate)))
      )         
    ; Create an alpha network (and memory)
    (multiple-value-setq (alpha-results offset-vn) (create-alpha-network pp c in out))
    (setq alpha-memory (car alpha-results))
    (when (and out (not in))
      (setf (conditional-last-condition-memory c) alpha-memory)
      )
    ; Add a beta factor and memory
    (if previous-beta-memory
        (create-beta-network c later-vars alpha-memory previous-beta-memory create-beta-memory next-action out in (cdr alpha-results) offset-vn)
      (setf (conditional-last-memory c) alpha-memory)
      )
    )
  )


; Compile a set of patterns from conditional c into a graph
; The set will be the conditions, the condacts or the actions
(defun compile-patterns (c pattern-type patterns later-vars later-linear-patterns out in)
  (do ((patterns-l patterns (cdr patterns-l))
       (lvs-l (cdr later-vars) (cdr lvs-l)))
      ((null patterns-l) nil)
    (compile-predicate-pattern pattern-type
                               (car patterns-l)
                               (car lvs-l)
                               (or later-linear-patterns ; Create a new beta memory if there are condacts or functions still yet to come or
                                   (and (not (eq pattern-type 'actions)) ; Not an action and
                                        (or (cdr patterns-l) ; Later linear patterns remaining in this class or
                                            (conditional-actions c) ; There are actions (so last linear before actions gets a beta memory)
                                            )
                                        )
                                   )
                               (and (not (eq pattern-type 'actions)) ; Next pattern is first action if these aren't actions and
                                    (not later-linear-patterns) ; There are no further classes of linear patterns and
                                    (null (cdr patterns-l)) ; And there is nothing left in the current class and
                                    (conditional-actions c) ; There are actions in the conditional
                                    )
                               c out in)      
    )
  )

; Verify predicate name and argument names in a pattern
(defun verify-predicate-pattern (pattern ptype c-name)
  (unless (consp pattern)
    (error "Non-list pattern ~S found as a ~A in conditional ~S" pattern ptype c-name)
    )
  (let ((pred (find (car pattern) (graph-predicates cg) :key #'predicate-name)))
    (unless pred
      (error "Unknown predicate ~S in ~A ~S in conditional ~S" (car pattern) ptype pattern c-name)
      )
    (dolist (element (cdr pattern))
      (when (consp element)
        (let ((argument (find (car element) (predicate-arguments pred) :key #'argument-name)))
          (unless argument
            (error "Unknown argument ~S for predicate ~S in ~A ~S in conditional ~S" (car element) (car pattern) ptype pattern c-name)
            )
          )
        )
      )
    )
  )

; Verify predicate pattern names and arguments
(defun verify-patterns (patterns ptype c-name)
  (dolist (pattern patterns)
    (verify-predicate-pattern pattern ptype c-name)
    )
  )

; Create a list of variable names in a predicate pattern
; If types is true, provide the types of the variables as well
(defun pp-variable-names (pp &optional types)
  (let (vs rest aff pos val type nev)
    (dolist (element pp)
      (when (and (listp element) ; Ignores predicate name and negation at front of pattern
                 (variable-element (element-content element)))
        (when types
          (setq type (type-from-predicate-argument (element-argument-name element) (predicate-from-name (car pp))))
          )
        (setq vs (adjoin (if types (list (car (element-content element)) type) (car (element-content element))) vs))
        (setq rest (cdr (element-content element)))
        (when (and rest (consp (setq aff (car rest))) (symbolp (car aff))) ; An affine transform
          (setq pos (position ':from aff))
          (when (and pos (setq val (nth (+ pos 1) aff)) (symbolp val)) ; There is a variable name after :from
            (setq vs (adjoin (if types (list val type) val) vs))
            )
          (setq pos (position ':offset aff))
          (when (and pos (setq val (nth (+ pos 1) aff)) (symbolp val)) ; There is a variable name after :offset
            (setq vs (adjoin (if types (list val type) val) vs))
            )
          )
        (when (and rest (not-equal-listp (car rest)))
          (setq nev (cadar rest))
          (setq vs (adjoin (if types (list nev type) nev) vs))
            )
        )
      )
      (reverse vs))
  )

; Create a list of the variable names in a list of patterns
(defun all-variable-names (patterns)
  (let (pvs)
    (dolist (pattern patterns)
      (setq pvs (union (pp-variable-names pattern) pvs))
      )
    pvs)
  )

; Determine list of lists of which variable names come after conditions, condacts and actions
(defun later-variable-names (patterns later &optional action)
  (if action
      (mapcar #'pp-variable-names patterns)
    (let ((cs-later (list later)))
      (dolist (rc (reverse patterns))
        (setq cs-later (cons (union (pp-variable-names rc) (car cs-later)) cs-later))
        )
      cs-later)
    )
  )

; If not explicitly specifying function-variable-names
; determine the variable names, and their proper order, for use in a function
; This is all of the variables in the condacts that aren't in the conditions
; Logically this could be done by set-difference if it would guarantee order preservation
(defun function-variable-names (c)
  (unless specify-function-variable-names
    (let (condition-var-names ; List of names of variables in the conditions
          function-var-names ; List of names of variables to be included in the function
          e-content ; Content of the current element
          )
      (setq condition-var-names (all-variable-names (conditional-conditions c)))
      (dolist (condact (conditional-condacts c)) ; Cycle through condacts in order
        (dolist (element condact) ; Cycle through elements of condact (including non-element stuff at front)
          (when (listp element) ; Check if actually an element or prefix information
            (setq e-content (element-content element))
            (when (variable-element e-content) ; Check if element is a variable
              (when (and ; Variable not already seen in conditions or function variables
                     (not (member (car e-content) condition-var-names))
                     (not (member (car e-content) function-var-names)))
                (setq function-var-names (cons (car e-content) function-var-names))))))
        )
      (setf (conditional-function-variable-names c) (reverse function-var-names))
      )
    )
  )

; Maximum volume of a PLM (assuming discrete/unitary variables) given a set of variables
(defun max-discrete-volume (variables)
  (let ((volume 1))
    (dotimes (i (length variables))
      (setq volume (* (stype-span (svariable-type (aref variables i))) volume))
      )
    volume)
  )

; Return conditional function node give name of conditional
(defun conditional-function-node-name-from-conditional-name (cname)
  (node-name (conditional-function-node (conditional-from-name cname)))
  )
(defun cfn (cname) (conditional-function-node-name-from-conditional-name cname))

; Find the type of a variable from a conditional function as used in an action
; Needed when variable isn't used in conditions or condacts
(defun find-action-variable-type (vname c)
  (let (element argname pred arg type)
    (dolist (action (conditional-actions c))
      (when (member vname (pp-variable-names action))
        (setq element (find vname action
                            :key #'(lambda (x) (if (and (listp x) (cdr x) (listp (cadr x)))
                                                   (caadr x)
                                                 nil))))
        (when element
          (setq argname (car element))
          (setq pred (predicate-from-name (car action)))
          (when pred
            (setq arg (assoc argname (predicate-arguments pred)))
            (when arg
              (setq type (type-from-name (cadr arg)))
              (return type)
              )
            )
          )
        )
      )
    type)
  )

; Copy a function from another conditional, updating it with the current variables
; Assumes variable types and ordering corresponds
; Reuses regions rather than copying them
(defun copy-conditional-function (f vs)
  (make-plm :rank (plm-rank f)
            :slices (plm-slices f)
            :active (plm-active f)
            :variables vs
            :array (plm-array f)
            :piecewise-constant (plm-piecewise-constant f)
            )
  )

; Union a (possibly empty) list of symbols
(defun union-lists (ls)
  (case (length ls)
    (0 nil)
    (1 (copy-seq (car ls)))
    (t (reduce #'union ls))
    )
  )

; Compile a conditional function
(defun compile-conditional-function (c)
  (let (p-memory ; Previous memory
        p-vars ; Variables in previous memory
        p-var-names ; Names of variables in previous memory
        x-var-names ; Names of function variables
        x-vars ; Function variables
        xn ; Variable index
        x-function ; Function for function factor
        x-neighbors ; Variable nodes adjacent to function factor
        x-node ; Function factor node
        v-node ; Variable node attached to function factor
        (c-fun (conditional-function c)) ; The specified conditional function
        row-major ; Whether should use special row-major initialization (an all discrete function with a full set of values)
        (c-norm (conditional-normal c)) ; Variable name for the dimension over which to normalize, if any
        (normalize-function t) ; Set the default to normalize the function if there is a normalization variables
        p-index type
        other-c ; Conditional from which function is to be copied
        other-fn ; CFF with function to copy
        message-to-function ; Whether to activate links towards function
        )
    (when (null c-fun) (setq c-fun 1)) ; Default to a constant one if no function specified
    ; Check for special case of a row-major function
    (when (and (consp c-fun) (eq (car c-fun) 'row-major))
      (setq c-fun (cdr c-fun))
      (setq row-major t)
      )
    ; List of variable names to be used in function, in order they appear (or specified variable names)
    (setq x-var-names (conditional-function-variable-names c))
    ; List of variables to be used in function
    (setq x-vars (init-vector (length x-var-names)))
    (setq xn 0)
    ; Beta memory that connects the function to the rest of the graph
    (setq v-node (init-variable-node (concat-symbols (cons (conditional-name c)
                                                  (cons 'cfv x-var-names)) t)
                                     'function nil nil x-vars nil (if (conditional-condacts c) 'condact 'action)))
    (setq p-memory (conditional-last-memory c)) ; Memory to which function subgraph is to be attached
    (if p-memory ; There is a preceding condition or condact
        (progn
          (setq p-vars (node-variables p-memory)) ; Variables in previous memory
          (setq p-var-names (variable-names p-vars)) ; Names of variables in previous memory
          )
      (setf (conditional-last-memory c) v-node))
    (dolist (xvn x-var-names)
      (when p-memory
        (setq p-index (position xvn p-var-names)) ; Index of variable in previous, if it is there
        )
      (if p-index
          (setf (aref x-vars xn) (aref p-vars p-index)) ; Copy variable from previous
        (progn
          (setq type (find-action-variable-type xvn c))
          (if type
              (setf (aref x-vars xn) (make-svariable :name xvn :type type))
            (error "Variable ~S in function for conditional ~S does not appear in any pattern." xvn (conditional-name c)))
          ))
      (setq xn (1+ xn))
      )
    ; Determine which nodes are neighbors of the function factor node
    (setq x-neighbors (list v-node))
    (setq message-to-function (and feedback-to-functions
                                   learn-via-gradient-descent
                                   (not (equal (conditional-learning-rate c) 0))
                                   (not (member (conditional-name c) do-not-learn))
                                   ))
    ; Create a function factor node
    (setq x-node
          (init-factor-node (concat-symbols (cons (conditional-name c)
                                                  (cons 'CFF x-var-names)) t)
                            'function
                            x-vars
                            x-neighbors
                            t message-to-function t nil nil c))
    (setf (node-assumption x-node) t)
    (setf (node-function-name x-node) (conditional-name c))
    (setf (conditional-function-node c) x-node)
    ; If the conditional function is a number, use it as a constant PLM
    ; If the conditional function is a symbol, assume it is the name of another conditional whose function is to be shared
    ; Otherwise assume it specifies a full PLM
    (cond ((numberp c-fun)
           (setq x-function (init-plm x-vars c-fun 0 (init-vector (length x-vars) t)))
           (setf (plm-piecewise-constant x-function) t)
           )
          ((symbolp c-fun) ; Copy function from another conditional
           (setq normalize-function nil) ; Don't need to normalize function, as already normalized
           (setq other-c (conditional-from-name c-fun))
           (unless other-c
             (error "No conditional named ~S, as specified in the :FUNCTION for conditional ~S" c-fun (conditional-name c))
             )
           (unless (equal (conditional-function-variable-names c) (conditional-function-variable-names other-c))
             (error "Function variable names ~S in conditional ~S not the same as ~S in conditional to which function is to be tied ~S"
                    (conditional-function-variable-names c) (conditional-name c) (conditional-function-variable-names other-c) (conditional-name other-c))
             )
           (unless (equal (conditional-normal c) (conditional-normal other-c))
             (error "Function normal ~S in conditional ~S not the same as ~S in conditional to which function is to be tied ~S"
                    (conditional-normal c) (conditional-name c) (conditional-normal other-c) (conditional-name other-c))
             )
           (setq other-fn (conditional-function-node other-c))
           (unless other-fn
             (error "No CFF for conditional ~S as needed given specification in conditional ~S" c-norm (conditional-name c))
             )
                             ; Add shared function node, and all nodes it shares with to list of shared function nodes
           (setf (node-shared-functions x-node) (cons other-fn (node-shared-functions other-fn)))
                             ; Add current node to list of shared function nodes for node shared and everyone it shares with
           (setf (node-shared-functions other-fn) (cons x-node (node-shared-functions other-fn)))
           (dolist (cousin (node-shared-functions other-fn))
             (setf (node-shared-functions cousin) (cons x-node (node-shared-functions cousin)))
             )
           (setq x-function (copy-conditional-function (node-function other-fn) x-vars))
           )
          (row-major
           (setq x-function (rml-plm c-fun x-vars t))
           (setf (plm-piecewise-constant x-function) t)
           )
          (t
           (setq x-function (cpt-function-array-plm x-var-names c-fun x-vars
                                                    (if (conditional-function-default c) (conditional-function-default c) function-default) t))
           (setf (plm-piecewise-constant x-function) (notany #'(lambda (x) (consp (car x))) c-fun)) ; No linear regions in specification
           )
          )
    (setf (node-restriction x-node) (transform-plm #'boolean-function x-function)) ; Function that constrains learning to 0s where initial function is 0
    (setf (node-normal x-node) nil)
    (when c-norm
      (setf (node-normal x-node) (if (symbolp c-norm)
                                     (position c-norm x-var-names)
                                   (mapcar #'(lambda (cx) (position cx x-var-names)) c-norm)))
      (when normalize-function ; Avoid renormalizing when it is a function copied from another conditional
        (setq x-function (normalize-plm x-function (node-normal x-node) t))
        )
      )
    (setf (node-function x-node) x-function)
    (setf (node-conditional-name x-node) (conditional-name c))
    (setf (node-changes x-node) 1) ; Initialize number of changes made to fucntion via learning to 0
    ; Set the node's learning rate
    (if (conditional-learning-rate c) ; Use value specified in conditional if specified
        (progn
          (unless (numberp (conditional-learning-rate c))
            (error "Learning rate specified for conditional ~S is not a number" (conditional-name c))
            )
          (if (not (or (conditional-normal c) learn-no-normal (e= (conditional-learning-rate c) 0)))
              (error "Learning rate specified for a conditional with no normal variable when learn-no-normal not T: ~S" (conditional-name c))
            (setf (node-learning-rate x-node) (conditional-learning-rate c)))
          )
      (when adaptive-learning-rate ; Otherwise use the adaptive rate if active
        (setf (node-learning-rate x-node) (/ 0.3 (function-span x-node)))
        ))
    ; Set the node's smoothing parameter
    (when (conditional-smoothing-parameter c) ; Use value specified in conditional if specified
      (unless (numberp (conditional-smoothing-parameter c))
        (error "Learning rate specified for conditional ~S is not a number" (conditional-name c))
        )
      (setf (node-smoothing-parameter x-node) (conditional-smoothing-parameter c))
      )
    ; If there is a previous memory, connect function subgraph to it via a beta factor
    (when p-memory
      (create-beta-network c
                           (union-lists (conditional-action-later-variable-names c))
                           v-node p-memory (conditional-actions c) (conditional-actions c) t message-to-function)
      )
    x-node)
  )

; Statically estimate volume for a type
(defun v-type (type)
  (if (stype-constants type) (stype-span type) ; Number of constants for symbolic
    (if (stype-discrete type) 10 ; 10 for discrete numeric
      100)) ; 100 for continuous numeric
  )

; Determine (approximate) volume of message given variables
; Each v is a variable name followed by its type
(defun vs-volume (vs)
  (let ((vol 1))
    (dolist (v vs)
      (setq vol (* vol (v-type (cadr v))))
      )
    vol)
  )

; Reorder conditions to reduce computation
(defun reorder-conditions (conditions later-vars)
  (let* ((cv (coerce conditions 'vector))
         (cvl (length cv)) ; Number of conditions
         rcl ; Reordered conditions
         bestc ; Best condition so far
         bestv ; Volume for best condition so far
         bestvs-sofar ; Variables after beta for best condition so far
         c-vars ; Variables in conditions
         count
         vs-in-cs ; alist for number of remaining conditions variables are in
         vs-sofar ; Variables included so far
         vs-after-beta ; Variables after beta
         cvol ; Volume of message after beta
         (vs (init-vector cvl)) ; Variables in each condition (with their types)
         )
    ; Determine which variables are in each condition (and overall list of variables)
    (dotimes (i cvl)
      (setf (aref vs i) (pp-variable-names (aref cv i) t))
      (setq c-vars (union (aref vs i) c-vars :key #'car))
      )
    ; Determine how many conditions each variable is in
    (dolist (cv c-vars)
      (setq count 0)
      (dotimes (i cvl)
        (when (member (car cv) (aref vs i) :key #'car)
          (setq count (1+ count))
          )
        )
      (setq vs-in-cs (acons (car cv) count vs-in-cs))
      )
    ; Generate the sequence of reordered conditions
    (dotimes (i cvl)
      (setq bestc nil)
      (setq bestv 1E30)
      ; Check each remaining condition to see if it is best at this point
      (dotimes (j cvl)
        (when (aref cv j) ; Condition not yet added in
          (setq vs-after-beta (union (aref vs j) vs-sofar :key #'car))
          ; Eliminate any variables that can be summarized out
          (dolist (v (aref vs j))
            (when (and (not (member (car v) later-vars))
                       (= (cdr (assoc (car v) vs-in-cs)) 1)
                       )
              (setq vs-after-beta (remove (car v) vs-after-beta :key #'car))
              )
            )
          ; Check if current condition better than best so far
          (setq cvol (vs-volume vs-after-beta))
          (when (< cvol bestv)
            (setq bestc j)
            (setq bestv cvol)
            (setq bestvs-sofar vs-after-beta)
            )
          )
        )
      (when (not bestc) ; No condition has a volume less than 1E30
        (setq bestc (position-if #'(lambda (x) x) cv))
        )
      (setq rcl (cons (aref cv bestc) rcl))
      (setf (aref cv bestc) nil)
      (setq vs-sofar bestvs-sofar)
      ; Reduce the number of remaining conditions for variables in best condition
      (dolist (v (aref vs bestc))
        (setq vs-in-cs (acons (car v) (1- (cdr (assoc (car v) vs-in-cs))) vs-in-cs))
        )
      )
    (reverse rcl))
  )

; Compile conditional c into a graph
(defun compile-conditional (c)
  ; Signal an error if try to redefine a conditional (reuse a conditional name)
  ; Can't presently delete a conditional from graph, so can't redefine
  ; Instead need to reload entire graph at this point
  (when (conditional-from-name (conditional-name c))
    (error "Conditional ~S already exists in graph." (conditional-name c))
    )
  (let ((conditions (conditional-conditions c)))
    ; Verify predicate and argument names in patterns
    (verify-patterns conditions "condition" (conditional-name c))
    (verify-patterns (conditional-condacts c) "condact" (conditional-name c))
    (verify-patterns (conditional-actions c) "action" (conditional-name c))
    ; Determine list of conditional's function variable names if not specified explicitly
    (function-variable-names c)
    ; List of conditional's action variables
    (setf (conditional-action-later-variable-names c)
          (later-variable-names (conditional-actions c) nil t)
          )
    ; Variables in actions and function which must be kept around during condacts
    (setf (conditional-condact-later-variable-names c)
          (later-variable-names (conditional-condacts c)
                                (if (conditional-action-later-variable-names c)
                                    (union (conditional-function-variable-names c) ; Include variables from function
                                           (reduce #'union (conditional-action-later-variable-names c))) ; Include variables from all actions
                                  (conditional-function-variable-names c) ; Just variables from function
                                  )
                                )
          )
    (when automatically-reorder-conditions
      (when (> (length conditions) 1)
        (setq conditions (reorder-conditions conditions (car (conditional-condact-later-variable-names c))))
        )
      (setf (conditional-reordered-conditions c) conditions)
      )
    ; Variables that must be kept around through conditions
    (setf (conditional-condition-later-variable-names c)
          (later-variable-names conditions (car (conditional-condact-later-variable-names c))))
    ; Record the conditional on the graph
    (setf (graph-conditionals cg) (cons c (graph-conditionals cg)))
    ; Compile the conditions and condacts with their own later-variables
    (compile-patterns c 'conditions conditions (conditional-condition-later-variable-names c)
                      (or (conditional-condacts c) (conditional-function c))
                      t nil)
    (compile-patterns c 'condacts (conditional-condacts c) (conditional-condact-later-variable-names c)
                      (conditional-function c)
                      t t)
    ; Create function factor if a conditional function is specified
    (when (conditional-function c)
      (compile-conditional-function c)
      )
    ; Compile actions
    (compile-patterns c 'actions (conditional-actions c) (conditional-action-later-variable-names c) nil nil t)
    )
  )

;---------------------
; HIGH LEVEL
;---------------------
; Vector operations
; -----------------

; Compute the pointwise sum of two vectors
(defun vector-sum (v1 v2 &optional piecewise-constant)
  (if piecewise-constant
      (+ v1 v2)
    (map 'vector #'+ v1 v2)))

; Compute the pointwise difference of two vectors
(defun vector-difference (v1 v2 &optional piecewise-constant)
  (if piecewise-constant
      (- v1 v2)
    (map 'vector #'- v1 v2)))

; Divide vector by number
(defun vector-divide (vin n &optional piecewise-constant)
  (if piecewise-constant
      (/ vin n)
    (let ((vout (init-vector (length vin))))
      (dotimes (i (length vin))
        (setf (aref vout i) (/ (aref vin i) n))
        )
      vout))
  )

; Divide vector by number (but if n is 0, yield 0)
(defun vector-divide-0 (vin n &optional piecewise-constant)
  (if piecewise-constant
      (if (zerop n)
          0
        (/ vin n))
    (let ((vout (init-vector (length vin) 0)))
      (when (not (zerop n))
        (dotimes (i (length vin))
          (setf (aref vout i) (/ (aref vin i) n))
          )
        )
      vout))
  )

; Compute whether two vectors are e=
(defun vector-e= (v1 v2 &optional piecewise-constant)
  (if piecewise-constant
      (e= v1 v2)
    (and (= (length v1) (length v2))
         (every #'e= v1 v2)
         ))
  )

; Compute pointwise OR of two vectors
(defun vector-or (v1 v2 &optional piecewise-constant)
  (if piecewise-constant
      (or v1 v2)
    (map 'vector #'(lambda (a b) (or a b)) v1 v2))
  )

; Compute inverse of a vector
(defun vector-not (v &optional piecewise-constant)
  (if piecewise-constant
      (not v)
    (map 'vector #'(lambda (x) (not x)) v))
  )

; Determine if a vector is all T
(defun vector-all-t (v &optional piecewise-constant)
  (if piecewise-constant
      v
    (every #'(lambda (x) x) v))
  )

; Create a vector of length 'dimension' of uniform 'value'
; Value defaults to nil if not given
(defun init-vector (dimension &optional value)
  (make-array (list dimension) :initial-element value))

; Reduce vector with specified value
(defun reduce-vector (vector value)
  (let* ((vr (length vector))
         nvector
         flag-pos
         )
    (dotimes (i vr)
      (when (eq (aref vector i) value) (setf flag-pos i) (return))
      )
    (when flag-pos
      (setf nvector (init-vector (- vr 1)))
      (dotimes (i flag-pos)
        (setf (aref nvector i) (aref vector i))
        )
      (dotimes (i (- vr (+ flag-pos 1)))
        (setf (aref nvector (+ i flag-pos)) (aref vector (+ 1 (+ i flag-pos))))
        )
      )
    (if flag-pos nvector vector)    
    )
  )

; Init PLM
; --------

; Create a dimension for the origin element
(defun make-spanning-dimension (type is weights)
  (make-dimension :min-slice (if is
                                 (find-slice-at-location (stype-min type) is)
                               (make-slice :location (stype-min type))
                               )
                  :max-slice (if is
                                 (find-slice-at-location (stype-max type) is)
                               (make-slice :location (stype-max type))
                               )
                  :weight weights :discrete (stype-discrete type))
  )

; Create a dimension array for an origin node of a PLM
(defun make-spanning-dimensions (variables isv weights)
  (let* ((rank (length variables))
         (ds (init-vector rank))
         var-s)
    (dotimes (d rank)
      (setq var-s (aref variables d))
      ; When more than one variable mapped to a dimension, just take first (types are all the same)
      (when (listp var-s) (setq var-s (car var-s)))
      (setf (aref ds d) (make-spanning-dimension (svariable-type var-s)
                                                 (if isv (aref isv d) nil)
                                                 weights)))
    ds)
  )

; Create a region covering entire space
; isv is an initial slice vector
(defun make-spanning-region (variables isv constant weights)
  (make-region :constant constant
               :dimensions (make-spanning-dimensions variables isv weights)
               :maximals (init-vector (length variables))
               )
  )

; Create a region, as specified by a list of dimensions, that has a discrete value
; isv is the initial slice vector
; If constant is a number, it becomes the constant value for the region.
; If constant is a list, the first element is the constant and the others are the weights.
; dps is a list of sublists.  The first element of each sublist is a dimension number.
; The rest of the sublist is a min-slice and a max-slice for the dimension.
; Weights is the weight to use for all dimensions not included in dps
(defun make-discrete-region (dps variables isv constant weights)
  (let ((cdrds (make-spanning-dimensions variables isv weights))
        (c constant) ; region constant
        ws ; dimension weights
        )
    (when (listp constant)
      (setq c (car constant))
      (setq ws (cdr constant))
      )
    (dolist (dp dps)
      (setf (dimension-min-slice (aref cdrds (car dp))) (cadr dp))
      (setf (dimension-max-slice (aref cdrds (car dp))) (caddr dp))
      (setf (dimension-weight (aref cdrds (car dp))) (if ws (nth (car dp) ws) 0))
      )
    (make-region :constant c :dimensions cdrds :maximals (init-vector (length variables)))
    )
  )

; Make a dps list (a list of sublists with dimension number, min-slice and max-slice) for dimensions/variables
(defun make-dps-list (ds isv)
  (let (dps)
    (dolist (d ds)
      (setq dps (cons (list d (car (aref isv d)) (cadr (aref isv d))) dps))
      )
    )
  )

; Create a vector of initial slice lists from a vector of variables
(defun initial-slice-vector (variables)
  (let* ((rank (length variables))
         (sv (init-vector rank))
         v-type)
    (dotimes (i rank)
      (setq v-type (svariable-type (if (listp (aref variables i))
                                      (car (aref variables i)) ; Handle case where multiple variables mapped
                                    (aref variables i))))
      (setf (aref sv i) (list (make-slice :location (stype-min v-type) :index 0)
                              (make-slice :location (stype-max v-type) :index 1)))
      )
    sv)
  )

; Create an empty PLM array
(defun make-region-array (ds)
  (make-array ds :element-type 'region)
  )

; Create a list of 1s
(defun list-of-constant (n constant)
  (make-sequence 'list n :initial-element constant)
  )

; Make a PLM with a single region that is a constant-discrete-region
; ds is just a list of dimension numbers that should be defined
(defun make-constant-discrete-plm (ds variables constant weights)
  (let ((rank (length variables))
        origin isv p)
    (setq isv (initial-slice-vector variables))
    (setq origin (make-discrete-region (make-dps-list ds isv) variables isv constant weights))
    (setq p (make-plm :rank rank :active (init-vector rank t) :variables variables
                      :array (make-region-array (list-of-constant rank 1)) :slices isv
                      :piecewise-constant (= weights 0)
                      ))
    (setf (row-major-aref (plm-array p) 0) origin)
    p)
  )

; Origin region of a region array
(defun region-array-origin (rarray)
  (row-major-aref rarray 0)
  )

; Origin region of a PLM
(defun plm-origin (p)
  (region-array-origin (plm-array p))
  )

; Create a new PLM
(defun init-plm (variables constant weights active)
  (let* ((rank (length variables))
        (isv (initial-slice-vector variables))
        (origin (make-spanning-region variables isv constant weights))
        plm
        )
    (setq plm
          (make-plm :rank rank :variables variables
                    :active active
                    :array (make-region-array (list-of-constant rank 1))
                    :slices isv
                    :piecewise-constant (= weights 0)
                    )
          )
    (setf (row-major-aref (plm-array plm) 0) origin)
    plm)
  )

; Determine number of regions in PLM
(defun plm-size (p)
  (array-total-size (plm-array p))
  )

; Reduce all elements of a vector by 1
(defun vector-1 (v)
  (map 'vector #'1- v)
  )

; Create a new PLM with slices
; Assume slices are already copied if necessary
(defun init-plm-with-slices (variables constant weights active slices)
  (let* ((rank (length variables))
         sizev ; Vector of dimension sizes
         sizev-1 ; Sizev reduced by 1 in each location
         rarray ; New region array
         size ; Number of regions in array
         ds ; Dimension vector
         svv ; Vector of slice vectors
         sv ; A slice vector
         iv ; Index vector
         )
    (cond ((zerop rank)
           (setq rarray (make-array nil))
           (setf (aref rarray) (make-region :constant constant
                                            :maximals (vector)
                                            :dimensions (vector)))
           )
          (t
           (sort-slice-list-array slices) ; Sort the slices
           (setq slices (delete-duplicates-slice-list-array slices))
           (index-slice-list-array slices) ; Index the slices
           (setq sizev (dimension-sizes-from-slices slices))
           (setq sizev-1 (vector-1 sizev))
           (setq rarray (make-region-array (coerce sizev 'list)))
           (setq size (array-total-size rarray))
           (setq svv (slice-vector-vector slices)) ; Create a vector of slice vectors
           (setq iv (init-vector rank 0))
           ; Create initial regions in all locations
           (dotimes (i size)
             (setq ds (init-vector rank))
             (setf (row-major-aref rarray i) (make-region :constant constant
                                                          :maximals (init-vector rank)
                                                          :dimensions ds))
             (dotimes (d rank)
               (setq sv (aref svv d))
               (setf (aref ds d) (make-dimension :weight weights
                                                 :discrete (stype-discrete (svariable-type (aref variables d)))
                                                 :min-slice (aref sv (aref iv d))
                                                 :max-slice (aref sv (1+ (aref iv d)))))
               )
             (setq iv (next-index-vector iv sizev-1 rank))
             )
           )
          )
    (make-plm :rank rank :variables variables
              :active active
              :array rarray
              :slices slices
              )
    )
  )

; Init one plm from another (but 0 constants and weights)
(defun init-plm-from-plm (p)
  (init-plm-with-slices (copy-seq (plm-variables p)) 0 0 (copy-seq (plm-active p)) (copy-slice-vector (plm-slices p)))
  )

; Regions
; -------

; Access minimum of a region's dimension
(defun region-min-slice (r d)
  (dimension-min-slice (dimension r d)))
(defun region-min (r d)
  (slice-location (region-min-slice r d)))

; Access maximum of a region's dimension
(defun region-max-slice (r d)
  (dimension-max-slice (dimension r d)))
(defun region-max (r d)
  (slice-location (region-max-slice r d)))

; Compute span of region along dimension
(defun region-span (r d)
  (- (region-max r d) (region-min r d))
  )

; Compute entire volume of region
(defun region-volume (r)
  (reduce #'* (region-dimensions r) :key #'dimension-span)
  )

; Access weight of a region's dimension
(defun region-weight (r d)
  (dimension-weight (dimension r d)))

; Access discrete field of a region's dimension
(defun region-discrete (r d)
  (dimension-discrete (dimension r d)))

; Rank of a region
(defun region-rank (r)
  (length (region-dimensions r)))

; Rank of a node
(defun node-rank (n)
  (length (node-variables n)))

; Determine if one region is before another along some dimension
(defun beforep (r1 r2 d)
  (e<= (dimension-max (dimension r1 d)) (dimension-min (dimension r2 d)) t))

; Determine if two regions overlap along a dimension
(defun overlapp (r1 r2 d)
  (not (or (beforep r1 r2 d) (beforep r2 r1 d))))

; Determine if first dimension is within second (based on min & max)
(defun within-dimension (d1 d2)
  (and (e>= (dimension-min d1) (dimension-min d2) t)
       (e<= (dimension-max d1) (dimension-max d2) t)))

; Determine if first region is contained within the second
(defun within-region (r1 map r2)
  (dotimes (d (region-rank r2) t)
    (unless (within-dimension (dimension r1 (if map (aref (smap-vfactor map) d) d))
                                 (dimension r2 d))
      (return nil)
      )
    )
  )

; Determine if first region is contained within the second
(defun regions-overlap (r1 r2)
  (dotimes (d (region-rank r1) t)
    (unless (overlapp r1 r2 d)
      (return nil)
      )
    )
  )

; Determine extent of a dimension (number) of a region
(defun dimension-extent (d r)
  (- (region-max r d) (region-min r d)))

; Determine if two regions have equal extent along a dimension
(defun equal-extentp (r1 r2 d)
  (and (e= (region-min r1 d) (region-min r2 d) t)
       (e= (region-max r1 d) (region-max r2 d) t)))

; Determine if one region starts before another along some dimension
(defun start-beforep (r1 r2 d)
  (e< (dimension-min (dimension r1 d)) (dimension-min (dimension r2 d))))

; Determine if one region ends after another along some dimension
(defun end-afterp (r1 r2 d)
  (e> (dimension-max (dimension r1 d)) (dimension-max (dimension r2 d))))

; Maxima of the minima along a dimension of two regions
(defun max-region-mins (r1 r2 d)
  (max (region-min r1 d) (region-min r2 d)))

; Minima of the maxima along a dimension of two regions
(defun min-region-maxs (r1 r2 d)
  (min (region-max r1 d) (region-max r2 d)))

; Copy a function from one region to another
(defun copy-function (r1 r2)
  (setf (region-constant r2) (region-constant r1))
  (dotimes (d (region-rank r1))
    (setf (dimension-weight (dimension r2 d)) (dimension-weight (dimension r1 d)))
    )
  )

; Is a region's function constant?
(defun region-function-constantp (r)
  (not (find-if #'(lambda (x) (not (zerop x))) (region-dimensions r) :key #'dimension-weight))
  )

; Is a function constant?
(defun function-constantp (f)
  (not (find-if #'(lambda (x) (not (e= x 0))) f :start 1))
  )

; Copy a region structure, copying the dimensions in the process
(defun copy-region-full (r)
  (make-region :constant (region-constant r)
               :dimensions (copy-dimensions (region-dimensions r))
               :maximals (copy-seq (region-maximals r))
               :evidence (region-evidence r)
               :exponential (region-exponential r)
               )
  )

; Slices
; ------

; Determine if two slices are equal
(defun slice= (x y)
  (e= (slice-location x) (slice-location y) t)
  )

; Determine if a slice is a member of a list (up to epsilon equality)
(defun slice-member (x l)
  (let ((xn (slice-location x))
        existing)
    (dolist (i l nil)
      (when (e= xn (slice-location i) t) ; Do an absolute comparison
        (return (setq existing i))
        )
      )
    existing)
  )

; Remove a slice from a list if it is a member (up to epsilon equality)
(defun slice-remove (x l)
  (let ((xn (slice-location x))
        newl)
    (dolist (i l (reverse newl))
      (if (e= xn (slice-location i) t)
          newl
        (setq newl (cons i newl))))
    )
  )

; Epsilon arithemetic
; -------------------

; Are two numbers equal within epsilon
(defun e= (n1 n2 &optional absolute arousal)
  (if (and (numberp n1) (numberp n2))
      (or (= n1 n2)
          (if (and use-relative-epsilon (not absolute)) ; Relative comparison
              (let ((max (max n1 n2))
                    (min (min n1 n2))
                    )
                (<= (- max min) (* (if arousal (* arousal relative-epsilon)
                                     relative-epsilon)
                                   (if (< max 0) (- min) max)))
                )
            (< (abs (- n1 n2)) (if arousal (* arousal epsilon)
                                 epsilon))) ; Absolute comparison
          )
    (eq n1 n2)) ; When either isn't a number
  )

; Are two numbers equal within absolute epsilon
(defun ae= (n1 n2)
  (e= n1 n2 t)
  )

; Is the first number greater than or equal to the second within epsilon
(defun e>= (n1 n2 &optional absolute)
  (or (e= n1 n2 absolute) (> n1 n2))
;  (>= n1 (- n2 epsilon))
  )

; Is the first number less than or equal to the second within epsilon
(defun e<= (n1 n2 &optional absolute)
  (or (e= n1 n2 absolute) (< n1 n2))
;  (<= n1 (+ n2 epsilon))
  )

; Is the first number greater than the second within epsilon
(defun e> (n1 n2)
  (> n1 n2)
;  (> n1 (+ n2 epsilon))
  )

; Is the first number less than the second within epsilon
(defun e< (n1 n2)
  (< n1 n2)
;  (< n1 (- n2 epsilon))
  )

; Is a region variable (any non-zero weight)
(defun region-is-variable (r)
  (notevery #'(lambda (d) (e= (dimension-weight d) 0)) (region-dimensions r))
  )

; Is a region constant (no non-zero weight)
(defun region-is-constant (r)
  (every #'(lambda (d) (e= (dimension-weight d) 0)) (region-dimensions r))
  )

; Are all the regions in a PLM constant
(defun plm-is-constant (p)
  (let ((rarray (plm-array p))
        (constant t))
    (dotimes (i (array-total-size rarray))
      (unless (region-is-constant (row-major-aref rarray i))
        (setq constant nil)
        (return constant)
        )
      )
    constant)
  )

; Is a region empty
(defun region-e-empty (r &optional piecewise-constant)
  (and (e= (region-constant r) 0) (not (region-exponential r))
       (or piecewise-constant
           (region-is-constant r)
           )
       )
  )

; Make region-empty
(defun empty-region (r)
  (let ((ds (region-dimensions r)))
    (setf (region-constant r) 0)
    (dotimes (d (length ds))
      (setf (dimension-weight (aref ds d)) 0)
      )
    r)
  )

; Is a region full
(defun region-e-full (r &optional piecewise-constant)
  (and (e= (region-constant r) 1)
       (or piecewise-constant
           (region-is-constant r)
           )
       )
  )

; Is a region uniform (constant >0)
(defun region-e-uniform (r &optional piecewise-constant)
  (and (e> (region-constant r) 0)
       (or piecewise-constant
           (region-is-constant r)
           )
       )
  )

; Is a dimension inactive?
(defun dimension-active (p d)
  (aref (plm-active p) d)
  )
(defun dimension-inactive (p d)
  (not (dimension-active p d)))

; Get constant weight from function
(defun function-constant (f)
  (aref f 0)
  )

; Is a region exhaustive (covering extent of PLM)?
(defun region-exhaustive (r p)
  (let ((exhaustive t)
        (ds (region-dimensions r))
        type
        )
    (dotimes (d (region-rank r))
      (setq type (svariable-type (aref (plm-variables p) d)))
      (unless (and (e= (dimension-min (aref ds d)) (stype-min type) t)
                   (e= (dimension-max (aref ds d)) (stype-max type) t))
        (setq exhaustive nil)
        (return nil)))
    exhaustive)
  )

; Is a PLM empty (one region that is a constant 0)
(defun plm-empty (p)
  (let ((oregion (plm-origin p)))
    (and (region-e-empty oregion (plm-piecewise-constant p)) ; The origin region is empty
         (= (plm-size p) 1) ; Only one region
        )
    )
  )

; Is a PLM full (one region that is a constant 1)
(defun plm-full (p)
  (let ((oregion (plm-origin p)))
    (and (region-e-full oregion (plm-piecewise-constant p)) ; The origin region is a constant 1
         (= (plm-size p) 1) ; Only one region
        )
    )
  )

; Is a PLM uniform (one region that is a constant >0)
(defun plm-uniform (p)
  (and (region-e-uniform (plm-origin p) (plm-piecewise-constant p)) ; The origin region is a constant 1
       (= (plm-size p) 1) ; Only one region
       )
  )


; Check if two slices are equal
(defun slices-e= (s1 s2 &optional arousal)
  (e= (slice-location s1) (slice-location s2) t arousal)
  )

; Check if two slice lists are equal
(defun slice-lists-e= (sl1 sl2 &optional arousal)
  (let ((sl-equal (= (length sl1) (length sl2))))
    (do ((sc1 sl1 (cdr sc1))
         (sc2 sl2 (cdr sc2)))
        ((null sc1))
      (unless (slices-e= (car sc1) (car sc2))
        (return (setq sl-equal nil))
        )
      )
    sl-equal)
  )

; Check if the slice vectors for two PLMs are the same lengths along all dimensions
; Assumes PLMs are of same rank
(defun slice-vectors-equal-length (sv1 sv2)  
(let ((lengths-equal t))
    (dotimes (d (length sv1))
      (unless (= (length (aref sv1 d)) (length (aref sv2 d)))
        (return (setq lengths-equal nil))
        )
      )
    lengths-equal)
  )

; Check if the slice vectors for two PLMs are the same lengths along all dimensions
; Assumes PLMs are of the same rank
(defun slice-vectors-e= (sv1 sv2 &optional arousal)
  (let ((sv-equal (slice-vectors-equal-length sv1 sv2)))
    (when sv-equal
      (dotimes (d (length sv1))
        (unless (slice-lists-e= (aref sv1 d) (aref sv2 d))
          (return (setq sv-equal nil))
          )
        )
      )
    sv-equal)
  )

; Are two regions e=
; Assumes regions' slices are in the same places
(defun region-e= (r1 r2 &optional arousal piecewise-constant)
  (and (e= (region-constant r1) (region-constant r2) nil arousal)
       (or piecewise-constant
           (let ((we t))
             (dotimes (d (region-rank r1) t)
               (unless (e= (region-weight r1 d) (region-weight r2 d) nil arousal)
                 (return (setq we nil))
                 )
               )
             we)
           )
       )
  )

; Are two PLMs e=
(defun plm-e= (p1 p2 &optional arousal)
    (if (= (plm-rank p1) (plm-rank p2))
        (let ((rarray1 (plm-array p1))
              (rarray2 (plm-array p2))
              (pc (and (plm-piecewise-constant p1) (plm-piecewise-constant p2)))
              (sv1 (plm-slices p1))
              (sv2 (plm-slices p2))
              )
          (and
           (slice-vectors-e= sv1 sv2) ; Check that all slices are in the same places
           (let ((equality t))
             (dotimes (i (array-total-size rarray1))
               (when (not (region-e= (row-major-aref rarray1 i) (row-major-aref rarray2 i) arousal pc))
                 (setq equality nil)
                 (return nil)
                 )
               )
             equality)
           )
          )
      nil)
    )

; -----------------------------------------------------------
; Region function functions

; Create a weight vector for a region function from the dimensions
; Put the constant in the 0 position and shift everything else over one.
; rank determines how big the weight vector should be
; Mapv is a map vector (or nil) that determines how the dimensions need to be realigned
(defun region-weights (r rank mapv &optional piecewise-constant)
  (if piecewise-constant
      (region-constant r)
    (let ((vf (init-vector (+ rank 1) 0))
          index
          (dims (region-dimensions r))
          )
      (setf (aref vf 0) (region-constant r))
      (dotimes (d (region-rank r))
        (setq index (if mapv
                        (aref mapv d)
                      d))
        (setf (aref vf (+ index 1)) (dimension-weight (aref dims d)))
        )
      vf))
  )

; Assign weights to a region function based on a vector
; The constant is in the 0th position and everything else is shifted from there
(defun assign-function (v r &optional piecewise-constant)
  (if piecewise-constant
      (setf (region-constant r) v)
    (let ((ds (region-dimensions r)))
      (setf (region-constant r) (aref v 0))
      (dotimes (d (region-rank r))
        (setf (dimension-weight (aref ds d)) (aref v (+ d 1)))
        )
      r)
    )
  )

; Extract a function from a region
(defun extract-function (r &optional piecewise-constant)
  (if piecewise-constant
      (region-constant r)
    (let* ((ds (region-dimensions r))
           (rank (region-rank r))
           (fn (init-vector (+ rank 1) 0))
           )
      (setf (aref fn 0) (region-constant r))
      (dotimes (d rank)
        (setf (aref fn (+ d 1)) (dimension-weight (aref ds d)))
        )
      fn)
    )
  )

; -----------------------------------------------------------
; Remove slices/hyperplanes from a PLM when they are no longer needed

; Determine if a hyperplane slices (intersects with) a region
(defun region-sliced (r d x)
  (and (e>= (slice-location x) (region-min r d) t) (< (slice-location x) (region-max r d))))

; Determine if a slice follows min of region
; Changed to check for the actual slice rather than location
(defun slice-at-region-min (r d x)
  (eq x (region-min-slice r d)))

; Determine if a slice follows max of region
(defun slice-at-region-max (r d x)
  (if (eq x (region-max-slice r d))
      t
      (if (e= (slice-location x) (slice-location (region-max-slice r d)) t)
          (error "Region boundary has same location as slice (~S), but is not the same slice." (slice-location x)) ; Regions should use PLM slices directly
        nil)
      )
  )

; Determine if a hyperplane borders a region
(defun slice-borders-region (r d x)
  (or (slice-at-region-min r d x) (slice-at-region-max r d x)))

; Determine if two sets (unordered lists) are equal, with specifiable equality test
(defun sets-equal (l1 l2 test)
  (and (= (length l1) (length l2))
       (dolist (i1 l1 t)
         (unless (member i1 l2 :test test)
           (return nil)
           )
         )
       )
  )

; Determine if two regions are equal in terms of not requiring a slice between them
(defun regions-equal (r1 r2)
  (function-equal r1 r2) ; Functions equal
  )

; Compute weighted average of two functions
(defun average-function (f1 s1 f2 s2)
  (let* ((s (+ s1 s2))
         (w1 (/ s1 s))
         (w2 (/ s2 s))
         (rank (length f1))
         (nf (init-vector rank))
         )
    (unless (= rank (length f2))
      (error "Functions ~S and ~S not of same length in average-function!" f1 f2)
      )
    (dotimes (i (length f1))
      (setf (aref nf i) (+ (* w1 (aref f1 i)) (* w2 (aref f2 i))))
      )
    nf)
  )

; Define exclusive or
(defun xor (a b)
  (not (eq a b))
  )

; Compute average of two region functions along dimension d
(defun average-region-functions (r1 r2 d)
  (average-function (extract-function r1) (region-span r1 d)
                    (extract-function r2) (region-span r2 d))
  )

; Determine if a slice is the extreme along a dimension in direction
(defun slice-is-extreme (loc sls compare)
  (dolist (sl sls t)
    (when (apply compare (list (slice-location sl) loc))
      (return nil)
      )
    )
  )

; Determine extreme slice
(defun extreme-slice (sls compare)
  (let ((extreme (car sls)))
    (dolist (sl (cdr sls))
      (when (apply compare (list (slice-location sl) (slice-location extreme)))
        (setq extreme sl)
        )
      )
    extreme)
  )

; Remove unneeded slices from slice lists
; Copies slice lists but not slices
(defun remove-unneeded-slices-from-list (slices needed)
  (let* ((rank (length slices))
         (nslices (init-vector rank))
         ns i nd
         )
    (dotimes (d rank)
      (setq ns nil)
      (setq i 0)
      (setq nd (aref needed d))
      (dolist (s (aref slices d))
        (when (aref nd i)
          (push s ns)
          )
        (setq i (1+ i))
        )
      (setf (aref nslices d) (reverse ns))
      )
    nslices)
  )

; Return index vector for original region array from index vector from reduced (unneeded slices removed) region array
; Assumes new slice list array is already sorted
(defun original-from-new-index (nv nslices)
  (let* ((rank (length nv))
         (ov (init-vector rank))
         nsl ; Slice list
         )
    (dotimes (d rank)
      (setq nsl (aref nslices d))
      (setf (aref ov d) (slice-index (nth (aref nv d) nsl)))
      )
    ov)
  )

; Copy a vector of dimensions, but without links to neighboring regions
(defun copy-dimensions (ds)
  (let* ((rank (length ds))
         (nds (init-vector rank))
         )
    (dotimes (i rank)
      (setf (aref nds i) (copy-dimension (aref ds i)))
      )
    nds)
  )

; Copy a region without the links, but without links to neighboring regions
(defun copy-a-region (r)
  (make-region :constant (region-constant r)
               :dimensions (copy-dimensions (region-dimensions r))
               :maximals (copy-seq (region-maximals r))
               :evidence (region-evidence r)
               :exponential (region-exponential r)
               )
  )

; Row major index for region before (based on region's index vector) along dimension number d
(defun rmi-before-ri (iv d mults)
  (if (zerop (aref iv d))
      nil
    (- (row-major-index iv mults) (aref mults d)))
  )

; Row major index for region after (based on region's index vector) along dimension number d
(defun rmi-after-ri (iv d mults sizev)
  (if (= (aref iv d) (1- (aref sizev d)))
      nil
    (+ (row-major-index iv mults) (aref mults d)))
  )

; Update of an index vector for region after, along a dimension
(defun region-after-index-vector (iv d size-1)
  (let ((i (aref iv d)))
    (if (= i size-1)
        nil
      (progn
        (setf (aref iv d) (1+ i))
        iv))
    )
  )

; Update of an index list for region after, along a dimension
(defun region-after-index-list (il d size-1)
  (let ((i (nth d il)))
    (if (= i size-1)
        nil
      (progn
        (setf (nth d il) (1+ i))
        il))
    )
  )

; Update of an index list for region before, along a dimension
; Assumes that the region isn't at beginning of dimension d
(defun region-before-index-list-x (il d)
  (setf (nth d il) (1- (nth d il)))
  il
  )

; Update of an index list for region after, along a dimension
; Assumes that the region isn't at end of dimension d
(defun region-after-index-list-x (il d)
  (setf (nth d il) (1+ (nth d il)))
  il
  )

; Update of an index list for next region in row-major order
(defun next-index-list (il sizev-1 rank)
  (if (= rank 0)
      nil
    (let* ((rank-1 (1- rank))
           r-1-j ; rank - (j + 1)
           locl ; List starting at location
           )
      (dotimes (j rank) ; Cycle through all dimensions of index list
        (setq r-1-j (- rank-1 j)) ; Proceed from right rather than left
        (setq locl (nthcdr r-1-j il))
        (if (< (car locl) (aref sizev-1 r-1-j)) ; If index at position is in bounds
            (return) ; Done generating vector index for this row-major index
          (rplaca locl 0)) ; Else, zero index at position and move on to next index position
        )
      (rplaca locl (1+ (car locl))) ; Increment index at position
      il))
  )

; Update of an index list for next region in row-major order, skipping dimension d
(defun next-index-list-no-d (il sizev-1 rank d)
  (if (< rank 2) ; Only a next index if there are at least two dimensions of the original array
      nil
    (let* ((rank-1 (1- rank))
           r-1-j ; rank - (j + 1)
           locl ; Index list starting at location
           )
      (dotimes (j rank) ; Cycle through all dimensions of index list
          (setq r-1-j (- rank-1 j)) ; Proceed from right rather than left
          (unless (= r-1-j d)
            (setq locl (nthcdr r-1-j il))
            (if (< (car locl) (aref sizev-1 r-1-j)) ; If index at position is in bounds
                (return) ; Done generating vector index for this row-major index
              (rplaca locl 0)) ; Else, zero index at position and move on to next index position
            )
          )
      (rplaca locl (1+ (car locl))) ; Increment index at position
      il))
  )

; Update of an index vector for next region in row-major order
(defun next-index-vector (iv sizev-1 rank)
  (if (= rank 0)
      nil
    (let* ((rank-1 (1- rank))
           r-1-j ; rank - (j + 1)
           )
      (dotimes (j rank) ; Cycle through all dimensions of index list
        (setq r-1-j (- rank-1 j)) ; Proceed from right rather than left
        (if (< (aref iv r-1-j) (aref sizev-1 r-1-j)) ; If index at position is in bounds
            (return) ; Done generating vector index for this row-major index
          (setf (aref iv r-1-j) 0)) ; Else, zero index at position and move on to next index position
        )
      (setf (aref iv r-1-j) (1+ (aref iv r-1-j))) ; Increment index at position
      iv))
  )

; Find indices of a regions min-slices
(defun region-index-mins (r)
  (let* ((rank (region-rank r))
         (ims (init-vector rank)))
    (dotimes (i rank)
      (setf (aref ims i) (slice-index (region-min-slice r i)))
      )
    ims)
  )

; Similar to old form of region after
(defun region-after-old (r d rarray)
  (let* ((s (region-max-slice r d))
         (rmins (region-index-mins r)))
    (if s
        (progn
          (unless (slice-index s)
            (error "Attempt to find region after region via unidexed slice: ~S" s)
            )
          (setf (aref rmins d) (slice-index s))
          (element-from-index-vector rarray rmins)
          )
      nil)
    )
  )

; Create an initial vector of vectors for needed slices
(defun init-needed-vector (rank sizev value)
  (let ((needed (init-vector rank)) ; Vector of vectors for the needed slices
        nv ; One subvector of needed
        )
    ; Initialize needed vector of vectors to track which slices are needed
    (dotimes (d rank)
      (setq nv (init-vector (1+ (aref sizev d)) value)) ; There is one more slice per dimension than region
      ; Mark that extreme slices along each dimension are needed
      (setf (aref nv 0) t)
      (setf (aref nv (aref sizev d)) t)
      (setf (aref needed d) nv)
      )
    needed)
  )

; Determine if one slice is needed
(defun slice-needed (rarray si d rank size-d sizev-1)
  (let (ii
        needed
        r ; Current region
        )
    (setq ii (make-list rank :initial-element 0))
    (setf (nth d ii) si)
    (dotimes (i size-d)
      (setq r (apply #'aref rarray ii))
      (unless (function-equal r (apply #'aref rarray (region-before-index-list-x ii d))) ; Destructively modifies ii
        (return (setq needed t))
        )
      (setq ii (next-index-list-no-d (region-after-index-list-x ii d) sizev-1 rank d))
      )
    needed)
  )

; Determine which slices are needed (one at a time)
(defun slices-needed-by-slice (p rank sizev)
  (let* ((slices (plm-slices p))
         (needed (init-needed-vector rank sizev nil)) ; Vector of vectors for the needed slices
         needed-d ; Vector for the needed slices in dimension d
         (rarray (plm-array p))
         (size (array-total-size rarray))
         sizev-d ; Size of dimension d
         (sizev-1 (vector-1 sizev))
         si ; Slice index
         )
    (dotimes (d rank)
      (setf needed-d (aref needed d))
      (setq sizev-d (aref sizev d))
      (dolist (sl (cdr (aref slices d))) ; Check all but extreme slices (start after zeroth slice)
        (setq si (slice-index sl))
        (unless (aref needed-d si) ; Ignore maximum slice, which is already needed
          (setf (aref needed-d si) (slice-needed rarray si d rank (/ size sizev-d) sizev-1))
          )
        )
      )
    needed)
  )

; Determine which slices are needed in a PLM
(defun slices-needed (p rank sizev mults &optional absolute)
  (let* ((rarray (plm-array p))
         (size (array-total-size rarray))
         (needed (init-needed-vector rank sizev nil)) ; Vector of vectors for the needed slices
         (sizev-1 (vector-1 sizev))
         r ; region
         pr ; prior region
         ri ; index vector
         si ; slice index
         bi ; index of previous region along d
         dneed ; Vector for slice needs along dimension d
         )
    ; Determine which slices are needed
    (setq ri (init-vector rank 0))
    (dotimes (i size)
      (setq r (row-major-aref rarray i))
      (dotimes (d rank)
        (setq dneed (aref needed d))
        (setq si (slice-index (region-min-slice r d)))
        (unless (aref dneed si) ; Skip comparison if know slice is already needed
          (setq bi (rmi-before-ri ri d mults))
          (setq pr (if bi (row-major-aref rarray bi) nil))
          (unless (and pr ; There is a prior region along dimension
                       (function-equal r pr absolute) ; Regions have same function
                       )
            (setf (aref dneed si) t)
            )
          )
        )
      (setq ri (next-index-vector ri sizev-1 rank))
      )
    needed)
  )

; Determine if all of the slices are needed
(defun all-needed (needed)
  (reduce #'(lambda (a b) (and a b)) (map 'vector #'(lambda (x) (reduce #'(lambda (a b) (and a b)) x)) needed))
  )

; Non-destructively eliminate hyperplane slices through a PLM that are no longer needed
; If needed is provided it is a vector of Boolean vectors true when slice is needed
; If combine is non-null, new region is that type of combination of the old pair along dimension d
; Absolute uses absolute comparisons rather than relative comparisons of region functions
(defun remove-unneeded-slices (p &optional needed combine d absolute)
  (if (zerop (plm-rank p))
      p
    (let* ((rank (plm-rank p))
           (rarray (plm-array p))
           r ; region
           (slices (plm-slices p))
           (sizev (dimension-sizes-v p))
           (mults (dimension-multipliers sizev)) ; Dimension multipliers for row major index
           np
           nslices nsizev nsizev-1 nrarray ; Equivalent variables for result array
           niv ; One index for new array
           nr ; New region
           nd ; New dimension
           nsl ; One slice list for new array
           original-fni ; Original index from new index
           original-fni-list
           (needed-d (when d (aref needed d))) ; Needed slice vector along d when it exists 
           )
      (sort-slice-list-array slices)
      (index-slice-list-array slices)
      (unless needed
        (setq needed (slices-needed p rank sizev mults absolute))
        )
      (if (plm-removed-unneeded-slices p)
          p
        (if (all-needed needed)
          (progn
            (setf (plm-removed-unneeded-slices p) t)
            p
            )
          (progn
            (setq np (make-plm :rank rank
                               :active (init-vector rank t)
                               :variables (copy-seq (plm-variables p))))
            (setq nslices (remove-unneeded-slices-from-list slices needed))
            (setq nsizev (dimension-sizes-from-slices nslices))
            (setq nsizev-1 (vector-1 nsizev))
            (setq nrarray (make-region-array (coerce nsizev 'list)))
            (setq niv (init-vector rank 0))
            (dotimes (i (array-total-size nrarray))
              (setq original-fni (original-from-new-index niv nslices))
              (setq original-fni-list (coerce original-fni 'list))
              (setq r (apply #'aref rarray original-fni-list))
              (setq nr (copy-a-region r))
              (setf (row-major-aref nrarray i) nr)
              ; Update min and max slices along each dimension
              (dotimes (j rank)
                (setq nd (aref (region-dimensions nr) j))
                (setq nsl (aref nslices j))
                (setf (dimension-min-slice nd) (nth (aref niv j) nsl))
                (setf (dimension-max-slice nd) (nth (1+ (aref niv j)) nsl)); If function already normalized, get exponentials of 0-10
                )
              (when (eq combine 'average)
                (if (and d (not (aref needed-d (+ (aref original-fni d) 1))))
                    (assign-function (average-region-functions r (row-major-aref rarray (rmi-after-ri original-fni d mults sizev)) d) nr)
                  (assign-function (average-regions-in-span nr p (dimension-sizes-v p) original-fni-list) nr))
                )
              (setq niv (next-index-vector niv nsizev-1 rank))
              )
            (setf (plm-array np) nrarray)
            (index-slice-list-array nslices)
            (setf (plm-slices np) nslices)
            (setf (plm-removed-unneeded-slices np) t)
            (when (plm-piecewise-constant p)
              (setf (plm-piecewise-constant np) t)
              )
            np)))
      ))
  )

; -----------------------------------------------------------
; Revise regions along dimension so that the function is again discrete
; Must add and remove slices as appropriate.

; Determine whether number is within epsilon of an integer
(defun eintegerp (n)
  (or (e= (if center-discrete-numeric-on-integer (+ n 1/2) n) (floor n) t)
      (e= (if center-discrete-numeric-on-integer (+ n 1/2) n) (ceiling n) t)
      )
  )

(defun discretize-dimension (p d)
  (let* ((slices (aref (plm-slices p) d))
         sizev
         sl fsl csl
         (rank (plm-rank p))
         needed ; Slices needed
         needed-d ; Slices needed along dimension d
         (new-slices (init-vector rank))
         ns
        )
    ; Add slices at the integers before and after slice location if not an integer
    (dolist (s slices)
      (setq sl (slice-location s))
      (when center-discrete-numeric-on-integer
        (setq sl (+ sl 1/2))
        )
      (setq fsl (floor sl))
      (setq csl (ceiling sl))
      ; Add slice at higher integer if not an integer and already there
      (unless (e= sl csl t)
        (setq ns (cons (make-slice :location (if center-discrete-numeric-on-integer (- csl 1/2) csl)) ns))
        )
      ; Add slice at lower integer if not an integer and not already there
      (unless (e= sl fsl t)
        (setq ns (cons (make-slice :location (if center-discrete-numeric-on-integer (- fsl 1/2) fsl)) ns))
        )
      )
    (setq ns (sort-slice-list ns))
    (setq ns (delete-duplicates-slice-list ns))
    (index-slice-list ns) ; Index the slices
    (setf (aref new-slices d) ns)
    (setq p (apply-slices new-slices nil p))
    ; Remove non-integral slices, averaging the functions on either side
    (setq sizev (dimension-sizes-v p))
    (setq needed (init-needed-vector rank sizev t))
    (setq needed-d (aref needed d))
    (setq slices (aref (plm-slices p) d))
    (dolist (s slices)
      (unless (eintegerp (slice-location s))
        (setf (aref needed-d (slice-index s)) nil)
        )
      )
    (remove-unneeded-slices p needed 'average d))
  )

; -----------------------------------------------------------
; Update a PLM based on a new region function
; Use the region to factor a PLM along all boundaries of the region
; Then update appropriate regions of PLM based on the function in the region

; Factor PLM by the min and max of each dimension of the update region
(defun factor-plm-by-dimensions (p ds)
  (let (type
        (new-slices (init-vector (plm-rank p))))
    (dotimes (d (length ds))
      (setq type (svariable-type (aref (plm-variables p) d)))
      (when (e> (dimension-min (aref ds d)) (stype-min type))
        (setf (aref new-slices d) (cons (dimension-min-slice (aref ds d)) (aref new-slices d)))
        )
      (when (e< (dimension-max (aref ds d)) (stype-max type))
        (setf (aref new-slices d) (cons (dimension-max-slice (aref ds d)) (aref new-slices d)))
        )
      )
    (sort-slice-list-array new-slices)
    (setq p (apply-slices new-slices nil p))
    p) ; Returned just to help when tracing
  )

; Return region from array given a vector of indices
(defun element-from-index-vector (array indices)
  (let ((il (coerce indices 'list)))
    (if (apply #'array-in-bounds-p array il)
        (apply #'aref array il)
      nil)
    )
  )

; recur on update-regions-in-span
(defun update-regions-in-span-recur (ur rarray i sizev starting-indices rank)
  (cond ((< i rank)
         (let ((sis (copy-seq starting-indices)))
           (do ((si sis (region-after-index-list si i (1- (aref sizev i))))) ; Destructive
               ((or (null si) (e> (region-max (apply #'aref rarray si) i) (region-max ur i))) nil)
             (update-regions-in-span-recur ur rarray (1+ i) sizev si rank)
             )
           )
         )
        ((= i rank)
         (let ((r (apply #'aref rarray starting-indices)))
           (when (within-region r nil ur)
             (copy-function ur r)
             (setf (region-evidence r) (region-evidence ur))
             )
           )
         )
        )         
  )

; Update PLM regions within span of update region
(defun update-regions-in-span (ur p sizev starting-indices)
  (update-regions-in-span-recur ur (plm-array p) 0 sizev starting-indices (plm-rank p))
  p)


; Find a slice in a vector at a location, if there is one
(defun find-slice-at-location-v (loc si sv)
  (dotimes (s (- (length sv) si))
    (when (e= loc (slice-location (aref sv (+ si s))) t)
      (return (+ si s))
      )
    )
  )

; Find the index for the slice based on its value and a starting point
; If provided, start at slice index in searching
(defun find-slice-index-v (loc si sv)
  (let ((s (find-slice-at-location-v loc si sv)))
    (if s s nil)
    )
  )

; Find a slice in a list at a location, if there is one
(defun find-slice-at-location (loc sl)
  (dolist (s sl)
    (when (e= loc (slice-location s) t)
      (return s)
      )
    )
  )

; Find the index for the slice based on its value
(defun find-slice-index (loc sl)
  (let ((s (find-slice-at-location loc sl)))
    (if s
        (slice-index s)
      nil)
    )
  )

; Find index of a region of a PLM according to its minimum slices
; If provided, use slices provided rather than those in PLM (to be able to start search part way through)
(defun find-region-index (p mins &optional slices)
  (let* ((slices (if slices slices (plm-slices p)))
        (region-index (make-list (length mins))) ; List of slice indices for region
        (ric region-index))
    (dotimes (d (plm-rank p))
      (rplaca ric (find-slice-index (aref mins d) (aref slices d)))
      (setq ric (cdr ric))
      )
    region-index)
  )

; Find a slice in a list that is largest that is <= than specified slice location, if there is one
(defun find-region-slice-at-location (loc sl)
  (let ((last-s (car sl)))
    (setq sl (cdr sl))
    (if (e< loc (slice-location last-s)) ; Loc is prior to whole dimension
        nil
      (dolist (s sl)
        (when (e< loc (slice-location s))
          (return last-s)
          )
        (setq last-s s)
        )
      )
    )
  )

; Find the index of a slice in a list that is largest that is <= than specified slice location
(defun find-region-slice-index (loc sl)
  (let ((s (find-region-slice-at-location loc sl)))
    (if s
        (slice-index s)
      nil)
    )
  )

; Error if region has a universal dimension with a weight
(defun check-universal-dimension-weights (r p)
  (dotimes (d (region-rank r))
    (when (and (multiple-variable (aref (plm-variables p) d))
               (not (e= (dimension-weight (aref (region-dimensions r) d)) 0))
               )
      (format trace-stream "~&Attempt to assign a non-zero weight to a universal dimension via region ")
      (print-region r p)
      (format trace-stream "for PLM ")
      (pplm p)
      (error "")
      )
    )
  )

; Update the function for a region of a PLM
; First factor the PLM along every boundary of region
; Then update those regions of the PLM that are within the update region
; Every PLM region should be completely within or without the update region
(defun update-region (r p &optional pred-name leave-unneeded-slices)
  (let ((pc (plm-piecewise-constant p)))
    (when (and trace-wm-changes
               (or (atom trace-wm-changes) (member pred-name trace-wm-changes))
               )
      (let (te)
        (setq te trace-empty)
        (setq trace-empty t)
        (format trace-stream "~&Updating region ")
        (print-region r p symbolic-trace trace-stream)
        (if (plm-empty p)
            (format trace-stream "of empty PLM")
          (format trace-stream "of PLM "))
        (setq trace-empty te)
        (print-plm p symbolic-trace trace-stream)
        )
      )
    (when unique-weights-only
      (check-universal-dimension-weights r p)
      )
    (setq p (factor-plm-by-dimensions p (region-dimensions r)))
    (setq p (update-regions-in-span r p (dimension-sizes-v p) (find-region-index p (region-mins-0 r))))
    (when (and trace-wm-changes
               (or (atom trace-wm-changes) (member pred-name trace-wm-changes))
               )
      (format trace-stream "~&Result region update: ")
      (print-plm p symbolic-trace trace-stream)
      )
    (when (and pc (region-is-constant r))
      (setf (plm-piecewise-constant p) t)
      )
    (unless leave-unneeded-slices
      (setq p (remove-unneeded-slices p))
      )
    p)
  )

; -----------------------------------------------------------
; Various operations on slices, including applying them

; Merge two lists of sorted slices, keeping sorted and indexing
(defun merge-slice-lists (sl1 sl2)
  (let (nsl s1 s2
        (ni 0) ; Index for position in the nsl list
        )
    (loop
     (cond ((and sl1 sl2) ; Slices left in both sl1 and sl2
            (setq s1 (slice-location (car sl1)))
            (setq s2 (slice-location (car sl2)))
            (cond ((e= s1 s2 t)
                   (setq nsl (cons (make-slice :location s1 :index ni) nsl))
                   (setq sl1 (cdr sl1))
                   (setq sl2 (cdr sl2))
                   )
                  ((e< s1 s2)
                   (setq nsl (cons (make-slice :location s1 :index ni) nsl))
                   (setq sl1 (cdr sl1))
                   )
                  (t
                   (setq nsl (cons (make-slice :location s2 :index ni) nsl))
                   (setq sl2 (cdr sl2))
                   )
                  )
            )
           (sl1 ; No slices left in sl2
             (setq nsl (cons (make-slice :location (slice-location (car sl1)) :index ni) nsl))
             (setq sl1 (cdr sl1))
             )
           (sl2 ; No slices left in sl1
             (setq nsl (cons (make-slice :location (slice-location (car sl2)) :index ni) nsl))
             (setq sl2 (cdr sl2))
             )
           (t (return)) ; No slices left in either list
           )
     (setq ni (1+ ni))
     )
    (nreverse nsl))
  )

; Merge two (sorted) vectors of slice lists yielding a sorted and indexed result
; The two inputs can be of different lengths, but the dimensions of the first must all
; be included in the second, with the map specifying the relationship
(defun merge-slice-vectors (sv1 map sv2)
  (let* ((size1 (length sv1))
         (size2 (length sv2))
         (nsv (init-vector size2))
        mapv
        d
        )
    (when map
      (setq mapv (smap-vfactor map))
      )
    ; Process dimensions that are in both vectors
    (dotimes (i size1)
      (setq d (if mapv (aref mapv i) i))
      (setf (aref nsv d) (merge-slice-lists (aref sv1 i) (aref sv2 d)))
      )
    ; Process dimensions only in second vector
    (dotimes (d size2)
      (unless (aref nsv d)
        (setf (aref nsv d) (copy-slice-list (aref sv2 d)))
        )
      )
    nsv)
  )

; Given two lists of (sorted indexed) slices, create a vector that gives the slice index in the
; first list for every index in the second list
(defun cross-index-slice-lists (sl1 sl2)
  (let* ((size2 (length sl2))
         (xi (init-vector size2)) ; Indices
         (previous-index -1)
         )
    (unless (reduce #'(lambda (a b) (and a b)) sl1 :key #'slice-index)
      (error "Can't cross-index a slice list with NIL indices: ~S" sl1)
      )
    (loop
     (when (not sl2) (return))
     (cond ((not sl1)
            (setf (aref xi (slice-index (car sl2))) -1)
            (setq sl2 (cdr sl2))
            )
           ((e= (slice-location (car sl2)) (slice-location (car sl1)) t)
            (setf (aref xi (slice-index (car sl2))) (slice-index (car sl1)))
            (setq previous-index (slice-index (car sl1)))
            (setq sl1 (cdr sl1))
            (setq sl2 (cdr sl2))
            )
           ((e< (slice-location (car sl2)) (slice-location (car sl1)))
            (setf (aref xi (slice-index (car sl2))) previous-index)
            (setq sl2 (cdr sl2))
            )
           (t ; e>
            (setq sl1 (cdr sl1))
            (setq previous-index (1+ previous-index))
            )
           )
     )
    xi)
  )

; Given two vectors of lists of (sorted indexed) slices, create a vector of vectors that for each pair of lists gives the
; slice index in the first list for every index in the second list
; Only creates entries for dimensions in both vectors
(defun cross-index-slice-vector (sv1 map sv2)
  (let* ((size1 (length sv1))
         (size2 (length sv2))
         (xiv (init-vector size2))
         (mapv (if map (smap-vfactor map) nil))
         mapd
         )
    (dotimes (d size1)
      (setq mapd (if mapv (aref mapv d) d))
      (setf (aref xiv mapd) (cross-index-slice-lists (aref sv1 d) (aref sv2 mapd)))
      )
    xiv)
  )

; Index list from cross-index
; iv is the index vector and ci is the cross-index
(defun index-list-from-cross-index (iv ci map)
  (if map ; Generate an index list appropriate to size and mapping
      (let* ((mapv (smap-vfactor map))
             (rank (length mapv))
             (civ (init-vector rank))
             mapd)
        (dotimes (d rank)
          (setq mapd (if mapv (aref mapv d) d))
          (setf (aref civ d) (aref (aref ci mapd) (aref iv mapd)))
          )
        (coerce civ 'list)
        )
    (let (cil)
      (dotimes (d (length iv))
        (setq cil (cons (aref (aref ci d) (aref iv d)) cil))
        )
      (nreverse cil)))
  )

; Index list from cross-index
; il is the index list and ci is the cross-index
(defun index-list-from-cross-index-list (il ci map)
  (if map ; Generate an index list appropriate to size and mapping
      (let* ((mapv (smap-vfactor map))
             (rank (length mapv))
             (civ (init-vector rank))
             mapd)
        (dotimes (d rank)
          (setq mapd (if mapv (aref mapv d) d))
          (setf (aref civ d) (aref (aref ci mapd) (nth mapd il)))
          )
        (coerce civ 'list)
        )
    (let (cil)
      (dotimes (d (length il))
        (setq cil (cons (aref (aref ci d) (car il)) cil))
        (setq il (cdr il))
        )
      (nreverse cil)))
  )

; Determine if there is a region in an array (given by list of dimension sizes) at specified index list
; There only shouldn't be when region index is from an affine transform that requires padding
(defun no-corresponding-region (ci ds)
  (reduce #'(lambda (a b) (or a b)) (map 'list #'>= ci ds))
  )

; Apply a slice array to a PLM
; s is a vector (one element for each dimension) of lists (one element for each slice)
; map determines how s dimensions map onto p dimensions
; p is a plm
; If svars is provided, it is the variables that go with the dimensions of s
(defun apply-slices (s map p &optional region-pad)
  (let* ((ps (plm-slices p))
         (rank (length ps))
         np ; New PLM
         nps ; Slices for np
         civ ; Slice cross-index vector
         (rarray (plm-array p))
         nrarray
         iv ; Index vector
         sizev-1
         cross-index ; Index vector for region in p corresponding to region in np
         )
    (setq nps (merge-slice-vectors s map ps))
    (cond ((slice-vectors-equal-length ps nps) ; Just use original function as no new slices were added
           p)
          (t
           (setq np (init-plm-with-slices (copy-seq (plm-variables p)) 0 0 (copy-seq (plm-active p)) nps))
           (setq nrarray (plm-array np))
           (setq civ (cross-index-slice-vector ps nil nps))
           (setq sizev-1 (vector-1 (array-dimensions-v nrarray)))
           (setq iv (init-vector rank 0))
           (dotimes (i (array-total-size nrarray))
             (setq cross-index (index-list-from-cross-index iv civ nil))
             (if (or (member -1 cross-index) (no-corresponding-region cross-index (array-dimensions rarray))) ; I'm not sure I understand this at this point
                 (setf (region-constant (row-major-aref nrarray i)) region-pad) ; Pad
               (copy-region-contents (apply #'aref rarray cross-index) (row-major-aref nrarray i))) ; Copy
             (setq iv (next-index-vector iv sizev-1 rank))
             )
           (when (plm-piecewise-constant p)
             (setf (plm-piecewise-constant np) t)
             )
           np)
          ))
  )

; Just factor plm along one slice
(defun factor-plm (p d x &optional region-pad)
  (let ((slices (init-vector (plm-rank p))))
    (setf (aref slices d) (list x))
    (apply-slices slices nil p region-pad)
    )
  )

; -----------------------------------------------------------
; Compute the pointwise combination of two PLMs
; Normally this would be a pointwise product for summary product,
; but sum is used in combining the effects of actions in deciding what changes to make to WM
; The product computation for regions was adapted from mhetree4.lisp
; Possibly could be optimized better for PLMs.

; Compute value of a linear function (as a vector of weights) at a point (as a vector)
(defun linear-value (function point)
  (let ((value 0))
    (dotimes (d (length function) value)
      (setq value (+ value (* (aref function d) (aref point d))))
      )
    value)
  )

; Compute value of an exponential function (as a vector of weights) at a point (as a vector)
(defun exponential-value (function point)
  (let ((value 0))
    (dotimes (d (length function) value)
      (setq value (+ value (* (aref function d) (aref point d))))
      )
    (exp value))
  )


; Compute outer product of two vectors
(defun outer-product (v1 v2)
  (let* ((r1 (length v1))
         (r2 (length v2))
         (op (make-array (list r1 r2)))
         )
    (dotimes (i1 r1)
      (dotimes (i2 r2)
        (setf (aref op i1 i2) (* (aref v1 i1) (aref v2 i2)))))
    op)
  )

; Given a product of two linear functions as an outer product,
; compute the value of the polynomial at a point
(defun quadratic-value (function point)
  (let ((value 0)
        (dimension (array-dimension function 0))
        )
    (dotimes (i dimension)
      (dotimes (j dimension)
        (setq value (+ value
                       (* (aref function i j)
                          (aref point i)
                          (aref point j))))
        )
      )
    value)
  )

; Compute linear slope approximation for a quadratic function along one dimension at a point.
; Essentialy computes the slope function by differentiation of the function
; with respect to variable d and then evaluates that function at point.
; The first element of the point vector should always be 1 (for product with the constant),
; and the others are point within a region for the corresponding variables.
; wps is a 2D weight array for the products of the weights of two linear functions.
; Every cell for d is counted horizontally and vertically
(defun linear-slope (wps d point)
  (let ((slope 0))
    (dotimes (i (array-dimension wps 0))
      (setq slope (+ slope (* (aref wps d i) (aref point i)))))
    (dotimes (i (array-dimension wps 1))
      (setq slope (+ slope (* (aref wps i d) (aref point i)))))
    slope)
  )

; Compute the mean of the arguments
(defun mean (&rest args)
  (/ (apply #'+ args) (length args)))

; Determine the minimum point in an n dimensional region
; Values start at 0 in the vector
(defun region-mins-0 (r)
  (let* ((rank (region-rank r))
         (ds (region-dimensions r))
         (vmin (init-vector rank))
        )
    (dotimes (d rank)
      (setf (aref vmin d) (dimension-min (aref ds d)))
      )
    vmin)
  )

; Determine the minimum point in an n dimensional region
; Values start at 1 in the vector, with the 0 element being 1 (for constant)
(defun region-mins (r)
  (let* ((rank (region-rank r))
         (ds (region-dimensions r))
         (vmin (init-vector (+ rank 1)))
        )
    (setf (aref vmin 0) 1)
    (dotimes (d rank)
      (setf (aref vmin (+ d 1)) (dimension-min (aref ds d)))
      )
    vmin)
  )

; Determine the maximum point in an n dimensional region
; Values start at 1 in the vector, with the 0 element being 1 (for constant)
(defun region-maxs (r)
  (let* ((rank (region-rank r))
         (ds (region-dimensions r))
         (vmax (init-vector (+ rank 1)))
        )
    (setf (aref vmax 0) 1)
    (dotimes (d rank)
      (setf (aref vmax (+ d 1)) (dimension-max (aref ds d)))
      )
    vmax)
  )

; Determine the midpoint in an n dimensional region
; Values start at 1 in the vector, with the 0 element being 1 (for constant)
(defun region-mids (r)
  (let* ((rmins (region-mins r))
         (rmaxs (region-maxs r))
         (rank (+ (region-rank r) 1))
         (vmid (init-vector rank)))
    (dotimes (d rank)
      (setf (aref vmid d) (/ (+ (aref rmaxs d) (aref rmins d)) 2)))
    vmid)
  )

; Compute a slope approximation by averaging the slopes derived at min, mid and amx
(defun slope-approximation-points (wps mins mids maxs d)
  (mean (linear-slope wps d mins)
        (linear-slope wps d mids)
        (linear-slope wps d maxs)))

; Compute the error/difference between quadratic function and linear approximation at a point
(defun approximation-error (wps wv point)
  (- (quadratic-value wps point)
     (linear-value wv point)))

; Compute a constant approximation by averaging over constants at min, mid and max
(defun constant-approximation-points (wps wv mins mids maxs)
  (mean (approximation-error wps wv mins)
        (approximation-error wps wv mids)
        (approximation-error wps wv maxs)))

; Take (approximate) max of two functions over a region
; Approximate by choosing function which is max at center point of region
; Return T if first is greater (rather than returning actual function)
(defun first-max-region-functions (f1 f2 r)
  (let ((mp (region-mids r)))
    (> (linear-value f1 mp) (linear-value f2 mp))
    )
  )

; Take max of two functions at a point (usually midpoint)
; Return T if first is greater (rather than returning actual function)
(defun first-max-functions (f1 f2 pt)
  (> (linear-value f1 pt) (linear-value f2 pt))
  )

; Multiply two linear functions, generating a new linear approximation of the result
; pc1 and pc2 are whether respective functions are constant
(defun product-functions (f1 f2 rank rnew &optional pc1 pc2)
  (let ((wv) ;0th element is the constant
        wps)
    (if pc1
        (if pc2 ; Both functions are constant
            (if (or (zerop f1) (zerop f2)) ; One of the functions is 0
                (setq wv 0)
              (if (= f1 1)
                  (setq wv f2)
                (if (= f2 1)
                    (setq wv f1)
                  (setq wv (* f1 f2)))))
          (if (zerop f1)
              (setq wv (init-vector (+ rank 1) 0)) ; 0 vector
            (if (= f1 1)
                (setq wv (copy-seq f2)) ; Copy second function
              (setq wv (scale-function f2 nil f1))))) ; First function a constant not 0 or 1, and second is variable
      (if pc2
          (if (zerop f2)
              (setq wv (init-vector (+ rank 1) 0)) ; 0 vector
            (if (= f2 1)
                (setq wv (copy-seq f1)) ; Copy second function
              (setq wv (scale-function f1 nil f2)))) ; Second function a constant not 0 or 1, and first is variable
        (let ((mins (region-mins rnew)) ; Neither function is constant
              (mids (region-mids rnew))
              (maxs (region-maxs rnew)))
          (setf wv (init-vector (+ rank 1) 0)) ; Initialize 0 vector
          ; Multiply two linear functions to achieve a quadratic function via outer product
          (setq wps (outer-product f1 f2))
          ; Compute slopes for the variables
          (dotimes (d rank)
            (setf (aref wv (+ d 1)) (slope-approximation-points wps mins mids maxs (+ d 1)))
            )
          ; Compute constant
          (setf (aref wv 0) 0) ; Baseline for computing constant
          (setf (aref wv 0) (constant-approximation-points wps wv mins mids maxs))
          )))
    wv)
  )

; Max of two linear functions

(defun max-functions (f1 f2 rnew &optional piecewise-constant)
  (if piecewise-constant
      (if (> f1 f2) f1 f2)
    (if (first-max-functions f1 f2 (region-mids rnew)) f1 f2))
  )

; Probabilistic OR (assuming independence) of two regions with linear functions
; pc1 and pc2 are whether respective functions are constant
(defun por-functions (f1 f2 rank rnew &optional piecewise-constant)
  (let ((sum-f (vector-sum f1 f2 piecewise-constant))
        (product-f (product-functions f1 f2 rank rnew piecewise-constant piecewise-constant))
        )
    (vector-difference sum-f product-f piecewise-constant))
  )

; Divide first function by constant in second
; Doesn't currently handle full functions in second
(defun divide-functions (f1 f2 &optional piecewise-constant)
  (vector-divide f1 (if piecewise-constant f2 (aref f2 0)) piecewise-constant)
  )

; Divide first function by constant in second
; Doesn't currently handle full functions in second
; If second function is 0, returns 0
(defun divide-0-functions (f1 f2 &optional piecewise-constant)
  (vector-divide-0 f1 (if piecewise-constant f2 (aref f2 0)) piecewise-constant)
  )

; Scale GDL increment
; If value of first function is greater than max-gdl-increment, divide by max and multiply by max-gdl increment
; Assumes both functions are constant
(defun gdl-scale (f1 f2)
  (let ((max f1))
    (if (or (zerop max) (<= max max-gdl-increment))
        f2 ; Use original function
      (let (nv)
        (setq nv (/ (* f2 max-gdl-increment) max))
        nv))
    )
  )        

; Determine if number n is within dimensions d's bounds
(defun within-bounds (n dim)
  (and (e>= n (dimension-min dim) t) (< n (dimension-max dim)))
  )

; Determine if point is in a PLM (not outside of the minimum and maximum slices for any dimension)
(defun point-in-plm (x p)
  (let ((result t)
        (vs (plm-variables p))
        xi)
    (dotimes (i (length vs))
      (setq xi (aref x i)) ; start at position 1 for initial dimension in point
      (when (or (e< xi (stype-min (svariable-type (aref vs i))))
                (e>= xi (stype-max (svariable-type (aref vs i))) t))
        (setq result nil)
        (return nil)
        )
      )
    result)
  )

; Find the index vector for the region containing the point
(defun region-point-index (slice-array x rank)
  (let ((rindex (init-vector rank))
        )
    (dotimes (d rank)
      (dolist (s (aref slice-array d))
        (when (e< (aref x d) (slice-location s))
          (setf (aref rindex d) (1- (slice-index s)))
          (return)
          )
        )
      )
    rindex)
  )

; Determine region within a PLM p containing point x (in p2 space)
; Returns nil if the point isn't in the PLM
(defun region-point (x p)
  (if (point-in-plm x p)
      (apply #'aref (plm-array p) (coerce (region-point-index (plm-slices p) x (plm-rank p)) 'list))
    nil)
  )

; Check if two PLMs to be multiplied are compatible type-wise
(defun plm-type-check (plm1 map plm2)
  (let* ((vars1 (plm-variables plm1))
         (vars2 (plm-variables plm2))
         v2
         (check t)
         mapd)
    (dotimes (d (length vars1))
      (setq mapd (if map (aref (smap-vfactor map) d) d))
      ; Deal with dimensions in factor with multiple variables (delta and transform functions)
      (setq v2 (aref vars2 mapd))
      (when (listp v2) (setq v2 (car v2)))
      ; Check that types are the same
      (unless (eq (svariable-type (aref vars1 d))
                  (svariable-type v2))
        (error "Type incompatibiltiy in plm-type-check ~D:~S, ~D:~S"
               d (stype-name (svariable-type (aref vars1 d)))
               mapd (stype-name (svariable-type v2))
               )
        (return (setq check nil))))
    check)
  )

; Beginning of code for sparse product---------------------

; Total volume of PLM
(defun plm-volume (p)
  (reduce #'* (plm-variables p) :key #'(lambda (v) (stype-span (svariable-type v))))
  )

; Just determine which slices begin non-empty regions
; Alternative to plm-dense function when don't need to figure out the density
(defun plm-non-empty (p)
  (let* ((piecewise-constant (plm-piecewise-constant p))
         (dense-volume 0)
         (rank (plm-rank p))
         (rarray (plm-array p))
         (non-empty (init-vector rank)) ; Will store vectors marking which slices start non-empty regions
         (slice-vector (plm-slices p))
         r ds)
    ; Initialize non-empty vector for each dimension's slices
    (dotimes (d rank)
      (setf (aref non-empty d) (init-vector (length (aref slice-vector d))))
      )
    (dotimes (i (array-total-size rarray))
      (setq r (row-major-aref rarray i))
      (when (not (region-e-empty r piecewise-constant))
        (setq ds (region-dimensions r))
        ; Add volume of region to dense total
        (setq dense-volume (+ (region-volume r) dense-volume)) 
        ; Mark min slices as starting non-empty regions
        (dotimes (d rank)
          (setf (aref (aref non-empty d) (slice-index (dimension-min-slice (aref ds d)))) t)
          )
        )
      )
    (values non-empty (/ dense-volume (plm-volume p)))) 
  )

; Merge a sparse list of slices with another one
; Return merged list plus cross-indexes to input lists
(defun sparse-merge-slices (sl1 sl-non-empty sl2)
  (let ((slice-mappings (init-vector 2))
        (slice-number 0)
        (last2 0)
        nsl car-sl cadr-sl min1 max1 loc2 sml1 sml2 index1 non-empty
        )
    ; Iterate through slices of first PLM
    (do ((sl1c sl1 (cdr sl1c)))
        ((null (cdr sl1c)) (setq car-sl (car sl1c)))
      (setq car-sl (car sl1c))
      (setq min1 (slice-location car-sl))
      (setq cadr-sl (cadr sl1c))
      (setq max1 (slice-location cadr-sl))
      ; Add slice from first PLM to new list
      (push (make-slice :location (slice-location car-sl) :index slice-number) nsl)
      ; Add cross-indexes
      (setq index1 (slice-index car-sl))
      (setq non-empty (aref sl-non-empty index1))
      (push index1 sml1)
      (when (e= min1 (slice-location (car sl2)) t)
        (setq last2 (slice-index (car sl2)))
        (setq sl2 (cdr sl2))
        )
      (push last2 sml2)
      (setq slice-number (1+ slice-number))
      (do ((sl2c sl2 (cdr sl2c))) ; Add the slices from the second PLM from here to the next slice of the first PLM
          ((null sl2c) nil)
        (setq loc2 (slice-location (car sl2c)))
        (cond ((e>= loc2 max1 t) ; Beyond the current region from first PLM
               (setq sl2 sl2c)
               (return)
               )
              ((and (> loc2 min1) (< loc2 max1)) ; Slice from second PLM is within region of first PLM
               (setq last2 (slice-index (car sl2c)))
               (when non-empty ; The slice in the first PLM begins a non-empty region
                 (push (make-slice :location loc2 :index slice-number) nsl)
                 (push index1 sml1)
                 (push last2 sml2)
                 (setq slice-number (1+ slice-number))
                 )
               )
              )
        )
      )
    ; Add last slice
    (push (make-slice :location (slice-location car-sl) :index slice-number) nsl)
    (push (slice-index car-sl) sml1)
    (push (slice-index (car sl2)) sml2)
    ; Create slice mappings by reversing lists and coercing to vectors
    (setf (aref slice-mappings 0) (coerce (reverse sml1) 'vector))
    (setf (aref slice-mappings 1) (coerce (reverse sml2) 'vector))
    (values (nreverse nsl) slice-mappings))
  )

; A vector that counts up from 0 until its end
(defun count-up-vector (n)
  (let ((v (init-vector n)))
    (dotimes (i n)
      (setf (aref v i) i)
      )
    v)
  )

; Find the slices and mappings for a sparse product
(defun find-sparse-slices (p1 p1-non-empty map p2)
  (let* ((rank1 (plm-rank p1))
         (rank2 (plm-rank p2))
         (nsv (init-vector rank2)) ; Slices
         (mappings (init-vector rank2)) ; Mappings
         (sv1 (plm-slices p1))
         (sv2 (plm-slices p2))
         (mapv (if map (smap-vfactor map) nil))
         md
         one-sv one-mapping
         )
    ; Handle dimensions in common between the two PLMS
    (dotimes (d rank1)
      (setq md (if mapv (aref mapv d) d))
      (multiple-value-setq (one-sv one-mapping) (sparse-merge-slices (aref sv1 d) (aref p1-non-empty d) (aref sv2 md)))
      (setf (aref nsv md) one-sv)
      (setf (aref mappings md) one-mapping)
      )
    ; Handle dimensions only in second PLM
    (dotimes (d rank2)
      (when (null (aref nsv d))
        (setf (aref nsv d) (copy-seq (aref sv2 d)))
        (setf (aref mappings d) (vector nil (count-up-vector (length (aref sv2 d)))))
        )
      )
    (values nsv mappings))
  )

; Find the slices and mappings for a sparse product
; This function is used when the second plm is the sparse one, non-empty should be created by using p2
(defun find-sparse-slices-reverse (p1 p2-non-empty map p2) 
  (let* ((rank1 (plm-rank p1))
         (rank2 (plm-rank p2))
         (nsv (init-vector rank2)) ; Slices
         (mappings (init-vector rank2)) ; Mappings
         (sv1 (plm-slices p1))
         (sv2 (plm-slices p2))
         (mapv (if map (smap-vfactor map) nil))
         md
         one-sv one-mapping
         )
    ; Handle dimensions in common between the two PLMS
    (dotimes (d rank1)
      (setq md (if mapv (aref mapv d) d))
      (multiple-value-setq (one-sv one-mapping) (sparse-merge-slices (aref sv2 md) (aref p2-non-empty md) (aref sv1 d)))
      (setf (aref nsv md) one-sv)
      (setf (aref mappings md) one-mapping)
      )
    ; Handle dimensions only in second PLM
    (dotimes (d rank2)
      (when (null (aref nsv d))
        (setf (aref nsv d) (copy-seq (aref sv2 d)))
        (setf (aref mappings d) (vector (count-up-vector (length (aref sv2 d))) nil))
        )
      )
    (values nsv mappings))
  )

; Make index for accessing an input region in sparse product
(defun sparse-region-index (nindex which-index mapv size cross-indexes)
  (let (index mapd)
    (dotimes (d size)
      (setq mapd (if mapv (aref mapv d) d))
      (push (aref (aref (aref cross-indexes mapd) which-index) (aref nindex mapd)) index)
      )
    (nreverse index))
  )

; Compute product of two PLMs where the first one is sparse
(defun sparse-product-plms (p1 non-empty map p2 &optional evidence argument)
  (let* ((pc1 (plm-piecewise-constant p1))
         (pc2 (plm-piecewise-constant p2))
         (rarray1 (plm-array p1))
         (rarray2 (plm-array p2))
         (rank1 (plm-rank p1))
         (rank2 (plm-rank p2))
         (piecewise-constant (and pc1 pc2))
         (nindex (init-vector (plm-rank p2) 0))
         (mapv (if map (smap-vfactor map) nil))
        slice-vector cross-indexes np nrarray sizev-1)
    (multiple-value-setq (slice-vector cross-indexes) (find-sparse-slices p1 non-empty map p2))
    (setq np (init-plm-with-slices (copy-seq (plm-variables p2)) 0 0 (init-vector (plm-rank p2) t) slice-vector))
    (setq nrarray (plm-array np))
    (setq sizev-1 (vector-1 (dimension-sizes-v np)))
    (dotimes (i (array-total-size nrarray))
      (combine-regions p1 (apply #'aref rarray1 (sparse-region-index nindex 0 mapv rank1 cross-indexes)) map
                       p2 (apply #'aref rarray2 (sparse-region-index nindex 1 nil rank2 cross-indexes))
                       (row-major-aref nrarray i) np 'product evidence argument pc1 pc2 piecewise-constant)
      (setq nindex (next-index-vector nindex sizev-1 rank2))
      )
    np)
  )

; Compute product of two PLMs where the first one is sparse
; This function is used when the second plm is the sparse plm,  non-empty should be created by using p2
(defun sparse-product-plms-reverse (p1 p2-non-empty map p2 &optional evidence argument) 
  (let* ((pc1 (plm-piecewise-constant p1))
         (pc2 (plm-piecewise-constant p2))
         (rarray1 (plm-array p1))
         (rarray2 (plm-array p2))
         (rank1 (plm-rank p1))
         (rank2 (plm-rank p2))
         (piecewise-constant (and pc1 pc2))
         (nindex (init-vector (plm-rank p2) 0))
         (mapv (if map (smap-vfactor map) nil))
        slice-vector cross-indexes np nrarray sizev-1
        )
    (multiple-value-setq (slice-vector cross-indexes) (find-sparse-slices-reverse p1 p2-non-empty map p2))
    (setq np (init-plm-with-slices (copy-seq (plm-variables p2)) 0 0 (init-vector (plm-rank p2) t) slice-vector))
    (setq nrarray (plm-array np))
    (setq sizev-1 (vector-1 (dimension-sizes-v np)))
    (dotimes (i (array-total-size nrarray))
      (combine-regions p1 (apply #'aref rarray1 (sparse-region-index nindex 1 mapv rank1 cross-indexes)) map
                       p2 (apply #'aref rarray2 (sparse-region-index nindex 0 nil rank2 cross-indexes))
                       (row-major-aref nrarray i) np 'product evidence argument pc1 pc2 piecewise-constant)
      (setq nindex (next-index-vector nindex sizev-1 rank2))
      ) 
    np)
  )

; For testing sparse product
(defun tsp ()
  (let ((map (make-smap :vfactor #(1)))
        preds predd sparse dense non-empty)
    (init)
    (new-type 'ten :discrete t :numeric t :min 0 :max 10)
    (setq preds (predicate 'sparse :arguments '((x ten))))
    (setq predd (predicate 'dense :arguments '((y ten) (x ten))))
    (setq sparse (cpt-function-array-plm '(wm-x) '((1 (0 3)) (1 5)) (predicate-wm-variables preds) 0))
    (setq dense (cpt-function-array-plm '(wm-y wm-x) '((1 0 0) (1 0 (2 4)) (1 0 (6 8)) (1 1 (6 8))) (predicate-wm-variables predd) 0))
    (pa sparse t)
    (pa dense t)
    (setq non-empty (plm-non-empty sparse))
;    (find-sparse-slices sparse non-empty map dense)
;    (sparse-merge-slices (aref (plm-slices sparse) 0) (aref non-empty 0) (aref (plm-slices dense) 0))
    (pa (sparse-product-plms sparse non-empty map dense))
    t)
  )

; End of code for sparse product------------------------------------

; Compute pointwise combination (product, sum, difference or max) of two regions and assign as function of new region (rnew)
; For product, computes quadratic product and then approximates as linear using
; slopes evaluated at three points in new region (min, mid, max)
; map determines how the dimensions of r1 match up with r2.
(defun combine-regions (p1 r1 map p2 r2 rnew np op &optional evidence argument pc1 pc2 piecewise-constant invert)
  (let* ((r2-rank (region-rank r2))
         wv ; New function
         (mapv (if map (smap-vfactor map) nil))
         (r1-f (region-weights r1 r2-rank mapv piecewise-constant)) ; Function in first region
         (r2-f (region-weights r2 r2-rank nil piecewise-constant)) ; Function in second region
         )
    (case op
      ((sum) ; Compute sum of two non-empty regions
       (setq wv (vector-sum r1-f r2-f piecewise-constant))
       )
      ((difference) ; Compute difference of two regions
       (setq wv (vector-difference r1-f r2-f piecewise-constant))
       )
      ((product) ; Compute products of two non-empty regions
       (setq wv (product-functions (region-weights r1 r2-rank mapv pc1) (region-weights r2 r2-rank nil pc2) r2-rank rnew pc1 pc2))
       )
      ((max) ; Compute max of two regions
       (setq wv (max-functions r1-f r2-f rnew piecewise-constant))
       )
      ((por) ; Compute probabilistic or of two regions
       (setq wv (por-functions r1-f r2-f r2-rank rnew piecewise-constant))
       )
      ((divide) ; Divide regions in first PLM by constants in second (doesn't handle full functions in second)
       (setq wv (divide-functions r1-f r2-f piecewise-constant))
       )
      ((divide-0) ; Divide regions in first PLM by constants in second (doesn't handle full functions in second), returning 0 if second is 0
       (setq wv (divide-0-functions r1-f r2-f piecewise-constant))
       )
      ((gdl-scale) ; Scale regions in second PLM by constants in first (doesn't handle full functions in second, and extracts constant from first)
       (cond (piecewise-constant
              (setq wv (gdl-scale (if (numberp r1-f) r1-f (aref r1-f 0)) (if (numberp r2-f) r2-f (aref r2-f 0))))
              )
             (t
              (setq wv (init-vector (length r1-f) 0))
              (setf (aref wv 0) (gdl-scale (if (numberp r1-f) r1-f (aref r1-f 0)) (if (numberp r2-f) r2-f (aref r2-f 0))))
              wv
              )
             )
       )
      ; *** Paul's new addition
      ((inner-bc) ; Within-integral aspect of Bhattacharyya-coefficient
      (setq wv (inner-bc-constants r1-f r2-f))
       )
      ((constrain-by-0) ; Constrain first region to 0 when second is
       (setq wv (constrain-by-0-function r1-f r2-f piecewise-constant))
       )
      ((compute-subtractor) ; Compute subtractor for subtractive normalization
       (setq wv (compute-subtractor r1-f r2-f piecewise-constant))
       )
      ; *** Paul's new addition
      ((translate) ; Translate region in first PLM by offset from second
       (let (dimension offset d type)
         (setq wv r1-f) ; The first argument is the original PLM
         (setq dimension (car argument)) ; (car argument) is the dimension along which to translate
         (setq offset (reduce #'min (aref (region-maximals r2) (cdr argument)) :key #'car)) ; (cdr argument) is the offset dimension
         (when center-discrete-numeric-on-integer
           (setq offset (+ offset 1/2))
           )
         (if invert (setq offset (* -1 offset))) ;VOLKAN
         (setq d (aref (region-dimensions rnew) dimension)) ; Region dimension along which to offset
         (setq type (svariable-type (aref (plm-variables p1) dimension))) ; Type of variable along dimension to offset
         (setf (dimension-min-slice d) (make-slice :location (max (stype-min type) (+ (dimension-min d) offset))))
         (setf (dimension-max-slice d) (make-slice :location (min (stype-max type) (+ (dimension-max d) offset))))
         (when (or (e>= (dimension-min d) (stype-max type))
                   (e<= (dimension-max d) (stype-min type))
                   )
           (setf (region-bad rnew) t)
           )
         )
       )
      (t (error "Unknown combination operator for PLMs: ~S" op))
      )
    (assign-function wv rnew piecewise-constant)
    ; Propagate region evidence to new region
    (when evidence
      (if (or (region-evidence r1) (region-evidence r2))
          (setf (region-evidence rnew) t)
        (setf (region-evidence rnew) nil))
      )
    (when (eq trace-combine 'region)
      (format trace-stream "~&~%R1: ") (print-region r1 p1 t trace-stream)
      (format trace-stream "~&R2: ") (print-region r2 p2 t trace-stream)
      (format trace-stream "~&RNEW: ") (print-region rnew np t trace-stream)
      )
    wv) ; Return the vector for debugging purposes
  )

; Create a new PLM that is the combination of two others
; op specifies which operation to perform
; The first plm may contain a subset of the variables of the second one
; If map exists, determines how to map variables of first PLM onto second
; Destructive-p1 is used to allow normalization (by division by p2) to be destructive
(defun combine-plms (p1 map p2 op &optional evidence argument keep-unneeded-slices destructive-p1 invert)
  (let* (np p1rarray nprarray p2rarray
            civ ; Slice cross-index vector
            nprank nr
            p1sizeone
            p1-origin
            cv ; Current index vector
            sizev-1 ; Dimension sizes -1
;            non-empty
            pc1
            pc2
            px
            piecewise-constant
            non-empty1
            non-empty2
            density-plm1
            density-plm2
            )
    (unless (plm-type-check p1 map p2)
      (error "Attempt to ~S two PLMs not of the same type: " op) (pplm p1) (pplm p2)
      )
    ; Under the right circumstances, swap p1 and p2
    (when (and (eq op 'product)
               (null map)
               (= (plm-rank p1) (plm-rank p2))
               (> (plm-size p1) (plm-size p2))
               )
      (setq px p1)
      (setq p1 p2)
      (setq p2 px)
      )
    (setq p1sizeone (= (plm-size p1) 1))
    (setq p1-origin (plm-origin p1))
    (setq pc1 (plm-piecewise-constant p1))
    (setq pc2 (plm-piecewise-constant p2))
    (setq piecewise-constant (and pc1 pc2))
    (cond ((and (eq op 'product) ; This is a product, and one constant region covers entire domain (or there is no domain because no variables)
                p1sizeone
                (region-is-constant p1-origin)
                )
           (setq np (if (zerop (region-constant p1-origin))
                        (empty-plm (plm-variables p2))
                      (if (= (region-constant p1-origin) 1)
                          p2
;                      (remove-unneeded-slices
                        (transform-plm #'scale-function p2 (region-constant p1-origin))
;                       )
                      )))
           )
          ((eq op 'product)
;           ((and sparse-product
;                 (setq non-empty (check-for-sparse-product p1 op))
;                 )
           (when trace-combine
             (format trace-stream "~&~%PRODUCT(SPARSE):")      
             (format trace-stream "~&~%P1: ") (print-plm p1 symbolic-trace trace-stream)
             (when map
               (format trace-stream "~&~%MAP: vfactor: ~S fvar: ~S omitted: ~S"
                       (smap-vfactor map) (smap-fvar map) (smap-omitted map)
                       )
               )
             (format trace-stream "~&~%P2: ") (print-plm p2 symbolic-trace trace-stream)
             )
           (multiple-value-setq (non-empty1 density-plm1) (plm-non-empty p1))  ;VOLKAN Sparse_Update - New function
           (multiple-value-setq (non-empty2 density-plm2) (plm-non-empty p2)) ;VOLKAN Sparse_Update - New function
           (if (< density-plm1 density-plm2)  ;VOLKAN Sparse_Update - New function
               (setq np (sparse-product-plms p1
;                                         non-empty
                                         ;(plm-non-empty p1)
                                         non-empty1
                                         map p2 evidence argument))
             (setq np (sparse-product-plms-reverse p1  ;VOLKAN Sparse_Update - New function
                                         non-empty2
                                         map p2 evidence argument))
             )
           (when trace-combine
             (format trace-stream "~&~%~S RESULT: " op) (print-plm np symbolic-trace trace-stream)
             )
           np)
          ((and destructive-p1 (member op '(divide divide-0)))
           (setq civ (cross-index-slice-vector (plm-slices p2) nil (plm-slices p1)))
           (setq np p1)
           (setq nprarray (plm-array np))
           (setq nprank (plm-rank np))
           (setq cv (init-vector nprank 0))
           (setq sizev-1 (vector-1 (array-dimensions-v nprarray)))
           (setq p2rarray (plm-array p2))
           (dotimes (i (array-total-size nprarray))
             (setq nr (row-major-aref nprarray i))
             (combine-regions np nr nil p2 (apply #'aref p2rarray (index-list-from-cross-index cv civ nil))
                              nr np op evidence argument pc1 pc2 piecewise-constant invert)
             (setq cv (next-index-vector cv sizev-1 nprank))
             )
           (setq np p1)
           )
          (t
           (when trace-combine
             (format trace-stream "~&~%~S:" op)
             (format trace-stream "~&~%P1: ") (print-plm p1 symbolic-trace trace-stream)
             (when map
               (format trace-stream "~&~%MAP: vfactor: ~S fvar: ~S omitted: ~S"
                       (smap-vfactor map) (smap-fvar map) (smap-omitted map)
                       )
               )
             (format trace-stream "~&~%P2: ") (print-plm p2 symbolic-trace trace-stream)
             )
           (setq p1rarray (plm-array p1))
           (setq np (if p1sizeone (copy-a-plm p2) (apply-slices (plm-slices p1) map (copy-a-plm p2))))
           (update-combine-active (plm-active p1) map (plm-active p2) (plm-active np)) ; Paul's new addition
           (setq nprarray (plm-array np))
           (unless p1sizeone
             (setq civ (cross-index-slice-vector (plm-slices p1) map (plm-slices np)))
             (setq nprank (plm-rank np))
             (setq cv (init-vector nprank 0))
             (setq sizev-1 (vector-1 (array-dimensions-v nprarray)))
             )
           (dotimes (i (array-total-size nprarray))
             (combine-regions p1 (if p1sizeone
                                     p1-origin
                                   (apply #'aref p1rarray (index-list-from-cross-index cv civ map)))
                              map np (row-major-aref nprarray i) (row-major-aref nprarray i) np op evidence argument pc1 pc2 piecewise-constant invert)
             (unless p1sizeone
               (setq cv (next-index-vector cv sizev-1 nprank))
               )
             )
           (unless keep-unneeded-slices
;             (setq np (remove-unneeded-slices np))
             )
           (when trace-combine
             (format trace-stream "~&~%~S RESULT: " op) (print-plm np symbolic-trace trace-stream)
             )
           np)
        )
    (setf (plm-piecewise-constant np) piecewise-constant)
    np)
  )

; Debug function for multiplying two plms with same variables
(defun product-plms (p1 p2)
  (combine-plms p1 nil p2 'product)
  )

; Compute the posterior distribution for a variable as the product
; of the incoming messages for the node
(defun variable-posterior (n)
  (when (variable-nodep n)
    (let ((links (node-links n))
          post uds)
      (dolist (link links)
        (when (link-fact-content link) ; Only when link is active in this direction
          (if post
              (setq post (combine-plms (link-fact-content link) nil post 'product))
            (setq post (link-fact-content link)))
          )
        )
      (when post
        (setq post (remove-unneeded-slices post))
        )
      (when (and post (node-normalize n))
        (setq uds (unique-dimensions post t))       
        (when uds   
          (setq post
          (if (node-vector n)  
              (normalize-plm post nil t t) 
            (normalize-plm post nil t))
          )
          )
        )
      post)
    )
  )

; Return maximum value in region
(defun maximum-in-region (r)
  (let (d+1
        (f (extract-function r))
        (max (region-constant r)))
    (dotimes (d (region-rank r))
      (setq d+1 (1+ d))
      (when (numberp (aref f d+1))
        (unless (zerop (aref f d+1))
          (setq max (+ max (* (aref f d+1)
                              (if (< (aref f d+1) 0)
                                  (region-min r d)
                                (- (region-max r d)
                                   (if (region-discrete r d) 1 epsilon2)))))) ; Region open at top
          )
        )
      )
    max)
  )

; Return maximum value in PLM
(defun maximum-in-plm (plm)
  (let ((max 0)
        val
        (rarray (plm-array plm)))
    (dotimes (i (array-total-size rarray))
      (setq val (maximum-in-region (row-major-aref rarray i)))
      (when (> val max) (setq max val))
      )
    max)
  )

; Transform a PLM so that if largest functional value is >1, the PLM is uniformaly scaled to be <=1
(defun scale-to-one-plm (plm)
  (let ((max plm)
        (new plm))
#|    (dotimes (i (length (plm-variables plm)))
      (setq max (maximize-plm max i))
      )
    (setq max (region-constant (plm-origin max)))|#
    (setq max (maximum-in-plm plm))
    (when (> max 1)
        (setq new (transform-plm #'scale-function plm (/ 1.0 max)))
        )
    new)
  )


; -----------------------------------------------------------
; Compute the outer combination of two PLMs

; Create a PLM in which to store the product of two PLMs (via an array)
; This function generates all of the regions but doesn't set the functions
; The variables in the first PLM are always a (not necessarily proper) subset
; of those in the second
; The product is always as big as the second PLM
(defun init-outer-plm (p1 p2)
  (let* (nv ; New variable vector
         na ; New active vector
         ns ; New slice vector
         (v1 (plm-variables p1))
         (v2 (plm-variables p2))
         (a1 (plm-active p1))
         (a2 (plm-active p2))
         (s1 (plm-slices p1))
         (s2 (plm-slices p2))
         (r1 (plm-rank p1))
         (r2 (plm-rank p2))
         (nr (+ r1 r2))
         ir
         )
    (setq nv (init-vector nr))
    (setq na (init-vector nr))
    (setq ns (init-vector nr))
    (dotimes (i r1) ; Copy variables and active from p1
      (setf (aref nv i) (aref v1 i))
      (setf (aref na i) (aref a1 i))
      (setf (aref ns i) (aref s1 i))
      )
    (dotimes (i r2) ; Copy variables and active from p2
      (setq ir (+ i r1))
      (setf (aref nv ir) (aref v2 i))
      (setf (aref na ir) (aref a2 i))
      (setf (aref ns ir) (aref s2 i))
      )
    (init-plm-with-slices nv 0 0 na ns)
    )
  )

; Generate a weight vector (with the constant oin the 0 position and everything else shifted over) for an outer product
(defun outer-region-weights (r rank offset)
  (let ((vf (init-vector (+ rank 1) 0)))
    (setf (aref vf 0) (region-constant r))
    (dotimes (d (region-rank r))
      (setf (aref vf (+ d offset)) (region-weight r d))
      )
    vf)
  )

; Compute outer combination (product) of two regions and assign as function of new region (rnew)
(defun outer-combine-regions (p1 r1 p2 r2 rnew np op)
  (let* ((nr-rank (region-rank rnew))
         (wv (init-vector (+ nr-rank 1) 0)) ; 0th element is the constant
         wps
         )
    (cond ((eq op 'product) ; Compute products of two non-empty regions
           ; Multiply two linear functions to achieve a quadratic function via outer product
           (setq wps (outer-product (outer-region-weights r1 nr-rank 1)
                                    (outer-region-weights r2 nr-rank (+ (region-rank r1) 1))))
           ; Compute slopes for the variables
           (dotimes (d nr-rank)
             (setf (aref wv (+ d 1)) (slope-approximation-points wps (region-mins rnew) (region-mids rnew) (region-maxs rnew) (+ d 1)))
             )
           ; Compute constant
           (setf (aref wv 0) 0) ; Baseline for computing constant
           (setf (aref wv 0) (constant-approximation-points wps wv (region-mins rnew) (region-mids rnew) (region-maxs rnew)))
           )
          (t (error "Unknown outer combination operator for PLMs: ~S" op))
          )
    ; Assign weights to new region
    (assign-function wv rnew)
    (when (eq trace-combine 'region)
      (format trace-stream "~&~%R1: ") (print-region r1 p1 t trace-stream)
      (format trace-stream "~&R2: ") (print-region r2 p2 t trace-stream)
      (format trace-stream "~&RNEW: ") (print-region rnew np t trace-stream)
      )
    wv) ; Return the vector for debugging purposes
  )

; Create a new PLM that is the outer combination of two others
; op specifies which operation to perform
; The first plm may contain a subset of the variables of the second one
; If map exists, determines how to map variables of first PLM onto second
; Recursive version
(defun outer-plms (p1 p2 op)
  (let* ((np (init-outer-plm p1 p2))
         (rank1 (plm-rank p1)) (rank2 (plm-rank p2))
         r1 r2 rn
         (rarray1 (plm-array p1)) (rarray2 (plm-array p2)) (rarrayn (plm-array np))
         (sizev1 (dimension-sizes-v p1)) (sizev2 (dimension-sizes-v p2))
         (sizev1-1 (vector-1 sizev1)) (sizev2-1 (vector-1 sizev2))
         indices1 indices2 indicesn ; Lists of indexs for the three PLMs
         (total-size1 (array-total-size rarray1)) (total-size2 (array-total-size rarray2))
         )
    (when trace-combine
      (format trace-stream "~&~%~S:" op)
      (format trace-stream "~&~%P1: ") (print-plm p1 symbolic-trace trace-stream)
      (format trace-stream "~&~%P2: ") (print-plm p2 symbolic-trace trace-stream)
      )
    (setq indices1 (make-list rank1 :initial-element 0))
    (dotimes (i1 total-size1)
      (setq r1 (apply #'aref rarray1 indices1))
      (setq indices2 (make-list rank2 :initial-element 0))
      (dotimes (i2 total-size2)
        (setq r2 (apply #'aref rarray2 indices2))
        (setq indicesn (append indices1 indices2))
        (setq rn (apply #'aref rarrayn indicesn))
        (outer-combine-regions p1 r1 p2 r2 rn np op) ; Combine the regions
        (setq indices2 (next-index-list indices2 sizev2-1 rank2))
        )
      (setq indices1 (next-index-list indices1 sizev1-1 rank1))
      )
    (when trace-combine
      (format trace-stream "~&~%~S RESULT: " op) (print-plm np symbolic-trace trace-stream)
      )
    (when (and (plm-piecewise-constant p1) (plm-piecewise-constant p2))
      (setf (plm-piecewise-constant np) t)
      )
    np)
  )

; Debug function for multiplying two plms with same variables
(defun product-outer-plms (p1 p2)
  (outer-plms p1 p2 'product)
  )

; -----------------------------------------------------------
; Summarize across one dimension of a PLM
; This only handles cases where you simply aggregate summarizations of the regions
; It doesn't handle more complicated cases where need to retain other results across the summarization, such as maximals

; Create an empty PLM with all of the regions needed for the summarization over multiple dimensions (via arrays)
; If one dimension is provided as a number, convert it to a list
(defun init-summarize-plm (p ds)
  (when (numberp ds) (setq ds (list ds)))
  (let ((slices (copy-seq (plm-slices p))))
    (dolist (d ds)
      (setf (aref slices d) (list (make-slice :location (stype-min (svariable-type (aref (plm-variables p) d))) :index 0) ; Dimension of summarizaiton only has extreme slices
                                  (make-slice :location (stype-max (svariable-type (aref (plm-variables p) d))) :index 1)
                                  ))
      )
    (init-plm-with-slices (plm-variables p) 0 0 (copy-seq (plm-active p)) slices))
  )

; Convert region volume into a function for use in summarize-region
(defun region-volume-function (r ds &optional piecewise-constant)
  (if piecewise-constant
      (region-volume-ds r ds)
    (let ((rw (init-vector (1+ (region-rank r)) 0)))
      (setf (aref rw 0) (region-volume-ds r ds))
      rw))
  )

; Summarize over one dimension of a region
(defun summarize-region (r ds op &optional argument piecewise-constant vector)
  (case op
    ((integral)
     (integral-region r ds piecewise-constant vector)) 
    ((extract-value)
     (extract-value-region r ds argument piecewise-constant))
    ((span-above-threshold)
     (span-above-threshold-region r ds argument piecewise-constant))
    ((volume)
     (region-volume-function r ds piecewise-constant)
     )
    (t (error "Unknown region summarization operator for a PLM: ~S" op))
    )
  )

; Summarize over one dimension of a PLM, yielding a new PLM
; region-op specifies how to summarize over a region, while combine-op says how to combine summarizations across regions
; Doesn't actually eliminate the dimension from the PLM, but makes it inactive
; If there is a region-argument, provide it to the region-op
(defun summarize-plm (p din region-op combine-op &optional region-argument vector) 
  (let* ((ds (if (consp din) din (list din)))
         (np (init-summarize-plm p ds))
         (rarray (plm-array p))
         (rarrayn (plm-array np))
         (rank (plm-rank p))
         (sizev (dimension-sizes-v p))
         (sizev-1 (vector-1 sizev))
         (size (array-total-size rarray))
         (sizeln (dimension-sizes np))
         (sizen (array-total-size rarrayn))
         (summaries (make-array sizeln))
         r ; Region
         rsummary ; Region integral
         ii ii0
         (piecewise-constant (plm-piecewise-constant p))
         )
    (when trace-summarize
      (format trace-stream "~&~%~S" region-op)
      (format trace-stream "~&~%P: ") (print-plm p symbolic-trace trace-stream)
      (format trace-stream "~&~%~S DIMENSION(S): ~S" region-op ds)
      )
    ; Compute the summazation over the regions in the PLM as function vectors in the variable (vector) summaries
    (setq ii (make-list rank :initial-element 0))
    (dotimes (i size)
      ; Zero the index along ds
      (setq ii0 (copy-seq ii))
      (dolist (d ds)
        (setf (nth d ii0) 0)
        )
      (setf r (row-major-aref rarray i))
      (setq rsummary (summarize-region r ds region-op region-argument piecewise-constant vector)) 
      (setf (apply #'aref summaries ii0) (if (apply #'aref summaries ii0) (apply combine-op rsummary (list (apply #'aref summaries ii0) piecewise-constant)) rsummary))
      (setq ii (next-index-list ii sizev-1 rank))
      )
    ; Assign functions to new regions
    (dotimes (i sizen)
      (assign-function (row-major-aref summaries i) (row-major-aref rarrayn i) piecewise-constant)
      )
    ; Make summarised dimensions inactive
    (dolist (d ds)
      (setf (aref (plm-active np) d) nil)
      )
    (when trace-summarize
      (format trace-stream "~&~%~S RESULT: " region-op) (print-plm np symbolic-trace trace-stream)
      )
    (when (plm-piecewise-constant p)
      (setf (plm-piecewise-constant np) t)
      )
    np)
  )

; -----------------------------------------------------------
; Compute integral across one dimension of a PLM

; For a linear function, compute the function obtained by the value of an integral along dimension d at point n of region r
; n is a (1D) vaue along dimension d
(defun integral-point-linear (r d n)
  (let* ((rw (extract-function r))
         (lrw (length rw))
         (rwnew (init-vector lrw))
         (d1 (+ d 1))
         )
    ; Multiply all weights by the value along the dimension being integrated
    ; The weight for the integrated dimension is not correct, but reset later
    (dotimes (i lrw)
      (setf (aref rwnew i) (* n (aref rw i)))
      )
    ; Instantiate dimension d and move over to part of constant
    ; The weight for it is currently the original weight times the value
    ; Need to multiply by the value once more (for x^2) and divide by 2
    (setf (aref rwnew 0) (+ (aref rwnew 0) (/ (* n (aref rwnew d1)) 2)))
    (setf (aref rwnew d1) 0)
    rwnew)
  )

; For an exponential function, compute the function obtained by the value of an integral along dimension d at point n of region r
; n is a (1D) value along dimension d
(defun integral-point-exponential (r d n)
  (let* ((rw (extract-function r))
         (lrw (length rw))
         (rwnew (init-vector lrw 0))
         (d1 (+ d 1))
         (dw (aref rw d1)) ; coefficient for dimension d
         )
    ; Copy old weights into new weight vector
; Deleted because we're assuming the other weights are all 0 (and depend on this below)
;    (dotimes (i lrw)
;      (setf (aref rwnew i) (aref rw i))
;      )
    ; Update constant
;    (setf (aref rwnew 0)
;          (+ (aref rwnew 0)
;             (if (e= dw 0) ; If weight for dimension is 0
;                 (if (e= n 0) ; If point is 0
;                     (- infinity) ; Set "log" to negative infinity
;                   (log n) ; Integral is original function times variable value (n), so add log(n) to constant
;                   )
;               (+ (log (/ 1 dw)) (* dw n))))) ; Otherwise, add weight times point plus log of one over weight
;    (setf (aref rwnew d1) 0)
    ; The following only works when there are no weights on dimensions other than on the one being integrated
    ; We're returning an an unexponentiated function with just a constant
    (setf (aref rwnew 0)
          (* (exp (aref rw 0))
             (if (e= dw 0) ; If weight for dimension is 0
                 n
               (* (/ 1 dw) (exp (* dw n))))
             ))
    rwnew)
  )

; Compute the integral over dimension d for region r
; Yields the definite integral from the minimum of d to the maximum of d
(defun integral-region (r ds &optional piecewise-constant vector) 
  (let ((rw (extract-function r piecewise-constant)))
    (if piecewise-constant ; Function is constant
       (if vector 
           (dolist (d ds)
             (setf rw (* (expt rw 2) (- (region-max r d) (region-min r d)))) 
            )
          (if (region-exponential r) ; Function is exponential
              (dolist (d ds)
                (setq rw (* (exp rw) (- (region-max r d) (region-min r d))))
                )
            (if (zerop rw) ; Function is 0
                (setq rw 0)
              (dolist (d ds)
                (setq rw
                      (if (= rw 1) ; Function is 1
                          (- (region-max r d) (region-min r d))
                        (* rw (- (region-max r d) (region-min r d)))))
                ))) 
          )
      (if (region-exponential r)
          (dolist (d ds)
            (setq rw (vector-difference (integral-point-exponential r d (region-max r d)) ; Compute definite integral
                                        (integral-point-exponential r d (region-min r d))))
            )
        (dolist (d ds)
          (setq rw (vector-difference (integral-point-linear r d (region-max r d)) ; Compute definite integral
                                      (integral-point-linear r d (region-min r d)))))
        )
      )
    rw)
  )

; Integrate over one dimension of a PLM, yielding a new PLM
(defun integral-plm (p ds &optional vector) 
  (if vector (transform-plm #'sqrt-function (summarize-plm p ds 'integral #'vector-sum nil vector)) (summarize-plm p ds 'integral #'vector-sum)) 
)

; -----------------------------------------------------------
; Compute (approximate) maximization across one dimension of a PLM

; Returns true no matter what the argument
(defun arg-true (dummy)
  (or dummy (not dummy)))

; Return maximum function for a region r along a dimension d
(defun maximize-region (r d &optional piecewise-constant)
  (if piecewise-constant
      (region-constant r)
    (let* ((d+1 (+ d 1))
           (f-new (extract-function r))
           )
      ; Add weighted value for d to constant and set d's weight to 0
      ; Use smallest value in region if weight is negative, otherwise use largest
      ; If use largest subtract 1 for discrete variables and epsilon2 for continuous
      (when (numberp (aref f-new d+1))
        (unless (zerop (aref f-new d+1))
          (setf (aref f-new 0) (+ (aref f-new 0) (* (aref f-new d+1)
                                                    (if (< (aref f-new d+1) 0)
                                                        (region-min r d)
                                                      (- (region-max r d)
                                                         (if (region-discrete r d) 1 epsilon2)))))) ; Region open at top
          (setf (aref f-new d+1) 0)
          )
        )
      f-new))
  )

; Return element(s) of dimension d in region r that generate(s) the maximum function value
(defun maximal-elements-region (r d)
  (let ((w (region-weight r d)))
    (cond ((or (not (numberp w)) ; If there is no weight on the dimension (so function does not vary over d)
               (e= w 0)) ; or the weight is (epsilon equal to) 0
           (list (region-min r d) (region-max r d))) ; The entire region is maximal (f doesn't depend on d)
          ((> w 0) ; Weight is positive (return a small region just below maximum, since top of region is open)
           (list (- (region-max r d) (if (region-discrete r d) 1 epsilon2))
                 (region-max r d))) ; Highest value is at high end
          (t ; Weight is negative (return small region starting at minimum, since bottom of region is closed)
           (list (region-min r d) (+ (region-min r d) (if (region-discrete r d) 1 epsilon2)))) ; Highest value is at small end
          )
    )
  )

; Compute weighted average of two numbers
(defun average (n1 n2 w1 w2)
  (when (equal (+ w1 w2) 0)
    (error "~&Trying to compute weighted average with 0 weights")
    )
  (/ (+ (* w1 n1) (* w2 n2)) (+ w1 w2)))

; Compute weighted average of two vectors
(defun vector-average (v1 v2 w1 w2)
  (let* ((rank (length v1))
         (va (init-vector rank))
         )
    (dotimes (i rank)
      (setf (aref va i) (average (aref v1 i) (aref v2 i) w1 w2))
      )
    va)
  )

; Determine which function, if either, dominates a region
; Find extreme points for each function and compare
(defun dominates-region (f1 f2 r &optional piecewise-constant)
  (if piecewise-constant
      (if (> f1 f2)
          f1
        (if (> f2 f1)
            f2
          nil))
    (let* ((minp1 (region-mins r)) ; Maximum point in region along all dimensions
           (maxp1 (region-maxs r)) ; Minimum point in region along all dimensions
           (minp2 minp1) ; Copies
           (maxp2 maxp1)
           d+1 temp f1min f1max f2min f2max
           )
      (if (and (function-constantp f1) (function-constantp f2)) ; Special case where both functions are constant
          (cond ((> (aref f1 0) (aref f2 0)) f1)
                ((> (aref f2 0) (aref f1 0)) f2)
                (t nil)
                )
        (progn
          (dotimes (d (region-rank r))
            (setq d+1 (1+ d))
      ; If the coefficient of a dimension is negative, swap the min and max points along that dimension
            (when (< (aref f1 d+1) 0)
              (setq temp (aref minp1 d+1))
              (setf (aref minp1 d+1) (aref maxp1 d+1))
              (setf (aref minp1 d+1) temp)
              )
            (when (< (aref f2 d+1) 0)
              (setq temp (aref minp2 d+1))
              (setf (aref minp2 d+1) (aref maxp2 d+1))
              (setf (aref minp2 d+1) temp)
              )
            (setq f1min (linear-value f1 minp1))
            (setq f1max (linear-value f1 maxp1))
            (setq f2min (linear-value f2 minp2))
            (setq f2max (linear-value f2 maxp2))
            )
          (cond ((or (and (e> f1min f2min)
                          (e>= f1max f2max)
                          )
                     (and (e>= f1min f2min)
                          (e> f1max f2max)
                          )
                     )
                 f1)
                ((or (and (e> f2min f1min)
                          (e>= f2max f1max)
                          )
                     (and (e>= f2min f1min)
                          (e> f2max f1max)
                          )
                     )
                 f2)
                (t nil)
                )
          ))
      ))
  )

; Compute the (approximate) maximization over two regions
(defun maximum-region (rnew fnew fold d nr extents ei &optional omit-maximals prev-max-ds piecewise-constant)
  (let ((maxf fold) ; Cumulate maximum function
        dominates ; Result of checking region in iteration against cumulative for domination
        rnew-extent ; Extent of new region along d
        )
    (setq dominates (dominates-region fnew fold rnew piecewise-constant))
    (cond ((eq dominates fnew) ; If function for region dominates current max
           (setq maxf fnew) ; Set maximum function to function for region
           (unless omit-maximals
             (setf (aref (region-maximals nr) d)
                   (list (maximal-elements-region rnew d))) ; Set dimension's maximal element to that of the region
             )
           ; Copy maximals for previous maximized dimensions
           (dolist (md prev-max-ds)
             (setf (aref (region-maximals nr) md) (aref (region-maximals rnew) md))
             )
           )
          ((null dominates) ; If neither function dominates
           (if piecewise-constant
               (setq maxf fold)
             (progn
               (setq rnew-extent (dimension-extent d rnew))
               (setf (apply #'aref extents ei) (+ (apply #'aref extents ei) rnew-extent))
               (setq maxf (vector-average fold fnew (apply #'aref extents ei) rnew-extent))
               ))
           ; The following is right if both regions have same constant value, but not sure
           ; what should do if really two crossing line segments
           (unless omit-maximals
             (setf (aref (region-maximals nr) d) ; Add region's maximal element to list
                   (cons (maximal-elements-region rnew d) (aref (region-maximals nr) d)))
             )
             ; Do we need to do anything about copying maximals from other dimensions here, as is done above?
           )
          )
    maxf)
  )

; Maximize over one dimension of a PLM, yielding a new PLM
; Doesn't actually eliminate the dimension from the PLM, but makes it inactive
; prev-max-ds is the previous dimensions over which maximized, and thus ones from which want to copy maximals
(defun maximize-plm (p d &optional omit-maximals prev-max-ds)
  (let* ((np (init-summarize-plm p d))
         (rarray (plm-array p))
         (rarrayn (plm-array np))
         (rank (plm-rank p))
         (sizev (dimension-sizes-v p))
         (sizev-1 (vector-1 sizev))
         (size (array-total-size rarray))
         (sizeln (dimension-sizes np))
         (sizen (array-total-size rarrayn))
         (maximums (make-array sizeln)) ; Stores maximums as function vectors
         (extents (make-array sizeln :initial-element 0))
         r ; Region
         rmaximum ; Region maximum
         ii ii0
         (piecewise-constant (plm-piecewise-constant p))
         rms ; Region maximals
         )
    (when trace-summarize
      (format trace-stream "~&~%MAX")
      (format trace-stream "~&~%P: ") (print-plm p t trace-stream)
      (format trace-stream "~&~%MAX DIMENSION: ~S" d)
      )
    ; Compute the maximization over the regions in the PLM as function vectors in the variable (vector) maximums
    (setq ii (make-list rank :initial-element 0))
    (dotimes (i size)
      (setf r (row-major-aref rarray i))
      (setq rmaximum (maximize-region r d piecewise-constant))
      ; Zero the index along d
      (setq ii0 (copy-seq ii))
      (setf (nth d ii0) 0)
      ; Maximize region
      (setf (apply #'aref maximums ii0) (if (apply #'aref maximums ii0)
                                            (maximum-region r rmaximum (apply #'aref maximums ii0) d (apply #'aref rarrayn ii0) extents ii0 omit-maximals prev-max-ds piecewise-constant)
                                         (progn
                                           (unless omit-maximals
                                             (setq rms (region-maximals (apply #'aref rarrayn ii0)))
                                             ; Copy maximals for previous maximized dimensions
                                             (dolist (md prev-max-ds)
                                               (setf (aref rms md) (aref (region-maximals r) md))
                                               )
                                            ; Set dimension's maximal element to that of the region
                                           (setf (aref rms d)
                                                 (list (maximal-elements-region r d)))
                                           )
                                         rmaximum)))
      (setq ii (next-index-list ii sizev-1 rank))
      )
    ; Assign functions to new regions
    (dotimes (i sizen)
      (assign-function (row-major-aref maximums i) (row-major-aref rarrayn i) piecewise-constant)
      )
    (setf (aref (plm-active np) d) nil)
    (when trace-summarize
      (format trace-stream "~&~%MAX RESULT: ") (print-plm np t trace-stream)
      )
    (when (plm-piecewise-constant p)
      (setf (plm-piecewise-constant np) t)
      )
    np)
  )

; -----------------------------------------------------------
; Compute value of function at one point along specified dimension

; Extract function of region if locations are within region along dimension ds
(defun extract-value-region (r ds locations &optional piecewise-constant)
  (let ((in-region t))
    (do ((dl ds (cdr dl))
         (ll locations (cdr ll)))
        ((or (null dl) (null ll)) nil)
      (unless (and (e>= (car ll) (region-min r (car dl)) t)
                   (e< (car ll) (region-max r (car dl)))
                   )
        (setq in-region nil)
        (return)
        )
      )
    (when in-region
      (extract-function r piecewise-constant)
      )
    )
  )

; Combine extracted functions for regions
(defun extract-value-combine (f1 f2 &optional piecewise-constant)
  piecewise-constant ; Dummy to avoid warning message
  (if f1 f1 f2)
  )

; Find function at specified location over one dimension of a PLM, yielding a new PLM
; Doesn't actually eliminate the dimension from the PLM, but makes it inactive
(defun extract-value-plm (p ds locations)
  (when (numberp locations) (setq locations (list locations)))
  (summarize-plm p ds 'extract-value #'extract-value-combine locations)
  )

; -----------------------------------------------------------
; Normalize a PLM
; If a specific dimension is mentioned, normalize along that one
; Otherwise if there is a single unique dimension, normalize along it
; Otherwise signal an error

; Assumes that weights on the other dimensions are all 0, so that can normalize by dividing by a constant

; Find the non-multiple dimensions (error if none)
(defun unique-dimensions (p &optional no-error-if-no-unique)
  (let (uds) ; Unique dimensions
    (dotimes (i (plm-rank p))
      (when (non-multiple-variable (aref (plm-variables p) i))
        (setq uds (cons i uds))
        )
      )
    (when (and (not no-error-if-no-unique) ; Error if there is no unique dimension
               (not uds) ; There is no unique dimension
               )
      (error "No unique dimension in PLM with variables ~S in call to unique-dimensions." (plm-variables p))
      )
    uds)
  )

; Given a PLM, normalize it along specified (or unique) dimension(s)
(defun normalize-plm (p &optional nds destructive vector); 
  (let (ip
        (ds (if nds nds (unique-dimensions p)))
        integral ; Result of integration out unique dimensions
        )
    (when trace-transform
      (format trace-stream "~&~%NORMALIZE:")
      (format trace-stream "~&~%P: ") (print-plm p symbolic-trace trace-stream)
      (format trace-stream "~&~%NORMALIZE DIMENSION(S): ~S" ds)
      )
    (setq integral (integral-plm p ds vector)) 
    (setf (plm-active integral) (init-vector (plm-rank integral) t))
    (setq ip (combine-plms p nil integral 'divide-0 nil nil nil destructive))
    (when trace-transform
      (format trace-stream "~&~%NORMALIZE RESULT: ") (print-plm ip symbolic-trace trace-stream)
      )
    ip)
  )

; -----------------------------------------------------------
; Compute the span along the dimension(s) specified that is above the smoothing paramter
; Used in subtractive normalization of a PLM

; Determine minimum point in region as a vector
; This is not the value at the point, but just the point at the dimension mins
(defun minimum-point (r)
  (let* ((rank (region-rank r))
         (mp (init-vector (+ rank 1)))
         )
    (setf (aref mp 0) 1) ; Value in point for constant (location 0) is always 1
    (dotimes (i rank)
      (setf (aref mp (+ i 1)) (region-min r i))
      )
    mp)
  )

; Determine maximum point in region as a vector
; This is not the value at the point, but just the point at the dimension maxs
(defun maximum-point (r)
  (let* ((rank (region-rank r))
         (mp (init-vector (+ rank 1)))
         )
    (setf (aref mp 0) 1) ; Value in point for constant (location 0) is always 1
    (dotimes (i rank)
      (setf (aref mp (+ i 1)) (region-max r i))
      )
    mp)
  )

; Determine extreme value in a region
(defun region-extreme (r relation)
  (let* ((min (minimum-point r))
         (max (maximum-point r))
         (rank (region-rank r))
         (fun (region-weights r rank nil))
         (min-val (linear-value fun min))
         (max-val (linear-value fun max))
        )
    (if (funcall relation min-val max-val) min-val max-val)
    )
  )

; Determine if the function in the region is above the smoothing parameter
(defun region-above-threshold-p (r smooth)
  (e> (region-extreme r #'<) smooth)
  )

; Compute volume of region along dimensions
(defun region-volume-ds (r ds)
  (if (numberp ds)
      (region-span r ds)
    (let ((volume 1))
      (dotimes (i (length ds))
        (setq volume (* volume (region-span r (nth i ds))))
        )
      volume))
  )

; Compute span-above threshold for a region
; If the region is above threshold, get volume along dimensions, otherwise 0
(defun span-above-threshold-region (r ds smooth &optional piecewise-constant)
  (if piecewise-constant
      (if (e> (region-constant r) smooth)
          (region-volume-ds r ds)
        0)
    (let ((wv (init-vector (1+ (length (region-dimensions r))) 0)))
      (when (region-above-threshold-p r smooth)
        (setf (aref wv 0) (region-volume-ds r ds))
        )
      wv))
  )

; Compute the span along the dimension(s) specified that is above the smoothing paramter
(defun span-above-threshold-plm (p ds smooth)
  (summarize-plm p ds 'span-above-threshold #'vector-sum smooth)
  )

; -----------------------------------------------------------
; Subtractive normalize a PLM
; If a specific dimension is mentioned, normalize along that one
; Otherwise if there is a single unique dimension, normalize along it
; Otherwise signal an error

; Assumes that weights on the other dimensions are all 0, so that get a constant sum over normalization dimension

; Destructively threshold a PLM based on whether regions in another function are above threshold
; Assumes constant functions for use in subtractive normalization
(defun threshold-plm-destructive (testp modifyp threshold)
  (let* ((trarray (plm-array testp))
         (mrarray (plm-array modifyp))
         (tsize (array-total-size trarray))
         (msize (array-total-size mrarray))
         )
    (unless (= tsize msize)
      (error "Test and modify arrays not of same size in THRESHOLD-PLM-DESTRUCTIVE: ~S versus ~S" tsize msize)
      )
    (dotimes (i tsize)
      (when (<= (region-constant (row-major-aref trarray i)) threshold)
        (setf (region-constant (row-major-aref mrarray i)) 0)
        )
      )
    modifyp)
  )

; Determine subtractor region from integrals and spans
(defun compute-subtractor (ifun sfun &optional piecewise-constant)
  (if piecewise-constant
      (let (wv)
        (setq wv (if (zerop sfun) 0 (/ (- ifun 1) sfun)))
        wv)
    (let ((wv (init-vector (length ifun) 0)))
      (setf (aref wv 0) ; Set contant to to subtractor
            (if (zerop (aref sfun 0))
                0
              (/ (- (aref ifun 0) 1)
                 (aref sfun 0))))
      wv))
  )

; Given a PLM, subtractively normalize it along specified (or unique) dimension(s)
(defun subtractive-normalize-plm (p smooth &optional nds)
  (let* ((ip (copy-a-plm p))
        (d (if nds nds (unique-dimensions p)))
        (integral (integral-plm p d)) ; Result of integrating out unique dimensions
        (span (span-above-threshold-plm p d smooth))
        sp ; Subtractor PLM
        (btp (transform-plm #'boolean-threshold-function p smooth)) ; Boolean threshold version of p (which has a 0 value for any region <= smooth)
        )
    (when trace-transform
      (format trace-stream "~&~%SUBTRACTIVE NORMALIZE:")
      (format trace-stream "~&~%P: ") (print-plm p symbolic-trace trace-stream)
      (format trace-stream "~&~%BOOLEAN THRESHOLD P (~S): " smooth) (pplm btp)
      (format trace-stream "~&~%SUBTRACTIVE NORMALIZE DIMENSION(S): ~S" d)
      (format trace-stream "~&~%INTEGRAL ALONG NORMALIZE DIMENSION(S): ") (pplm integral)
      (format trace-stream "~&~%SPAN ALONG NORMALIZE DIMENSION(S): ") (pplm span)
      )
    (setq sp (combine-plms integral nil span 'compute-subtractor nil nil t)) ; Keep "unneeded" slices
    (when trace-transform
          (format trace-stream "~&~%SUBTRACTOR ALONG NORMALIZE DIMENSION(S): ") (pplm sp)
          )
    (setq sp (product-plms sp btp))
    (when trace-transform
          (format trace-stream "~&~%FULL THRESHOLDED SUBTRACTOR: ") (pplm sp)
          )
    (setq ip (combine-plms p nil sp 'difference)) 
    (when trace-transform
      (format trace-stream "~&~%SUBTRACTIVE NORMALIZE RESULT: ") (print-plm ip symbolic-trace trace-stream)
      )
    (remove-unneeded-slices ip))
  )

; -----------------------------------------------------------
; Compute expected value of a PLM
; If a specific dimensions are mentioned, compute expectations along them
; Otherwise if there are unique dimensions, compute expectations along them
; Otherwise signal an error

; As with normalize-plm, assumes that weights on the other dimensions are all 0, so that can normalize by dividing by a constant

; A continuous point starting at x and going for epsilon2
(defun continuous-point (x)
  (list x (+ x epsilon2))
  )

; Return element in region r (along dimension that has been eliminated) that generates the expected function value
(defun expected-element-region (r)
  (continuous-point (region-constant r))
  )

; Compute the expected value of a region along a dimension
; Does this need to be extended for exponential functions?
(defun expected-value-region (r d)
  (let (ct ; Coefficient term
        (wv (init-vector (1+ (region-rank r)) 0))
        )
    (setq ct (* (/ (region-constant r) 2)
                (- (expt (region-max r d) 2)
                   (expt (region-min r d) 2))
                ))
    (unless (e= (region-weight r d) 0) ; There is a coefficient for this dimension
      (setq ct (+ ct (* (/ (region-weight r d) 3)
                        (- (expt (region-max r d) 3)
                           (expt (region-min r d) 3)
                           )
                        )
                  ))
      )
    (setf (aref wv 0) ct)
    wv)
  )

; Compute the expected value of the non-multiple variable of a plm
; Only appropriate when the non-multiple dimension is numeric and there is only one of them
; If assign-maximals is true, put the expected value into the maximals for the dimension
; Eventually generalize summarize-plm to handle this?
(defun expected-value-plm (p &optional d assign-maximals)
  (let* ((rarray (plm-array p))
         (rank (plm-rank p))
         (sizev (dimension-sizes-v p))
         (sizev-1 (vector-1 sizev))
         (size (array-total-size rarray))
         (np (init-summarize-plm p d))
         (rarrayn (plm-array np))
         (sizeln (dimension-sizes np))
         (sizen (array-total-size rarrayn))
         (expecteds (make-array sizeln))
         r nr ; Regions
         rexpected ; Region integral
         ii ii0 ; Index list
         )
    (unless d (setq d (car (unique-dimensions p))))
    ; Error message if dimension is non-numeric
    (unless (stype-numeric (svariable-type (aref (plm-variables p) d))) ; When dimension not numeric
      (pplm p)
      (error "Attempt to compute expected value along non-numeric dimension ~S of PLM."
             (svariable-name (aref (plm-variables p) d))
             )
      )
    (when trace-summarize
      (format trace-stream "~&~%EXPECTED VALUE")
      (format trace-stream "~&~%P: ") (print-plm p symbolic-trace trace-stream)
      (format trace-stream "~&~%EXPECTED VALUE DIMENSION: ~S" d)
      )
    ; Compute the expected value over the regions in the PLM as function vectors in the variable (vector) expecteds
    (setq ii (make-list rank :initial-element 0))
    (dotimes (i size)
      ; Set the dth index to 0
      (setq ii0 (copy-seq ii))
      (setf (nth d ii0) 0)
      (setf r (row-major-aref rarray i))
      (setq rexpected (expected-value-region r d))
      (setf (apply #'aref expecteds ii0) (if (apply #'aref expecteds ii0) (apply #'vector-sum rexpected (list (apply #'aref expecteds ii0))) rexpected))
      (setq ii (next-index-list ii sizev-1 rank))
      )
    ; Assign functions to new regionsh (and maximals if not omitted)
    (dotimes (i sizen)
      (setq nr (row-major-aref rarrayn i))
      (assign-function (row-major-aref expecteds i) nr)
      ; Set up the maximals with the expected point
      (when assign-maximals
        (setf (aref (region-maximals nr) d) (list (expected-element-region nr)))
        )
      )
    ; Make summarised dimension inactive
    (setf (aref (plm-active np) d) nil)
    (when trace-summarize
      (format trace-stream "~&~%EXPECTED VALUE RESULT: ") (print-plm np symbolic-trace trace-stream)
      )
    (when (plm-piecewise-constant p)
      (setf (plm-piecewise-constant np) t)
      )
    np)
  )

; -----------------------------------------------------------
; Make PLM's functional value explicit along the designated variable
; I.e., set the appropriate region (starting at the fraction along the dimension specified by the functional value) along the variable to 1 and everything else to 0

; Create an explicit cpt entry for one region
(defun explicit-cpt-entry (r nd rank vs)
  (let (cpt position vt lv)
    (dotimes (j rank)
      (setq vt (svariable-type (aref vs j)))
      (if (= j nd)
          (progn
            (setq lv (linear-value (extract-function r) (region-mids r)))
            (when (> lv 1)
              (error "Attempt to create an explicit representation of a functional value greater than 1: ~S" lv)
              )
            (setq position (* lv (stype-span vt)))
            (when (stype-discrete vt)
              (setq position (floor position))
              (when (= position (stype-max vt))
                (setq position (1- position)) ; Let a fraction of 1 still yield the highest discrete value
                )
              )
            (setq position (+ (stype-min vt) position)) ; start at min, rather than necessarily at 0
            (push (if (stype-discrete vt)
                      (list position (1+ position))
                    (progn
                      (setq position (min position (- (stype-max vt) epsilon2))) ; Make sure position leaves room for width of continuous region
                      (list position (+ position epsilon2)))) cpt)
            )
        (push (list (region-min r j) (region-max r j)) cpt))
      )
    (cons 1 (reverse cpt)))
  )

; Make PLM's functional value explicit along the designated variable
(defun explicit-plm (p nd)
  (let* (ep
         (rarray (plm-array p))
         (rank (plm-rank p))
         (size (array-total-size rarray))
         cpt-list ; List of region descriptions to turn into a PLM
         (vs (plm-variables p))
         )
    (when trace-transform
      (format trace-stream "~&~%EXPLICIT:")
      (format trace-stream "~&~%P: ") (print-plm p symbolic-trace trace-stream)
      (format trace-stream "~&~%EXPLICIT DIMENSION: ~S" nd)
      )
    ; Generate a list of explicit cpt entries, one per region
    (dotimes (i size)
      (setq cpt-list (cons (explicit-cpt-entry (row-major-aref rarray i) nd rank vs) cpt-list))
      )
    (setq ep (cpt-function-array-plm (variable-names vs) cpt-list vs 0))
    (when trace-transform
      (format trace-stream "~&~%EXPLICIT RESULT: ") (print-plm ep symbolic-trace trace-stream)
      )
    (setq ep (remove-unneeded-slices ep))
    (when trace-transform
      (format trace-stream "~&~%EXPLICIT RESULT (WITH UNNEEDED SLICES REMOVED): ") (print-plm ep symbolic-trace trace-stream)
      )
    (when (plm-piecewise-constant p)
      (setf (plm-piecewise-constant ep) t)
      )
    ep)
  )

; -----------------------------------------------------------
; Smooth a PLM

; Destructively smooth a piecewise constant PLM
(defun smooth-plm (p minimum)
  (let ((rarray (plm-array p))
        r)
    (dotimes (i (array-total-size rarray))
      (setq r (row-major-aref rarray i))
      (when (< (region-constant r) minimum)
        (setf (region-constant r) minimum)
        )
      )
    p)
  )

; -----------------------------------------------------------
; Determine extreme value in a PLM

; Determine extreme value in PLM given relation and largest possible value in other direction
(defun plm-extreme (p relation sofar)
  (let ((nrarray (plm-array p))
        r-ex)
    (dotimes (i (array-total-size nrarray))
      (setq r-ex (region-extreme (row-major-aref nrarray i) relation))
      (when (funcall relation r-ex sofar)
        (setq sofar r-ex)
        )
      )
    sofar)
  )

; -----------------------------------------------------------
; Average a PLM
; Create a new PLM from an existing one, replacing every region value with the average
; value for dimension along which are averaging

; Given a PLM, average it along specified dimension
(defun average-plm (p d)
  (let (ip)
    (when trace-average
      (format trace-stream "~&Function to average (over dimension ~A): " d)
      (pplm p)
      )
    (setq ip (combine-plms (integral-plm p d) nil (summarize-plm p d 'volume #'vector-sum) 'divide))
    (when trace-average
      (format trace-stream "~&Average function: ")
      (pplm ip)
      )
    ip)
  )

; Average a PLM over a list of dimensions
(defun average-plm-ds (p ds)
  (dolist (d ds)
    (setq p (average-plm p d))
    )
  p)

; -----------------------------------------------------------
; Compute transform of a PLM
; I.e., apply a function to values within each region

; Invert value
; For values in [0,1] get 1-v, for values >1 get 0
(defun invert-value (value)
  (if (e> value 1) ; Handle fact that the weight may be greater than 1
      0
    (- 1 value))
  )

; Invert a function (yielding 1-f)
; Subtracts constant from one and multiplies coefficients by -1.
; Yields a constant 0 if the value of the function can be >1 anywhere in region
(defun invert-function (f r &optional piecewise-constant)
  (if piecewise-constant
      (if (> f 1) 0 (- 1 f))
    (let* ((rank (length f))
           (nf (init-vector rank 0))
           d+1)
      (unless (or (> (linear-value f (region-mins r)) 1)
                  (> (linear-value f (region-maxs r)) 1)
                  )
        (setf (aref nf 0) (- 1 (aref f 0)))
        (dotimes (d (- rank 1))
          (setq d+1 (+ d 1))
          (setf (aref nf d+1) (- (aref f d+1)))
          )
        )
      nf))
  )

; Variation on invert-function that acts as if all positive regions are 1
; To do this completely correctly, may need to check if there is an epsilon subregion
; at the edge that is 0, split it off and make it 1 in the inverse.
; But this isn't done at the moment.
(defun invert-function-variant (f r &optional piecewise-constant)
  (if piecewise-constant
      (if (e= f 0) 1 0)
    (let* ((rank (length f))
           (nf (init-vector rank 0)))
      (if (region-e-empty r piecewise-constant)
          (setf (aref nf 0) 1)
        (setf (aref nf 0) 0)
        )
      nf))
  )

; Multiply function by scaling factor
(defun scale-function (f r scale &optional piecewise-constant)
  (if piecewise-constant
      (if (or (zerop f) (zerop scale))
          0
        (if (= f 1)
            scale
          (if (= scale 1)
              f
            (* scale f))))
    (let* ((rank (length f))
           (nf (init-vector rank 0)))
      r ; dummy so no warning about r not being used
      (dotimes (d rank)
        (setf (aref nf d) (* scale (aref f d)))
        )
      nf))
  )

; Negate function (multiply by -1)
(defun negate-function (f r &optional piecewise-constant)
  (scale-function f r -1 piecewise-constant)
  )
    
;; Add value to function
(defun add-to-function (f r value &optional piecewise-constant)
  (if piecewise-constant
      (if (zerop f)
          value
        (if (zerop value)
            f
          (+ f value)))
    (let ((nf (copy-seq f)))
      r ; dummy so no warning about r not being used
      (setf (aref nf 0) (+ (aref f 0) value))
      nf))
  )

; Compute exponential of function (just marking as exponential)
(defun exponentiate-function (f nr)
  (setf (region-exponential nr) t)
  f)

; Compute exponential of function (actually exponentiating the constant while ignore dimension weights)
(defun exponentiate-constant-function (f r &optional piecewise-constant)
  (if piecewise-constant
      (exp f)
    (let (nf)
      r ; dummy so no warning about r not being used
      (setq nf (init-vector (length f) 0))
      (setf (aref nf 0) (exp (aref f 0)))
      nf))
  )

; Compute exponential of (* function 10) (actually exponentiating 10 times the constant while ignore dimension weights)
; If function already normalized, get exponentials of 0-10
(defun exponentiate-constant-times10-function (f r &optional piecewise-constant)
  (if piecewise-constant
      (exp (* f 10))
    (let (nf)
      r ; dummy so no warning about r not being used
      (setq nf (init-vector (length f) 0))
      (setf (aref nf 0) (exp (* (aref f 0) 10)))
      nf))
  )

; Determine whether a function (represented as a vector) is zero
(defun function-zero (f &optional piecewise-constant)
  (if piecewise-constant
      (e= f 0)
    (every #'(lambda (x) (e= x 0)) f))
  )

; Make constant function Boolean based on a threshold (1 if above threshold, 0 otherwise)
(defun boolean-threshold-function (f r threshold &optional piecewise-constant)
  (if piecewise-constant
      (if (<= f threshold) 0 1)
    (let ((nf (init-vector (length f) 0)))
      r ; dummy so no warning about r not being used
      (unless (<= (aref f 0) threshold)
        (setf (aref nf 0) 1)
        )
      nf))
  )

; Actually convert a constant function to its exponential
(defun actually-exponentiate-function (f &optional piecewise-constant)
  (if piecewise-constant
      (if (zerop f) 0 (exp f))
    (let ((nf (init-vector (length f) 0)))
      (when (not (= (aref f 0) 0)) ; Leave value 0 if it is so no chance of selecting a 0 option
        (setf (aref nf 0) (exp (aref f 0)))
        )
      nf))
  )

; Convert function to Boltzmann
(defun boltzmann-function (f r &optional piecewise-constant)
  r ; dummy so no warning about r not being used
  (actually-exponentiate-function (scale-function f nil (if arousal (* arousal one-over-temperature) one-over-temperature) piecewise-constant) piecewise-constant)
  )

; Make function Boolean (1 if non-zero, 0 otherwise)
(defun boolean-function (f r &optional piecewise-constant)
  (if piecewise-constant
      (if (e= f 0) 0 1)
    (let ((nf (init-vector (length f) 0)))
      r ; dummy so no warning about r not being used
      (unless (function-zero f)
        (setf (aref nf 0) 1)
        )
      nf))
  )

; Transform region by function
(defun transform-region (function r &optional nr parameter use-nr piecewise-constant)
  (assign-function (if (and parameter use-nr)
                       (funcall function (extract-function r piecewise-constant) nr parameter piecewise-constant)
                     (if parameter
                         (funcall function (extract-function r piecewise-constant) r parameter piecewise-constant)
                       (if use-nr
                           (funcall function (extract-function r piecewise-constant) nr piecewise-constant)
                         (funcall function (extract-function r piecewise-constant) r piecewise-constant))))
                   (if nr nr r) piecewise-constant)
  )

; Given a PLM, transform the values of its regions via the specified function
; Parameter is a parameter of the function
; Use-nr determines if pass the new region to the function for modification
(defun transform-plm (function p &optional parameter use-nr destructive)
  (cond (destructive
         (let ((rarray (plm-array p))
               (piecewise-constant (plm-piecewise-constant p)))
           (when trace-transform
             (format trace-stream "~&~%Destructively apply ~S to function: " function) (print-plm p t trace-stream)
             )
           (dotimes (i (array-total-size rarray))
             (transform-region function (row-major-aref rarray i) nil parameter nil piecewise-constant)
             )
           (when trace-transform
             (format trace-stream "~&~%Result of transform: " function) (print-plm p t trace-stream)
             )
           p)
         )
        (t
         (let* ((rarray (plm-array p))
                (ip (init-plm-from-plm p))
                (irarray (plm-array ip))
                (piecewise-constant (plm-piecewise-constant p)))
           (when trace-transform
             (format trace-stream "~&~%Apply ~S to function: " function) (print-plm p t trace-stream)
             )
           (dotimes (i (array-total-size rarray))
             (transform-region function (row-major-aref rarray i) (row-major-aref irarray i) parameter use-nr piecewise-constant)
             )
           (when trace-transform
             (format trace-stream "~&~%Result of transform: " function) (print-plm ip t trace-stream)
             )
           (setf (plm-piecewise-constant ip) piecewise-constant) ; This assumes that the transform function doesn't convert a constant function to a linear one
           ip)
         )
        )
  )


; -----------------------------------------------------------
; Create a non-destructive copy of a PLM

; Copy a list of slices
(defun copy-slice-list (sl)
  (mapcar #'copy-slice sl)
  )

; Copy a slice vector
(defun copy-slice-vector (sv)
  (let* ((rank (length sv))
         (nsv (init-vector rank)) ; New slice vector
        )
  (dotimes (i rank)
    (setf (aref nsv i) (copy-slice-list (aref sv i)))
    )
  nsv)
  )

; Create a vector of slice vectors from a vector of slice lists
(defun slice-vector-vector (slice-vector-list)
  (let* ((rank (length slice-vector-list))
         (svv (init-vector rank))
         size sl sv)
    (dotimes (i rank)
      (setq sl (aref slice-vector-list i))
      (setq size (length sl))
      (setq sv (init-vector size))
      (setf (aref svv i) sv)
      (dolist (s sl)
        (setf (aref sv (slice-index s)) s)
        )
      )
    svv)
  )

; Create a vector of dimensions with size of each dimension
(defun dimension-sizes-from-slices (slices)
  (let* ((rank (length slices))
         (v (init-vector rank))
         )
    (dotimes (i rank)
      (setf (aref v i) (if (aref slices i)
                           (1- (length (aref slices i)))
                         0))
      )
    v)
  )

; Vector of array dimensions
(defun array-dimensions-v (a)
  (coerce (array-dimensions a) 'vector)
  )

; Create a vector of dimensions with size of each dimension
(defun dimension-sizes-v (p)
  (array-dimensions-v (plm-array p))
  )

; Create a list of dimensions with size of each dimension
(defun dimension-sizes (p)
  (array-dimensions (plm-array p))
  )

; Create a vector of dimension multipliers for row-major indexing
(defun dimension-multipliers (maxes)
  (let* ((rank (length maxes))
         (rank-1 (1- rank))
         (v (init-vector rank))
         j j1
         )
    (dotimes (i rank)
      (setq j (- rank-1 i))
      (setq j1 (1+ j))
      (setf (aref v j) (if (zerop i) 1 (* (aref v j1) (aref maxes j1))))
      )
    v)
  )

; Compute row-major address given index vector
(defun row-major-index (index mults)
  (let* ((rmi 0)
         (rank (length index))
         )
    (dotimes (i rank)
      (setq rmi (+ (* (aref index i) (aref mults i)) rmi))
      )
    rmi)
  )

; Compute index vector from row-major index
(defun index-from-row-major (rmi mults rank)
  (let (i rem (v (init-vector rank)))
    (dotimes (d rank)
      (multiple-value-setq (i rem) (floor (/ rmi (aref mults d))))
      (setf (aref v d) i)
      (setq rmi (* rem (aref mults d)))
      )
    v)
  )

; Create a vector relating row-major indices to index vectors
; sizev is a vector with the length of each of the array's dimensions
; size is the total number of elements in the array
; Rank is the number of dimensions of the array
; (Why can't the second and third argument be derived from the first?)
(defun row-major-vector (sizev size rank)
  (if (= rank 0)
      nil
    (let* ((v (init-vector size)) ; Result
          (ci (init-vector rank 0)) ; Current index vector
          (rank-1 (1- rank))
          r-1-j ; rank - (j + 1)
          )
      (dotimes (i size) ; Cycle through all row-major indices
        (setf (aref v i) (copy-seq ci))
        (dotimes (j rank) ; Cycle through all dimensions of vector index
          (setq r-1-j (- rank-1 j)) ; Proceed from right rather than left
          (if (< (aref ci r-1-j) (1- (aref sizev r-1-j))) ; If index at position is in bounds
              (return) ; Done generating vector index for this row-major index
            (setf (aref ci r-1-j) 0)) ; Else, zero index at position and move on to next index position
          )
        (setf (aref ci r-1-j) (1+ (aref ci r-1-j))) ; Increment index at position
        )
      v))
  )

; Copy the contents of one region to another
(defun copy-region-contents (from to)
  (setf (region-constant to) (region-constant from))
  (setf (region-maximals to) (copy-seq (region-maximals from)))
  (setf (region-evidence to) (region-evidence from))
  (setf (region-exponential to) (region-exponential from))
  (let ((rds (region-dimensions from)) (nrds (region-dimensions to)))
    (dotimes (d (length rds))
      (setf (dimension-weight (aref nrds d)) (dimension-weight (aref rds d)))
      )
    )
  to)

; Copy a PLM
(defun copy-a-plm (p)
  (let* ((rank (plm-rank p))
         (np (init-plm-from-plm p))
         (nprarray (plm-array np))
         (prarray (plm-array p))
         )
    (if (zerop rank)
        (let ((or (plm-origin p)))
          (setf (plm-array np) (make-array nil))
          (setf (aref (plm-array np)) (make-region :constant (region-constant or)
                                                   :exponential (region-exponential or)
                                                   :evidence (region-evidence or)
                                                   :dimensions (init-vector rank)))
          (setf (plm-slices np) (init-vector 0))
          )
      (progn
        ; Copy content of regions
        (dotimes (i (array-total-size nprarray))
          (copy-region-contents (row-major-aref prarray i) (row-major-aref nprarray i))
          )
        ))
    (when (plm-piecewise-constant p)
      (setf (plm-piecewise-constant np) t)
      )
    (when (plm-removed-unneeded-slices p)
      (setf (plm-removed-unneeded-slices np) t)
      )
    np)
  )

; -----------------------------------------------------------
; Reverse one dimension of a PLM (currently destructive)

; Reverse a single region
(defun reverse-region (r d)
  (let ((dd (aref (region-dimensions r) d))
        temp)
    ; Swap the dimension's min-slice and max-slice
    (setq temp (dimension-min-slice dd))
    (setf (dimension-min-slice dd) (dimension-max-slice dd))
    (setf (dimension-max-slice dd) temp)
    r)
  )

; Reverse one dimension of a PLM, yielding a new PLM
(defun reverse-plm (p d)
  (let* ((rarray (plm-array p))
         (rank (plm-rank p))
         (sizev (dimension-sizes-v p))
         (sizev-1 (vector-1 sizev))
         (nrarray (make-array (coerce sizev 'list)))
         ii iir ; Index list
         r ; Original region
         (d-1 (1- (aref sizev d)))
         (slices (plm-slices p))
         )
    (setq ii (make-list rank :initial-element 0))
    (dotimes (i (array-total-size rarray))
      (setq r (apply #'aref rarray ii))
      (reverse-region r d)
      (setq iir (copy-seq ii))
      (setf (nth d iir) (- d-1 (nth d ii))) ; Invert index along dimension
      (setf (apply #'aref nrarray iir) r)
      (setq ii (next-index-list ii sizev-1 rank))
      )
    (setf (plm-array p) nrarray) ; Switch to new region array
    ; Reverse slice list
    (setf (aref slices d) (reverse (aref slices d)))
    (index-slice-list-array (plm-slices p))
    p)
  )

; -----------------------------------------------------------
; Strip vestigial dimensions from a PLM and reorder it according to a map
; Destructively modifies PLM

; Create a new vector stripping off and reordering all dimensions but ones in map
(defun strip-and-reorder-vector (map nrank ovector)
  (let ((nvector (init-vector nrank)))
    (dotimes (d nrank)
      (setf (aref nvector d) (aref ovector (if map (aref (smap-vfactor map) d) d))))
    nvector)
  )

; Strip and reorder dimensions from a region of a PLM
(defun strip-and-reorder-region (map nrank r)
  (setf (region-dimensions r) (strip-and-reorder-vector map nrank (region-dimensions r)))
  r)

; Create an index for the original region array from one for the new one
(defun srr-original-index (ni map orank)
  (let ((oi (init-vector orank 0)))
    (dotimes (d (length ni))
      (setf (aref oi (if map (aref (smap-vfactor map) d) d)) (aref ni d))
      )
    oi)
  )

; Strip and reorder dimensions from regions of a PLM
; This operation is destructive in that it doesn't create a new PLM, but changes regions in place
(defun strip-and-reorder-regions (map nrank nsizev rarray)
  (if (zerop (array-rank rarray))
      rarray
    (let* ((nrarray (make-array (coerce nsizev 'list))) ; New region array
           (nsize (array-total-size nrarray)) ; Total size of new region array
;           (nmults (dimension-multipliers nsizev)) ; Dimension multipliers for row major index
           (rank (array-rank rarray)) ; Rank of old region array
           (nsizev-1 (vector-1 (array-dimensions-v nrarray)))
           niv
           )
      (setq niv (init-vector nrank 0))
      (dotimes (i nsize)
        (setf (row-major-aref nrarray i)
              (strip-and-reorder-region map nrank (if (zerop nrank)
                                                      (row-major-aref rarray 0)
                                                    (apply #'aref rarray (coerce (srr-original-index niv map rank) 'list)))))
        (setq niv (next-index-vector niv nsizev-1 nrank))
        )
      nrarray))
  )

; Strip dimensions from factor summary-product (PLM) not used in variable PLM
; The stripped dimensions should already be vestigial
; Also reorder the PLM according to the map and variables
(defun strip-and-reorder-plm (map vs p)
  (let* ((vrank (length vs))
         (nplm (make-plm :rank vrank :variables vs)))
    (setf (plm-active nplm) (strip-and-reorder-vector map vrank (plm-active p)))
    (setf (plm-slices nplm) (strip-and-reorder-vector map vrank (plm-slices p)))
    (setf (plm-array nplm) (strip-and-reorder-regions map vrank (map 'vector #'(lambda (sl) (1- (length sl))) (plm-slices nplm)) (plm-array p)))
    (when (or trace-combine trace-summarize trace-affine)
      (format trace-stream "~&~%PLM after stripping and reordering dimensions: ") (print-plm nplm symbolic-trace)
      )
    (when (plm-piecewise-constant p)
      (setf (plm-piecewise-constant nplm) t)
      )
    nplm)
  )

; -----------------------------------------------------------
; Combine dimensions for reused variables in a pattern, extracting the diagonal along dimensions

; Combine dimensions while testing for equality across them
; This is for handling variable reuse within a single pattern in a conditional
(defun factor-combined-dimensions (p np dns)
  (let ((new-slices (init-vector (plm-rank np)))
        (old-slices (plm-slices p)))
    ; Apply slices from each incoming variable in list to other incoming variables in list
    (dolist (i dns)
      (dolist (j dns)
;        (unless (= i j)
          (setf (aref new-slices j) (append (aref old-slices i) (aref new-slices j)))
;          )
        )
      )
    (setf new-slices (sort-slice-list-array new-slices))
    (delete-duplicates-slice-list-array new-slices)
    (setf np (apply-slices new-slices nil p))
    )
  )

; Determine if region is a diagonal along listed (by number) dimensions
(defun diagonal-region (r dns)
  (let ((diagonal t)
        bounds dims first-dim other-dim)
    (setq dims (region-dimensions r))
    (setq first-dim (aref dims (car dns)))
    (setq bounds (list (slice-location (dimension-min-slice first-dim)) (slice-location (dimension-max-slice first-dim))))
    (dolist (other-dn (cdr dns))
      (setq other-dim (aref dims other-dn))
      (when (or (not (e= (car bounds) (slice-location (dimension-min-slice other-dim)) t))
                (not (e= (cadr bounds) (slice-location (dimension-max-slice other-dim)) t))
                )
        (setq diagonal nil)
        )
      )
    diagonal)
  )

; Slice vector for result of diagonalize-plm
; All but first dimension of dns should just have extreme slices
(defun diagonal-slices (slices vars dns)
  (let* ((rank (length slices))
         (nsv (init-vector rank))
         (rdns (cdr dns))
         )
    (dotimes (d rank)
      (setf (aref nsv d)
            (if (member d rdns)
                (let ((vt (svariable-type (aref vars d))))
                  (list (make-slice :location (stype-min vt) :index 0) (make-slice :location (stype-max vt) :index 1))
                  )
              (copy-slice-list (aref slices d))))
      )
    nsv)
  )

; Create content of new diagonal region from old region
(defun diagonalize-region (r nr dns &optional piecewise-constant)
  (let ((ds (region-dimensions r))
        (nds (region-dimensions nr))
        )
    (setf (region-constant nr) (region-constant r))
    ; Copy dimension information
    (dotimes (d (length ds))
      (setf (dimension-discrete (aref nds d)) (dimension-discrete (aref ds d)))
      (setf (dimension-weight (aref nds d)) (dimension-weight (aref ds d)))
      )
    ; Add weight from all of the diagonalized dimensions to the first one
    (unless piecewise-constant
      (setf (dimension-weight (aref nds (car dns))) (reduce #'+ ds :key #'dimension-weight))
      )
    nr)
  )

; Create an index for the original array from an index for the diagonalized array
; This is destructive
(defun diag-original-index (ni dns)
  (let ((dv (aref ni (car dns)))) ; Domain element to be replicated along other diagonal dimensions
    (dolist (d (cdr dns))
      (setf (aref ni d) dv) ; Change new value, which should be 0, to the same old value for first dimension of diagonal
      )
    ni)
  )

; Extract diagonal from PLM along dimensions listed (by number)
; The regions along the diagonal should already be square along these dimensions
(defun diagonalize-plm (p dns)
  (let* ((rank (plm-rank p))
         (rarray (plm-array p))
         (nslices (diagonal-slices (plm-slices p) (plm-variables p) dns))
         (np (init-plm-with-slices (plm-variables p) 0 0 (init-vector rank t) nslices))
         (nrarray (plm-array np))
         (nsizev (dimension-sizes-v np))
         (nsizev-1 (vector-1 nsizev))
         niv
         (piecewise-constant (plm-piecewise-constant p))
         )
    (setq niv (init-vector rank 0))
    (dotimes (i (array-total-size nrarray))
      (diagonalize-region (apply #'aref rarray (coerce (diag-original-index niv dns) 'list)) (row-major-aref nrarray i) dns piecewise-constant)
      (setq niv (next-index-vector niv nsizev-1 rank))
      )
    (setf (plm-piecewise-constant np) piecewise-constant)
    np)
  )

; Destructively compute next index along diagonal
(defun next-diagonal-index (index dns)
  (let ((nv (1+ (aref index (car dns)))))
    (dolist (d dns)
      (setf (aref index d) nv)
      )
    index)
  )

; Destructively zero all of the diagonal regions of a shattered PLM (so square regions along diagonal)
(defun zero-diagonal (p dns)
  (let ((rarray (plm-array p))
        (index (init-vector (plm-rank p) 0))
        (piecewise-constant (plm-piecewise-constant p))
        r)
    (dotimes (i (array-dimension rarray (car dns)))
      (setq r (apply #'aref rarray (coerce index 'list)))
      (unless (region-e-empty r piecewise-constant)
        (empty-region r)
        )
      (setq index (next-diagonal-index index dns))
      )
    p)
  )

; Combine dimensions for reused variables in a pattern, extracting everything but the diagonal along dimensions
; This is to implement a not-equal (<>) test across variables in a single pattern
(defun inverse-diagonalize-plm (p dns)
  (dolist (d dns) ; Shatter PLM along all diagonalization dimensions so yield square regions along diagonal
    (setq p (shatter-plm p d))
    )
  (zero-diagonal p dns)
  )

; functions for sum product algorithm, queues, message initialization & messages processing 

; Queues
; ------

; Initialize a queue
(defun init-queue (&optional head)
  (let ((qhead (list head)))
    (make-queue :head qhead :tail qhead)
    )
  )

; Is a queue not empty?
(defun queue-empty (q)
  (not (queue-not-empty q))
  )

; Is a queue not empty?
(defun queue-not-empty (q)
  (cdr (queue-head q))
  )

; Length of a queue (without head)
(defun queue-length (q)
  (length (cdr (queue-head q)))
  )

; Messages in depth queues
(defun depth-queues-length nil
  (reduce #'+ (aref (graph-queues cg) depth-queues-index) :key #'queue-length)
  )

; Total messages in queue
(defun length-queues nil
  (+ (depth-queues-length)
     (queue-length (aref (graph-queues cg) other-queue-index))
     )
  )

; Get element off of front of queue
; queue-list will point to the element in front of the one to be removed (head, if the first element)
; (cdr queue-list) is the list starting with the element to be removed.
; (cadr queue-list) is the element to be removed.
; (cddr queue-list), if it exists, is the list that should follow queue-list after removal;
; otherwise queue-list becomes the tail of the new queue
(defun pop-queue (q)
  (let ((queue-list (queue-head q))
        element)
    (when (cdr queue-list) ; There is an item to be removed
      (unless (cddr queue-list) ; Removing the last item from the queue
        (setf (queue-tail q) queue-list))
      (setq element (cadr queue-list))
      (rplacd queue-list (cddr queue-list)))
    element)
  )

; Add an element to the back of a queue
(defun add-to-queue (element q &optional front)
  (let ((new-cdr (list element)))
    (cond (front ; Place at front of queue
           (rplacd new-cdr (cdr (queue-head q)))
           (rplacd (queue-head q) new-cdr)
           )
          (t ; Place at back of queue
           (rplacd (queue-tail q) new-cdr)
           (setf (queue-tail q) new-cdr)
           )
          )
    q)
  )

; Messages
; --------

; Retrieve a message from "from" and "to" node numbers
(defun message-from-numbers (from-num to-num)
  (let* ((from-node (node-from-number from-num))
         (to-node (node-from-number to-num))
         (link (link-from-nodes from-node to-node))
         )
    (if link
        (make-message :index (if (variable-nodep from-node) 0 1)
                      :link link
                      )
      nil)
    )
  )

; Retrieve a message function from "from" and "to" node numbers
(defun message-function-from-numbers (from-num to-num)
  (let ((from-node (node-from-number from-num))
         (to-node (node-from-number to-num))
         )
    (aref (link-contents (link-from-nodes from-node to-node))
          (if (variable-nodep from-node) 0 1))
    )
  )
(defun mffn (from-num to-num)
  (message-function-from-numbers from-num to-num)
  )
; Determine if a message is empty
(defun message-empty (m)
  (plm-empty (aref (link-contents (message-link m)) (message-index m))))

; Determine if a message is full
(defun message-full (m)
  (plm-full (aref (link-contents (message-link m)) (message-index m))))

; Determine if a message is uniform
(defun message-uniform (m)
  (plm-uniform (aref (link-contents (message-link m)) (message-index m))))

; Combine the input messages functionally via op
(defun combine-messages (fn op)
  (let (result vc (nf (node-function fn)) pred)
    (when (and (plm-p nf) ; If there is a function stored in the node, then include it in the combination
               (not (plm-empty nf)) ; Optimization that assumes 0 is the identify element for all of the combination operations
               )
      ; Eliminate lower states when it is part of a FAN for a state predicate
      (when (eq (node-subtype fn) 'combine)
        (setq pred (node-predicate fn))
        )
      (when (and pred (state-predicate pred))
        (if multiagent
            (dotimes (ai (graph-agents cg))
              (delete-lower-states-function pred nf (+ (aref bottom-state ai) 1) ai)
              )
          (delete-lower-states-function pred nf (+ bottom-state 1)))
        )
      (setq result nf)
      )
    (dolist (l (node-links fn))
      (setq vc (link-var-content l))
      (when vc ; Link is incoming to factor node
        (when (eq op 'por) ; Scale incoming message to <=1 if this is a probabilistic or
          (setq vc (scale-to-one-plm vc))
          )
        (if result
            (setq result (combine-plms vc nil result op))
          (setq result vc)
          )
        )
      )
    result)
  )

; Transform a message at a transform factor node
; The function argument here is the name of an executable lisp function to be applied to all regions on message from in-link
(defun transform-message (function in-link out-link &optional normalize)
  (let ((p (aref (link-contents in-link) 0))) ; Incoming PLM
    (setq p (transform-plm function p)) ; Outgoing PLM (with incoming variables)
    (setf (plm-variables p) ; Replace incoming variables with outgoing variables
          (plm-variables (aref (link-contents out-link) 1)))
    (when normalize
      (setq p (normalize-plm p nil t))
      (when trace-transform
        (format trace-stream "Result of transform (normalized): " p)
        )
      )
    p)
  )

; -----------------------------------------------------------
; Compute affine transform of PLM in incoming message

; Remove all slices outside the dimensions min and max
(defun remove-out-of-bound-slices (p d)
  (let* ((type (svariable-type (aref (plm-variables p) d))) ; Dimension structure for d
        (min (stype-min type))
        (max (stype-max type))
        (rank (plm-rank p))
        (sizev (dimension-sizes-v p))
        (needed (init-needed-vector rank sizev t))
        (needed-d (aref needed d))
        )
    (dolist (sl (aref (plm-slices p) d)) ; Process all slices along the dimension
      (when (or (e> (slice-location sl) max)
                (e< (slice-location sl) min)
                )
        (setf (aref needed-d (slice-index sl)) nil)
        )
      )
    (remove-unneeded-slices p needed))
  )

; Compute a vector mapping old dimensions to new for affine transformations
(defun affine-dimensions (rank affines)
  (let ((affine-map (init-vector rank)))
    (dotimes (i rank) ; Initialize map to identity
      (setf (aref affine-map i) i)
      )
    (dolist (aff affines) ; Process affine transforms
      (setf (aref affine-map (affine-from aff)) (affine-to aff))
      )
    affine-map)
  )

; Find the smallest maximal point along the specified dimension
; Assumes that the dimension is independent of the others, so can just maximize over all of them, ending with the one of interest
(defun smallest-maximal-point (p d)
  ; First maximize out all other dimensions
  (dotimes (i (length (plm-variables p)))
    (unless (= i d)
      (setq p (maximize-plm p i))
      )
    )
  ; Lastly maximize out dimension of interest and find smallest maximal point
  (reduce #'min (aref (region-maximals (plm-origin (maximize-plm p d))) d) :key #'car)
  )

; Translate one dimension of a PLM based on an offset specified by another dimension
; Allows offsets to be set on a region-by-region basis
(defun translate-plm (p d o &optional default invert)
  (let ((maximal-plm p)
        ;(variables (plm-variables p))
        )
    (setq maximal-plm (maximize-plm p o))
    (cpt-function-array-plm (variable-names (plm-variables p))
                            (plm-cpt (combine-plms p nil maximal-plm 'translate nil (cons d o) t nil invert))
                            (plm-variables p)
                            (if default default 0)
                            center-discrete-numeric-on-integer
                            t
                            )
    )
  )


; String for printing the offset
(defun offset-print-string (offset)
  (if offset
      (if (and (numberp offset) (< offset 0))
          (format nil " - ~S" (- offset))
        (format nil " + ~S" offset))
    "")
  )

; String for printing an affine transform
(defun affine-print-string (vn coef off apply)
  (cond (apply
         (format nil "~S*(~S~A)" coef vn (offset-print-string off))
         )
        (coef
         (cond ((= coef -1)
                (if off
                    (format nil "~S - ~S" off vn)
                  (format nil "-~S" vn))
                )
               ((and off (< coef 0))
                (format nil "~S - ~S*~S" off (- coef) vn)
                )
               (t
                (if off
                    (format nil "~S*~S~A" coef vn (offset-print-string off))
                  (format nil "~S*~S" coef vn))
                )
               )
         )
        (off
         (format nil "~S~A" vn (offset-print-string off))
         )
        (t
         (format nil "~S" vn)
         )
        )
  )        

; Map a list of dimension numbers
(defun map-dns (dns imapv)
  (let (mds)
    (dolist (d dns)
      (setq mds (cons (position d imapv) mds))
      )
    (nreverse mds))
  )

; Compute affine transform of PLM
; Affines is a list of affine transformations
(defun affine-plm (p affines in-map out-map variables new-vs old-vs &optional invert region-pad)
  (let ((np (copy-a-plm p)) ; Result function
        (rot-out-map (when out-map (make-smap :vfactor (copy-seq (smap-vfactor out-map))))) ; New out-map to change with rotations
        d rot-d in-d out-rot-d temp-d offset coef new-loc type second-slice imapv mapped-dns variable-offset-position
        (discretize (init-vector (length (plm-variables p)))) ; Track which dimensions need to be rediscretized at end
        v-ne ov-ne variable-offset print-offset
        )
    (when trace-affine
      (format trace-stream "~&~%PLM at beginning of affine transform: ") (print-plm p symbolic-trace)
      )
    (when in-map
      (setq imapv (smap-vfactor in-map))
      )
    (dolist (aff affines) ; Process the affine transforms for the corresponding dimensions
      (setq coef (affine-coefficient aff)) ; Coefficient for this dimension
      (when (and coef (= coef 1)) (setq coef nil)) ; Noop
      (setq d (affine-from aff)) ; Affine dimension in factor node
      (setq rot-d (affine-to aff)) ; Dimension to which d is rotated in factor node
      (when invert ; Swap to and from dimensions
        (setq temp-d d) (setq d rot-d) (setq rot-d temp-d)
        )
      (cond ((listp d) ; Incoming variables need to be combined in outgoing message
             (setq mapped-dns (map-dns d imapv))
;             (factor-combined-dimensions p np (if imapv mapped-dns d))
	     (setq np (factor-combined-dimensions p np (if imapv mapped-dns d)))
             (setq np (diagonalize-plm np mapped-dns))
             (when trace-affine
               (format trace-stream "~&~%PLM after combining factor node dimensions ~S (variable node dimensions ~S) and diagonalizing: " d mapped-dns)
               (pplm np)
               )
             (setq d (car d)) ; Use the first dimension to actually do the rotation/swap
             )
            ((listp rot-d) ; Incoming variable needs to be duplicated in outgoing message
             (error "Reuse of variables within a single action or condact not currently allowed.")
             )
            )
      ; in-d is the dimension in the incoming message from the variable node, rather than in the factor node
      (setq in-d d)
      (when in-map
        (setq in-d (position d imapv))
        )
      ; out-rot-d is the dimension that is rotated to in the outgoing message to the variable node, rather than in the factor node
      (setq out-rot-d rot-d)
      (when out-map
        (setq out-rot-d (position rot-d (smap-vfactor out-map)))
        )
      ; Process a rotation for the dimension
      (unless (= d rot-d)
        (setf (aref (plm-variables np) in-d) (aref new-vs out-rot-d))
        (setf (aref (smap-vfactor rot-out-map) out-rot-d) in-d) ; Create map for strip-and-reorder-plm
        )
      (setq offset (affine-offset aff)) ; Offset for this dimension
      (setq print-offset offset)
      (when invert ; If message is coming from evidence (i.e., from WM), invert the offset and coefficient
        (when (and offset (not (symbolp offset))) ;VOLKAN - can't invert if variable offset
          (setq offset (* offset -1)) ; Invert the offset
          )
        (when (and offset (symbolp offset))                 
          (setf (aref (smap-vfactor rot-out-map) (position offset old-vs :key #'svariable-name)) (position offset new-vs :key #'svariable-name))  
          )
        (when coef
          (setq coef (/ 1 coef))
          (when (and offset (not (symbolp offset)) (< coef 0))
            (setq offset (* -1 offset))
            )
          )
        )   
      ; Handle specification of offset by variable (using the smallest maximal point)
      ; (when (and offset (symbolp offset)) ; The offset is a variable name
      ; (setq variable-offset-position (position offset old-vs :key #'svariable-name))
      ; (setq offset (smallest-maximal-point p variable-offset-position)) ; Set offset to smallest maximal
      ; (setq np (maximize-plm np variable-offset-position)) ; Wipe out offset dimension from message

      (when trace-affine
        (setq print-offset (if offset print-offset variable-offset))
        (format trace-stream "~&~%Transform variable: ~S = " (svariable-name (aref variables rot-d)))
        (format trace-stream (affine-print-string (svariable-name (aref old-vs in-d)) coef print-offset (affine-apply-coefficient-to-offset aff)))
        )
      (when (and offset (symbolp offset)) ; The offset is a variable name
        (setq variable-offset offset)
        (setq variable-offset-position (position offset old-vs :key #'svariable-name))
        ; If not applying coefficient to offset, apply coefficient to variable before translating
        ;(unless (affine-apply-coefficient-to-offset aff)
        (when (and coef (not (affine-apply-coefficient-to-offset aff)))
          (when trace-affine
            (format trace-stream "~&~%<<< Begin subsidiary affine transform for coefficient >>>")
            )
         (if invert
              (setq np (affine-plm np (list (make-affine :from (affine-from aff) :to (affine-from aff) :coefficient coef :pad (affine-pad aff)))
                               out-map out-map variables new-vs new-vs invert region-pad)) ; use in-map for out-map and old-vs for new-vs because not yet stripping offset
            (setq np (affine-plm np (list (make-affine :from (affine-from aff) :to (affine-from aff) :coefficient coef :pad (affine-pad aff)))
                              in-map in-map variables old-vs old-vs invert region-pad)) ; use in-map for out-map and old-vs for new-vs because not yet stripping offset
            )
          (when trace-affine
            (format trace-stream "~&~%PLM after ~S = " (svariable-name (aref old-vs in-d)))
            (format trace-stream (affine-print-string (svariable-name (aref old-vs in-d)) coef nil nil))
            (format trace-stream ": ")
            (print-plm np symbolic-trace)
            (format trace-stream "~&~%<<< End subsidiary affine transform for coefficient >>>")
            )
          )
        ; Translate by variable offset
        (setq np (translate-plm np in-d variable-offset-position region-pad invert)) ;translate over in-d rather than rot-d
        (when trace-affine
          (format trace-stream "~&~%PLM after ~S = " (svariable-name (aref old-vs in-d)))
          (format trace-stream (affine-print-string (svariable-name (aref old-vs in-d)) nil print-offset nil))
          (format trace-stream ": ")
          (print-plm np symbolic-trace)
          )
        ; If applying coefficient to offset, apply coefficient after translating
        (when (and coef (affine-apply-coefficient-to-offset aff))
        ;(when (affine-apply-coefficient-to-offset aff)
          (when trace-affine
            (format trace-stream "~&~%<<< Begin subsidiary affine transform for coefficient >>>")
            )
         (if invert
              (setq np (affine-plm np (list (make-affine :from (affine-from aff) :to (affine-from aff) :coefficient coef :pad (affine-pad aff)))
                               out-map out-map variables new-vs new-vs invert region-pad)) ; use in-map for out-map and old-vs for new-vs because not yet stripping offset
            (setq np (affine-plm np (list (make-affine :from (affine-from aff) :to (affine-from aff) :coefficient coef :pad (affine-pad aff)))
                              in-map in-map variables old-vs old-vs invert region-pad)) ; use in-map for out-map and old-vs for new-vs because not yet stripping offset
            )
          (when trace-affine
            (format trace-stream "~&~%PLM after ~S = " (svariable-name (aref old-vs in-d)))
            (format trace-stream (affine-print-string (svariable-name (aref old-vs in-d)) coef nil nil))
            (format trace-stream ": ")
            (print-plm np symbolic-trace)
            (format trace-stream "~&~%<<< End subsidiary affine transform for coefficient >>>")
            )
          )
        (setq np (maximize-plm np variable-offset-position)) ; Wipe out offset dimension from message
        )
      (when (and offset (not (symbolp offset)) (affine-apply-coefficient-to-offset aff))
        (setq offset (* coef offset))
        )
      (setq type (svariable-type (aref new-vs out-rot-d))) ; Type of outgoing variable dimension
      ; Transform the slices for a dimension in the new PLM
      (dolist (s (aref (plm-slices np) in-d))
        ; Transform each slice (assumes already copied so no destructive side effects)
        (setq new-loc (slice-location s))
        (when (and coef (not (and offset (symbolp offset))))
          (setq new-loc (* new-loc coef))
          )
        (when (and offset (not (symbolp offset)))
          (setq new-loc (+ new-loc offset))
          )
        (setf (slice-location s) new-loc)
        )
      (when trace-affine
        (format trace-stream "~&~%PLM after affine transforms: ") (print-plm np symbolic-trace)
        )
      ; When coefficient is negative, reverse the order of the regions along the dimension
      (when (and coef (not (and offset (symbolp offset))) (< coef 0))
        (setq np (reverse-plm np in-d))
        (when trace-affine
          (format trace-stream "~&~%PLM after reversing dimension ~S: " in-d) (print-plm np symbolic-trace)
          )
        )
      (setq second-slice (extreme-slice (aref (plm-slices np) in-d) #'<)) ; Second slice from beginning (is actually first slice??)
      ; Pad front of PLM
      (when (> (slice-location second-slice) (stype-min type))
        (setq np (factor-plm np in-d (make-slice :location (stype-min type)) region-pad))
        (when trace-affine
          (format trace-stream "~&~%PLM after padding front: ") (print-plm np symbolic-trace)
          )
        )
      ; Ensure there is a slice at the type minimum
      (when (< (slice-location second-slice) (stype-min type))
        (setq np (factor-plm np in-d (make-slice :location (stype-min type))))
        (when trace-affine
          (format trace-stream "~&~%PLM after adding min slice: ") (print-plm np symbolic-trace)
          )
        )
      (setq second-slice (extreme-slice (aref (plm-slices np) in-d) #'>)) ; Second slice from end (is actually last slice??)
      ; Pad end of plm
      (when (< (slice-location second-slice) (stype-max type))
        (setq np (factor-plm np in-d (make-slice :location (stype-max type)) region-pad))
        (when trace-affine
          (format trace-stream "~&~%PLM after padding rear: ") (print-plm np symbolic-trace)
          )
        )
      ; Ensure there is a slice at the type maximum
      (when (> (slice-location second-slice) (stype-max type))
        (setq np (factor-plm np in-d (make-slice :location (stype-max type))))
        (when trace-affine
          (format trace-stream "~&~%PLM after adding max slice: ") (print-plm np symbolic-trace)
          )
        )
      (setq np (remove-out-of-bound-slices np in-d))
      (when trace-affine
        (format trace-stream "~&~%PLM after removing out-of-bound slices: ") (print-plm np symbolic-trace)
        )
      ; If dimension is discrete and there is a non-integral coefficient, rediscretize along the dimension
      (when (and (stype-discrete type) coef (not (integerp coef)))
        (setf (aref discretize rot-d) t)
        )
      )
    ; Take care of any within predicate not-equal (<>) tests
    (dolist (aff affines)
      (when (affine-not-equal aff)
        (setq v-ne (position (affine-from aff) (smap-vfactor out-map))) ; Variable from which to remove not-equals
        (setq ov-ne (position (affine-not-equal aff) (smap-vfactor out-map))) ; Variable to which v-ne is not equal
        (setq np (inverse-diagonalize-plm np (list v-ne ov-ne)))
        (when trace-affine
          (format trace-stream "~&~%PLM after not-equal test (~S <> ~S): " (svariable-name (aref new-vs v-ne)) (svariable-name (aref new-vs ov-ne)))
          (print-plm np symbolic-trace)
          )
        )
      )
;    (setq np (remove-unneeded-slices np))
    (when trace-affine
      (format trace-stream "~&~%PLM after removing unneeded slices: ") (print-plm np symbolic-trace)
      )
    (dotimes (i (length discretize))
      (when (aref discretize i)
        (setq np (discretize-dimension np i))
        (when trace-affine
          (format trace-stream "~&~%PLM after rediscretizing slices for dimension ~S: " i) (print-plm np symbolic-trace)
          )
        )
      )
      (setq np (strip-and-reorder-plm rot-out-map new-vs np))
    (when (plm-piecewise-constant p)
      (setf (plm-piecewise-constant np) t)
      )
    np)
  )

; Compute special case of affine transform for ADF delta nodes
; Only changes variables
; Ignores actual affines, just paying attention to mapping from variable node variables to factor node variables
(defun affine-delta-plm (p variables mapv)
  (let* ((rank (plm-rank p))
         (np (make-plm :rank rank
                       :active (copy-seq (plm-active p))
                       :slices (plm-slices p)
                       :array (plm-array p)
                       :piecewise-constant (plm-piecewise-constant p)
                       :removed-unneeded-slices (plm-removed-unneeded-slices p)))
         (nvs (init-vector rank))
         )
    (dotimes (i rank)
      (setf (aref nvs i) (aref variables (aref mapv i)))
    )
    (setf (plm-variables np) nvs)
    np)
  )

; Determine if a vector is sorted from smallest to largest
(defun in-order (v)
  (let ((in-order t))
    (dotimes (i (1- (length v)))
      (unless (< (aref v i) (aref v (1+ i)))
        (return (setq in-order nil))
        )
      )
    in-order)
  )

; Compute affine transform of PLM in incoming message
; Affines is a list of affine transformations
(defun affine-message (affines in-link out-link variables &optional other-in-link) ;optional added by VOLKAN
  (let ((in-link-var-content (link-var-content in-link)) ;VOLKAN
        (invert  (member (link-var-node in-link) ; Source variable node for message
                            (node-evidence (link-fact-node in-link)) ; Transform factor node
                            ))
        temp-plm
        temp-map
        )
    (when trace-affine
      (format trace-stream "~&~%~% *** Affine transform at node ~S ***" (node-name (aref (link-nodes in-link) 1)))
      )
    (if (and other-in-link invert (eq (nth 0 (array-dimensions (plm-array (link-var-content other-in-link)))) 1))
        in-link-var-content
      (progn
        (when (and invert other-in-link)      
          ; VOLKAN NEXT LINE TRIES TO EXTRACT THE OFFSET VARIABLE AS THE LAST VARIABLE TO BE USED IN THE OUTER PRODUCT: This is an assumption, need to find a way to extract the offset variable
          (setf temp-plm (full-plm  (coerce (list (aref (plm-variables (link-var-content other-in-link)) (1- (length (plm-variables (link-var-content other-in-link)))) )) 'vector)))
          (setf temp-plm (outer-plms in-link-var-content temp-plm 'product))
          (setf temp-map (build-smap  (plm-variables (link-var-content other-in-link)) (plm-variables temp-plm)))
          (setf in-link-var-content (combine-plms (link-var-content other-in-link)  temp-map temp-plm 'product))
          )
    
  ; Check if can use optimized implementation at delta nodes (no variable mapping in either direction and same number of variables)
        (if (and (eq (node-subsubtype (aref (link-nodes in-link) fact-index)) 'match)
                 (in-order (smap-vfactor (link-map out-link)))
                 (in-order (smap-vfactor (link-map in-link)))
                 (= (length (node-variables (aref (link-nodes in-link) var-index)))
                    (length (node-variables (aref (link-nodes out-link) var-index))))
                 )
            (affine-delta-plm in-link-var-content variables (smap-vfactor (link-map out-link))) ;in-link-var-content VOLKAN
          (affine-plm in-link-var-content affines
                    ;(if other-in-link (link-map out-link) (link-map in-link)) (link-map out-link)
                      (link-map in-link) (link-map out-link)
                      variables (node-variables (aref (link-nodes out-link) var-index)) (plm-variables in-link-var-content);(node-variables (aref (link-nodes in-link) var-index))
              ; If message is coming from evidence (i.e., from WM), invert transform
                      invert
                    ;(member (link-var-node in-link) ; Source variable node for message
                    ;        (node-evidence (link-fact-node in-link)) ; Transform factor node
                     ;       )
                      (node-region-pad (link-fact-node in-link)))
          )
        )
      )
    )
  )

; Create an initial message from a variable node to a factor node
(defun init-var-fact-link-content (vn fn in out)
  (let ((vn-vs (node-variables vn))
        (evidence (node-evidence fn))
        )
    (cond ((and (eq (node-subsubtype vn) 'van) ; When chaining on actions, need the input from VANs to FAN to initialize to 0
                (eq (node-subtype fn) 'combine)
                (or (eq (node-subsubtype fn) 'sum)
                    (eq (node-subsubtype fn) 'max)
                    (eq (node-subsubtype fn) 'por)
                    )
                )
           (empty-plm vn-vs)
           )
          (t
           (if (eq evidence t) ; WM factor node
               (if in ; The variable node is from an action or condact
                   (full-plm vn-vs) ; Generic message
                 nil)
             (if (member vn evidence) ; The variable node is evidence for this factor
                 (if out ; Messages flow from evidence variable nodes
                     (full-plm vn-vs) ; Generic message
                   nil) ; No message
               (if (and in ; Messages flow from non-evidence variable nodes
                        (not (eq (node-subtype fn) 'pass-through))) ; A hack to avoid the message from prediction predicate's outgoing WMVN to prediction factor node
                   (full-plm vn-vs) ; Generic message
                 nil) ; No message
               )
             )
           )
          )
    )
  )

; Create an initial message from a factor node to a variable node
(defun init-fact-var-link-content (l fn vn unary map in out)
  (let ((vn-vs (node-variables vn))
        (evidence (node-evidence fn))
        (function (node-function fn))
        )
    (if (eq evidence t) ; WM factor node
        (if out ; Messages flow to non-evidence variable nodes
            (if (link-variables-same l)
                function
              (strip-and-reorder-plm map vn-vs function)) ; Send factor function
          nil) ; No message
      (if (member vn evidence) ; The variable node is evidence for this factor
          (if in ; Messages flow to evidence variable nodes
              (if unary ; Only one variable node
                  (if (predicate-attention-predicate (node-predicate fn)) ; There is attention for this node
                      (apply-attention (node-predicate fn) ; Apply attention to initial value 
                                       (if (link-variables-same l)
                                           function
                                         (strip-and-reorder-plm map vn-vs function))) ; Send factor function
                    (if (link-variables-same l)
                                           function
                                         (strip-and-reorder-plm map vn-vs function)))
                (full-plm vn-vs)) ; Generic message
            nil) ; No message
        (if out ; Messages flow to non-evidence variable nodes
            (if unary ; Only one variable node
                function ; Send factor function
              (full-plm vn-vs)) ; Generic message
          nil)
        )
      )
    )
  )

; Add message to prequeue
(defun prequeue (m)
  (unless (aref (link-prequeue (message-link m)) (message-index m))
    (setf (aref (link-prequeue (message-link m)) (message-index m)) m)
    )
  )

; Create initial outgoing messages from a node to all of its links.
(defun init-outgoing-messages-links (node &optional ignore-decision-count)
  (let* ((ls (node-links node))
         (unary (eq (length ls) 1))
         (is-var-node (variable-nodep node))
         (index (if is-var-node var-index fact-index))
         m lnode lcontent)  
    (dolist (l ls)
      (setq lnode (if is-var-node (link-fact-node l) (link-var-node l)))
      (setq lcontent (if is-var-node
                         (init-var-fact-link-content node lnode (link-in l) (link-out l))
                       (init-fact-var-link-content l node lnode unary (link-map l) (link-in l) (link-out l))
                       )
            )
      (when (and lcontent ; Link is active in direction
                 (or ignore-decision-count ; Allow a forced reintialization even if already done on decision (for use with new evidence)
                     (< (aref (link-inits l) index) decision-count) ; Not already initialized on this decision
                     )
                 )      
        ; Create message for link and add to prequeue
        (setf (aref (link-contents l) index) lcontent)
        (setq m (make-message :link l :index index :wm-driven (wm-fnp node)))
        (prequeue m)
        (setf (aref (link-inits l) index) decision-count) ; Mark link direction with decision on which initialized
        )
      )
    )
  )

; Create initial outgoing messages for all of the descendant-links of a node
(defun update-outgoing-messages-links (node &optional ignore-decision-count)
  (let* (
         (ls (node-descendant-links node))        
         n index unary is-factor-node l m lnode lcontent
         )
    (dolist (ld ls)
      (setf l (descendant-link-link ld)) 
      (setf lnode (link-node l (descendant-link-direction ld)))
      (setf is-factor-node (factor-nodep lnode))
      (setf index (if (eq (descendant-link-direction ld) 1) 0 1))
      (setf n (link-node l index))
      (setf unary (eq (length (node-links n)) 1))
      (setq lcontent (if is-factor-node
                         (init-var-fact-link-content n lnode (link-in l) (link-out l))
                       (init-fact-var-link-content l n lnode unary (link-map l) (link-in l) (link-out l))
                       )
            )
      (when (and lcontent ; Link is active in direction
                 (or ignore-decision-count ; Allow a forced reintialization even if already done on decision (for use with new evidence)
                     (< (aref (link-inits l) index) decision-count) ; Not already initialized on this decision
                     )
                 )
        ; Create message for link and add to prequeue
        (setf (aref (link-contents l) index) lcontent)
        (setq m (make-message :link l :index index :wm-driven (and (wm-nodep n) (not is-factor-node))))
        (setf (aref (link-stale l) index) t)
        (prequeue m)
        (setf (aref (link-inits l) index) decision-count) ; Mark link direction with decision on which initialized
        )
      )
    )
  )

; Initialize message counts on links
(defun init-link-counts nil
  (dolist (l (graph-links cg))
    (setf (aref (link-counts l) var-index) 0)
    (setf (aref (link-counts l) fact-index) 0)
    )
  )


; Total number of messages sent (summing link-counts)
(defun total-link-counts ()
  (let ((total 0))
    (dolist (l (graph-links cg))
      (when (numberp (aref (link-counts l) var-index))
        (setq total (+ total (aref (link-counts l) var-index)))
        )
      (when (numberp (aref (link-counts l) fact-index))
        (setq total (+ total (aref (link-counts l) fact-index)))
        )
      )
    total)
  )

; Set messages from assumption nodes as fresh, and all others as stale
(defun init-messages-fresh-stale ()
  (dolist (l (graph-links cg))
    (setf (aref (link-stale l) var-index) t)
    (if (node-assumption (link-node l fact-index))
        (setf (aref (link-stale l) fact-index) nil)
      (setf (aref (link-stale l) fact-index) t))
    )
  )

; Initialize graph-changes vector to nil
(defun initialize-graph-changes ()
  (let ((cgs (graph-changes cg)))
    (if cgs
        (dotimes (i (graph-node-count cg))
          (setf (aref cgs i) nil)
          )
      (setf (graph-changes cg) cgs))
    )
  (setf (graph-changes cg) (init-vector (graph-node-count cg)))
  )

; Create initial messages for all links in a graph
(defun init-graph-messages (&optional ignore-decision-count)
;  (mapc #'(lambda (n) (init-outgoing-messages-links n ignore-decision-count)) (graph-nodes cg))
  (let (nf)
    (dolist (n (graph-nodes cg))
      (setq nf (node-function n))
      (init-outgoing-messages-links n ignore-decision-count)
      (when (and nf (typep nf 'plm) (plm-is-constant nf))
        (setf (plm-piecewise-constant nf) t)
        )
      )
    (initialize-graph-changes) ; In case there was any evidence that set graph-changes
    (init-messages-fresh-stale)
    )
  )

; Update messages between decisions
(defun update-graph-messages (&optional ignore-decision-count)
  (let ((cgs (graph-changes cg))
        )
    (if (and save-message-state ; We're saving message state across decisions
             (> decision-count 1) ; This is not the first decision
             )
        ; Update messages from all nodes that have changed
        (dolist (n (graph-nodes cg))
          (when (aref cgs (node-number n))
            (update-outgoing-messages-links n ignore-decision-count)
            (when (plm-is-constant (node-function n))
              (setf (plm-piecewise-constant (node-function n)) t)
              )
            )
          )
      (init-graph-messages ignore-decision-count)
      )
    (initialize-graph-changes)
    )
  )

; Return a list of copies of outgoing messages for a node
(defun node-outgoing-messages (n)
  (let ((index (if (variable-nodep n) 0 1))
        ml
        contents)
    (dolist (l (node-links n))
      (setq contents (aref (link-contents l) index))
      (when contents
        (setq ml (cons (cons (node-number (aref (link-nodes l) (- 1 index))) (copy-a-plm contents)) ml))
        )
      )
    ml)
  )

; Reorder variables by volumes
(defun reorder-factor-variables (vs)
  (sort (copy-seq vs) #'< :key #'(lambda (v) (v-type (if (listp v) (svariable-type (car v)) (svariable-type v)))))
  )

; Create a list of depth message queues of one per depth plus one for everything more (and null)
(defun full-depth-message-queues ()
  (let* ((depth (+ (graph-depth cg) 1))
         (dqs (init-vector depth))
         )
    (dotimes (i depth)
      (setf (aref dqs i) (init-queue))
      )
    dqs)
  )

; Create message queues
(defun init-message-queues ()
  (let ((qs (init-vector 2)))
    (setf (aref qs depth-queues-index) (full-depth-message-queues))
    (setf (aref qs other-queue-index) (init-queue))
    qs)
  )

; Find message coming in to WM FN node
(defun wm-change-message (pred)
  (let (message
        (predicate-wm (predicate-wm pred))
        (pos-var (predicate-incoming-vn pred))
        )
    (dolist (l (node-links predicate-wm))
      (when (equal pos-var (link-var-node l))
        (return (setq message (link-var-content l)))
        )
      )
    message)
  )

; Initialize a run by initializing link contents and messages
(defun init-messages (&optional compute-depths)
  (restrict-to-bottom-state) ; State dimensions should all be limited to base-state
  (init-graph-messages t)
  (when compute-depths
    (compute-all-depths)
    )
  (setf (graph-queues cg) (init-message-queues))
  (load-queues)
  )
(defun im nil (init-messages))

; Break when message is non-empty from one node number to another
(defun break-on-positive-messages ()
  (let (break mf)
    (dolist (m break-on-positive-messages)
      (setq mf (message-function-from-numbers (car m) (cadr m)))
      (when (not (plm-empty mf))
        (format trace-stream "~&~%Breaking on positive message from ~S to ~S: " (node-name (node-from-number (car m))) (node-name (node-from-number (cadr m))))
        (pplm mf)
        (setq break t)
        )
      )
    break)
  )  

; Get message from first node (name) to second
(defun message (n1-name n2-name)
  (let* ((n1-node (node-from-name n1-name))
         (n2-node (node-from-name n2-name))
         v-node ; Variable node
         f-node ; Factor node
         index ; Index for accessing content array
         )
    (cond ((variable-nodep n1-node)
           (setq v-node n1-node)
           (setq f-node n2-node)
           (setq index var-index)
           )
          (t
           (setq v-node n2-node)
           (setq f-node n1-node)
           (setq index fact-index)
           )
          )
    (dolist (link (node-links v-node))
      (when (eq (aref (link-nodes link) fact-index) f-node)
        (return (aref (link-contents link) index))
        )
      )
    )
  )


; Get message PLM from node numbers
(defun mp (nn1 nn2)
  (let* ((n1 (node-from-number nn1))
         (n2 (node-from-number nn2))
         (l (link-from-nodes n1 n2))
         )
    (if (variable-nodep n1)
        (link-var-content l)
      (link-fact-content l))
    )
  )      

; Messages with maximum regions, from graph-statistics
; Vector with total regions and non-empty regions
(defvar max-message-regions)

; Compute statistics on messages
(defun message-statistics (&optional stream)
  (unless stream (setq stream trace-stream))
  (let ((nums 0)
        (sums (init-vector 2 0))
        (maxs (init-vector 2 0))
        (maxms (init-vector 2 nil)) ; Lists of messages with maximum regions
        p ; message PLM
        regs) ; Data on regions in a message PLM
    (dolist (n (graph-nodes cg))
      (when (factor-nodep n)
        (dolist (l (node-links n))
          (dotimes (i 2) ; Iterate over message direction
            (setq p (aref (link-contents l) i))
            (when p
              (setf nums (+ nums 1))
              (setq regs (count-plm-regions p))
              (dotimes (j 2) ; Iterate over whether region is empty
                (setf (aref sums j) (+ (aref sums j) (aref regs j)))
                (when (= (aref regs j) (aref maxs j))
                  (setf (aref maxms j)
                        (cons (list (node-name (aref (link-nodes l) i))
                                    (node-name (aref (link-nodes l) (invert-value i)))
                                    )
                              (aref maxms j)))
                  )
                (when (> (aref regs j) (aref maxs j))
                  (setf (aref maxs j) (aref regs j))
                  (setf (aref maxms j)
                        (list (node-name (aref (link-nodes l) i))
                              (node-name (aref (link-nodes l) (invert-value i)))
                              ))
                  )
                )
              )
            )
          )
        )
      )
    (dotimes (i 2)
      (setf (aref sums i)
            (coerce (/ (aref sums i) nums) 'short-float)) ; Convert sums to averages
      )
    (format stream "~&Average regions per message: ~5,1F; non-empty regions: ~5,1F"
            (aref sums 0) (aref sums 1))
    (format stream "~&Maximum regions per message: ~s; non-empty regions: ~S"
            (aref maxs 0) (aref maxs 1))
    (setq max-message-regions maxms) ; Store maxes globally in case want to look at them
    t)
  )
; Shortcut for message-statistics
(defun ms (&optional stream)
  (unless stream (setq stream trace-stream))
  (message-statistics stream)
  )

; -----------------------------------------------------------
; Compute the depth of each link direction in a graph
; To be used in stratifying messages with depth in queues

; Compute the depth of a link from a node
; Adding new node to queue of nodes
(defun compute-link-depth (l n q)
  (let* ((direction (if (variable-nodep n) 0 1))
         (opposite (- 1 direction))
         (links (node-links n))
         (depth -1) ; Depth when no incoming links should be 0
         il-depth ; Depth of incoming link
         depth+1
         )
    (unless (or (node-assumption n) ; Don't need to check for these
                (not (incoming-links n)) ; Handle open-world WMVN nodes when no actions or condacts
                )
      (dolist (il links)
        (when (and (not (= (node-number (aref (link-nodes l) opposite)) ; Don't consider outgoing link as incoming
                           (node-number (aref (link-nodes il) opposite))))
                   (aref (link-contents il) opposite) ; Only consider active incoming links
                   )
          (setq il-depth (aref (link-depths il) opposite))
          (if il-depth
              (when (> il-depth depth) (setq depth il-depth))
            (progn
              (setq depth nil)
              (return)
              )
            )
          )
        )
      )
    (when depth
      (setq depth+1 (+ depth 1))
      (setf (aref (link-depths l) direction) depth+1)
      (when (> depth+1 (graph-depth cg)) (setf (graph-depth cg) depth+1))
      (add-to-queue (aref (link-nodes l) opposite) q)
      )
    q)
  )

; Compute the link depths outgoing from a node
; Adding new nodes to queue as found
(defun compute-node-link-depths (n q)
  (let ((direction (if (variable-nodep n) 0 1)))
    (dolist (l (node-links n))
      (when (and (aref (link-contents l) direction) ; Outgoing link is active
                 (not (aref (link-depths l) direction)) ; Not already a depth
                 )
        (setq q (compute-link-depth l n q))
        )
      )
    q)
  )

; Are there incoming links for node?
(defun incoming-links (node)
  (let (incoming
        (node-incoming-index (if (factor-nodep node) 0 1)))
    (dolist (l (node-links node))
      (when (aref (link-contents l) node-incoming-index)
        (setq incoming t)
        (return)
        )
      )
    incoming)
  )

; Determine depths of all links in graph
(defun compute-link-depths ()
  (setf (graph-depth cg) 0)
  (let ((q (init-queue)) ; Queue of nodes, not messages, for determining depth
        n)
    ; Initialize queue to assumption nodes
    (dolist (node (graph-nodes cg))
      (when (or (node-assumption node)
                (not (incoming-links node)) ; Handle open-world WMVN nodes when no actions or condacts
                )
        (add-to-queue node q)
        )
      )
    (loop
     (when (queue-empty q) (return))
     (setq n (pop-queue q))
     (setq q (compute-node-link-depths n q))
     )
    )
  )

; Compute the loop-depth of a link from a node
; Adding new node to queue of nodes
(defun compute-link-loop-depth (l n d q)
  (let ((other (- 1 d))
        (loop-depth 0)
        )
      (dolist (il (node-links n))
        (when (and (not (equal l il)) ; Don't consider outgoing link as incoming
                   (aref (link-contents il) other) ; Only consider active incoming links
                   (aref (link-loop-depths il) other) ; There is an incoming loop-depth
                   )
          (setq loop-depth (max loop-depth (+ (aref (link-loop-depths il) other) 1)))
          )
        )
    (when (> loop-depth 0)
      (setf (aref (link-loop-depths l) d) loop-depth)
      (add-to-queue (aref (link-nodes l) other) q)
      (when (> loop-depth (graph-depth cg))
        (setf (graph-depth cg) loop-depth)
        )
      )
    q)
  )


; Compute the link loop-depths outgoing from a node
; Adding new nodes to queue as found
(defun compute-node-link-loop-depths (n q)
  (let ((d (if (variable-nodep n) 0 1)))
    (dolist (l (node-links n))
      (when (and (aref (link-contents l) d) ; Outgoing link is active
                 (not (aref (link-depths l) d)) ; Not already a depth
                 (not (aref (link-loop-depths l) d)) ; Not already a loop-depth
                 )
        (setq q (compute-link-loop-depth l n d q))
        )
      )
    q)
  )

; Process link to see if it is a loop edge, given it is in loop
(defun link-loop-edge (n ol d q)
  (let ((loop-depth 0)
        (other (- 1 d))
        )
    (dolist (il (node-links n)) ; Iterate through incoming links
      (when (and (not (equal ol il)) ; Incoming and outgoing are different links
                 (aref (link-contents il) other) ; Incoming link is active
                 (aref (link-depths il) other) ; There is an incoming depth
                 )
        (setq loop-depth (max loop-depth (+ (aref (link-depths il) other) 1)))
        )
      )
    (when (> loop-depth 0) ; There are some incoming depths
      (setf (aref (link-loop-depths ol) d) loop-depth)
      (add-to-queue (aref (link-nodes ol) other) q)
      (when (> loop-depth (graph-depth cg))
        (setf (graph-depth cg) loop-depth)
        )
      )
    )
  )
        

; Process links from node to see if loop edge
(defun node-loop-edge (n q)
  (let ((direction (if (variable-nodep n) 0 1)))
    (dolist (l (node-links n))
      (when (and (aref (link-contents l) direction) ; Outgoing link is active
                 (not (aref (link-depths l) direction)) ; Child is depthless
                 ) 
        (link-loop-edge n l direction q)
        )
      )
    )
  )
          

; Determine depths of all links in graph
(defun compute-link-loop-depths ()
  (let ((q (init-queue)) ; Queue of nodes, not messages, for determining depth
        n)
    ; First process all loop edges (nodes with depthless outgoing links but with some incoming depths)
    (dolist (node (graph-nodes cg))
      (unless (node-assumption node) ; Don't need to check for these
        (node-loop-edge node q)
        )
      )
    (loop
     (when (queue-empty q) (return))
     (setq n (pop-queue q))
     (unless (node-assumption n) ; Don't need to check for these
       (setq q (compute-node-link-loop-depths n q))
       )
     )
    )
  )

; Clear all link depths
(defun clear-link-depths nil
  (setf (graph-depth cg) nil)
  (dolist (l (graph-links cg))
    (dotimes (i 2)
      (setf (aref (link-depths l) i) nil)
      (setf (aref (link-loop-depths l) i) nil)
      )
    )
  )

; Compute link-depths and then link-loop-depths
(defun compute-all-depths ()
  (when (graph-depth cg) ; Link depths have already been computed
    (clear-link-depths) ; So clear all before recomputing
    )
  (compute-link-depths)
  (compute-link-loop-depths)
  )

; -----------------------------------------------------------
; Define summary-product algorithm

; Are two messages on same arc (same link and index)
(defun same-arc (l1 i1 l2 i2)
  (and (eq i1 i2)
       (eq (link-node l1 0) (link-node l2 0))
       (eq (link-node l1 1) (link-node l2 1))
       )
  )

; Is a message on arc in the queue?
(defun arc-in-queue (l i q)
  (dolist (mi (cdr (queue-head q)) nil)
    (when (same-arc l i (message-link mi) (message-index mi))
      (return (list q mi))
      )
    )
  )

; Is a message on arc in the depth queues?
(defun arc-in-depth-queues (l i dqs)
  (let (returned)
    (dotimes (j (length dqs))
      (setq returned (arc-in-queue l i (aref dqs j)))
      (when returned
        (return returned)
        )
      )
    returned)
  )

; Is a message on arc in the queues?
(defun arc-in-queues (l i qs)
  (let (returned)
    (setq returned (arc-in-depth-queues l i (aref qs depth-queues-index)))
    (unless returned
      (setq returned (arc-in-queue l i (aref qs other-queue-index)))
      )
    returned)
  )

; Remove message on arc from queue
(defun remove-arc-in-queue (l i q)
  (do ((mi-l (queue-head q) (cdr mi-l)))
      ((null (cdr mi-l)))
    (when (same-arc l i (message-link (cadr mi-l)) (message-index (cadr mi-l)))
      (when (eq (queue-tail q) (cdr mi-l)) ; If removing last element, move tail pointer forward
        (setf (queue-tail q) mi-l))
      (rplacd mi-l (cddr mi-l)) ; Remove item from queue
      (return t)
      )
    )
  )

; Check list of depth queues if there is at least one that isn't empty
(defun depth-message-queues-not-empty (dqs)
  (let (ne)
    (dotimes (i (length dqs))
      (when (queue-not-empty (aref dqs i))
        (setq ne t)
        (return)
        )
      )
    ne)
  )

; Are the queues not empty?
(defun message-queues-not-empty (qs)
  (or (depth-message-queues-not-empty (aref qs depth-queues-index))
      (queue-not-empty (aref qs other-queue-index))
      )
  )

; Add message m to the graph's queue
(defun add-to-message-queue (m)
  (let* ((ml (message-link m))
         (mi (message-index m))
         (qs (graph-queues cg))
         q
         depth
         (front nil) ; Whether to add message at the front of the queue
         )
    (when (and (not (arc-in-queues ml mi qs)) ; Message not already in queue
               (link-content ml mi) ; Link is active in direction
               )
      (setq depth (if (aref (link-depths ml) mi)
                      (aref (link-depths ml) mi)
                    (aref (link-loop-depths ml) mi)))
      (cond (depth ; The message direction has a depth
             (setq q (aref (aref qs depth-queues-index) depth))
             (when trace-queue
               (format trace-stream "~&Adding to ~A of depth queue ~S: " (if front '"front" '"back") (aref (link-depths ml) mi))
               (print-message nil ml mi t)
               )
             )
            (t
             (setq q (aref qs other-queue-index))
             (when trace-queue
               (format trace-stream "~&Adding to ~A of other queue: " (if front '"front" '"back"))
               (print-message nil ml mi t)
               )
             )
            )
      (add-to-queue m q front)
      )
    )
  )

; Is variable located at current site
; If the site is a list, see if a member, otherwise just check for same
(defun variable-exists (v vs-site)
  (let ((vname (if (typep v 'svariable) (svariable-name v) v)))
    (if (listp vs-site)
        (member vname vs-site :key #'svariable-name)
      (eq vname (svariable-name vs-site))))
  )

; Find the variable number from a variable in a vector of variables
; Some of the slots may have more than one variable, so need to be sure to check all
(defun variable-number (v vs)
  (dotimes (i (length vs))
    (when (variable-exists v (aref vs i))
      (return i)
      )
    )
  )

; Factor variable(s) for dimension are part of a vector of variables from variable node
(defun variables-members (fn-vars vn-vars)
  (if (listp fn-vars)
      (dolist (fnv fn-vars nil)
        (when (find (svariable-name fnv) vn-vars :key #'svariable-name) (return t)))
    (find (svariable-name fn-vars) vn-vars :key #'svariable-name)
    )
  )

; Given a binary node and one of its links return the other one
(defun other-link (n link)
  (if (equal link (car (node-links n)))
      (cadr (node-links n))
    (car (node-links n)))
  )

; Given a transform node and one of its incoming links return the other one
(defun other-incoming-link (n link)
  (let (other)
    (dolist (l (node-links n))
      (when (and (not (equal l link)) ; Different link
                 (aref (link-contents l) var-index) ; There is an incoming message
                 )
        (return (setq other l))
        )
      )
    other)
  )

; Given a transform node and one of its incoming links return the other one
(defun other-unidirectional-incoming-link (n link)
  (let (other)
    (dolist (l (node-links n))
      (when (and (not (equal l link)) ; Different link
                 (aref (link-contents l) var-index) ; There is an incoming message
                 (not (aref (link-contents l) fact-index)) ; There is no outgoing message
                 )
        (return (setq other l))
        )
      )
    other)
  )

; Create an outgoing message from a factor node
; Need to multiply all incoming messages (except for from outgoing node)
; times the node's function and integrate/maximize out all but the outgoing variables.
; Integrates/maximizes out a variable right after the function has been multiplied by it
(defun outgoing-fact-var-message (m wm-driven)
  (let* ((ml (message-link m)) ; The link for the message
         (lc (link-fact-content ml)) ; Existing message to send to variable node
         (fn (link-fact-node ml)) ; Factor node from which message is sent
         (vn (link-var-node ml)) ; Variable node to which message is sent
         (vn-vars (node-variables vn)) ; The variables used at the variable node
         (sum-prod (node-function fn)) ; Cumulatively computed message content
         (steps (node-factor-steps fn)) ; The steps to be taken to generate message
         (skip-product (and (beta-factor fn) (plm-full (node-function fn)))) ; Skip inital product for beta factors with a function of 1 under right circumstances
         (first-product t) ; Whether product is first one performed
         new-message ; Whether generate a new message
         s
         )
    (cond ((eq (node-subtype fn) 'transform) ; Factor function is a function to be computed on input message rather than PLM
           (setq sum-prod (transform-message sum-prod (other-incoming-link fn ml) ml (node-normalize fn)))
           )
          ((eq (node-subtype fn) 'combine) ; Factor function does a one-way functional combination of inputs
           (setq sum-prod (combine-messages fn (node-subsubtype fn)))
           )
          ((eq (node-subtype fn) 'affine) ; Factor function computes a tranform on the PLM slices
            (setq sum-prod (affine-message sum-prod (other-link fn ml) ml (node-variables fn) (other-unidirectional-incoming-link fn (other-link fn ml)))) ;updated by VOLKAN
           )
          ((eq (node-subtype fn) 'explicit) ; Factor converts implicit functional value into an explicit domain value along new action variable
           (setq sum-prod (explicit-plm (aref (link-contents (other-incoming-link fn ml)) var-index) (cadr (node-function fn))))
           )
          ((eq (node-subtype fn) 'function) ; Function factor node that maintains a constant message across the decision
           (setq sum-prod lc)
           )
          (t
           ; Summarize across the product of the messages
           (do ((ss steps (cdr ss)))
               ((null ss))
             (setq s (car ss))
             (let ((sl (factor-step-argument s))) ; The link (product) or variable number (integrate/maximize) for this step
               (if (eq (factor-step-type s) 'product)
                   (when (and
                          (not (eq sl ml)) ; Not from target variable node
                          (link-var-content sl) ; Incoming message from variable node is active
                          )
                     (setq sum-prod
;                           (remove-unneeded-slices
                            (combine-plms (link-var-content sl) (link-map sl) sum-prod 'product)
;                            )
                           )
                     (setq first-product nil)
                     )
                 (unless (variables-members (aref (node-variables fn) sl) vn-vars) ; Variable is not part of target VN
                   (setq sum-prod
;                         (remove-unneeded-slices
                                   (if (eq (factor-step-type s) 'integral)
                                       (integral-plm sum-prod sl)
                                     (maximize-plm sum-prod sl))
;                                   )
                         )
                   )
                 )
               )
             )
           ; Determine when to use an inverse filter (padding with 1s)
           (when (and (eq (node-subtype fn) 'filter)
                      (or (eq (node-subsubtype fn) 'inverse-both) ; Condacts that are are using the inverse filter in both directions
                          (and (eq (node-subsubtype fn) 'inverse-in) (member vn (node-evidence fn))) ; Incoming condact or action (with open-actions-like-condacts T)
                          (and (eq (node-subsubtype fn) 'inverse-out) (not (member vn (node-evidence fn)))) ; Outgoing condition (with open-conditions-like-condacts T)
                          )
                      )
             (setq sum-prod (combine-plms sum-prod nil (node-inverse-function fn) 'por))
             )
; If there are any linear filters that are problematic, should be flagged when they are defined, rather than requiring this here
           ; For linear filters set a floor of 0 on all regions
;           (when (and (eq (node-subtype fn) 'filter)
;                      (node-linear-filter fn)
;                      )
;             (setq sum-prod (smooth-plm sum-prod 0))
;             )
           ; Copy node function if a beta factor and there are no incoming messages
           (when (and skip-product first-product)
             (setq sum-prod (copy-a-plm sum-prod))
             )
           ; Strip PLM of dimensions not part of PLM for variable node and reorder variables/dimensions as needed
           (unless (link-variables-same ml)
             (setq sum-prod (strip-and-reorder-plm (link-map ml) vn-vars sum-prod))
             )
           (setq sum-prod (remove-unneeded-slices sum-prod))
           )
          )
    ; If new PLM is epsilon-different from old, set it and add message to queue
    (cond ((plm-e= lc sum-prod arousal) ; Handle cases where initial message not changed, but it should be piecewise constant
           (unless (eq (plm-piecewise-constant lc) (plm-piecewise-constant sum-prod))
             (setf (plm-piecewise-constant lc) (plm-piecewise-constant sum-prod))
             )
           )
          (t
           (setf (aref (link-contents ml) fact-index) sum-prod)
           (setf (message-wm-driven m) wm-driven) ; If incoming messages is wm-driven, then so is outgoing
           (setq new-message t)
           )
          )
    new-message)
  )

; Test if the link has a message that should be used in the product
(defun use-link-in-var-product (l fn)
  (and (not (eq (link-fact-node l) fn)) ; Message is not from target factor node
       (link-fact-content l) ; There is a message (not being blocked by variable node being evidence)
       )
  )

; Strip off any initial links at a variable node that are not to be used in product
(defun strip-front-useless-links (ls fn)
  (do ((link-list ls (cdr link-list)))
      ((null link-list) nil)
    (when (use-link-in-var-product (car link-list) fn) (return link-list))
    )
  )

; Dynamically reorder messages coming into variable node for efficiency
(defun reorder-variable-product (ls)
  (sort (copy-seq ls) #'< :key #'(lambda (l) (if (link-fact-content l) (plm-size (link-fact-content l)) infinity)))
  )

(defvar destructive-product t)
(defvar dynamic-variable-product-ordering nil)

; Create a new working memory variable node
; vn-in and vn-out determine whether this is an incoming and/or outgoing WMVN
; l-in and l-out determine whether link points to the WMFN and/or WMVN
; Create an outgoing message from a variable node
; Just compute product of incoming messages (except for from outgoing node)
; can exponential predicates be vector predicates? Exponential predicates are not checked for vector normalization 
(defun outgoing-var-fact-message (m wm-driven)
  (let* ((ml (message-link m))
         (lc (link-var-content ml)) ; Message to send to factor node
         (vn (link-var-node ml)) ; Variable node from which message is sent
         (fn (link-fact-node ml)) ; Factor node to which message is sent
         (ls (node-links vn)) ; Links from variable node to factor nodes
         prod
         new-message ; Whether generate new message
         product-computed
         )
    ; Dynamically reorder links for product optimization
    (when dynamic-variable-product-ordering
      (setq ls (reorder-variable-product ls))
      )
    ; Instead of initializing prod to the 1 array and doing an extra product,
    ; initialize prod to first PLM not from the "to" node and not nil (i.e., from an evidence factor)
    (setq ls (strip-front-useless-links ls fn))
    (when ls ; When there are inputs to include in the product (node has more than one neighbor)
      (setq prod (link-fact-content (car ls))) ; Initialize product to message from first input
      (setq ls (cdr ls))
      ; Compute the product of the messages in prod (always of same rank so no offset)
      (dolist (l ls)
        (when (use-link-in-var-product l fn)
          (setq prod
;                (remove-unneeded-slices
                 (combine-plms (link-fact-content l) nil prod 'product (wm-nodep vn))))
;          )
        (unless product-computed (setq product-computed t))
        )
      ; Exponentiate messages out of WM VN nodes for exponential predicates
      (when (node-exponential vn)
        (when (node-normalize vn)
          (setq prod (normalize-plm prod nil product-computed))
          )
        (setq prod (transform-plm #'exponentiate-constant-times10-function prod nil nil product-computed))
        )
      ; This normalizes most outgoing messages from WM VN nodes
      (when (and (node-normalize vn)
                 (not (and
                       (graph-selected-predicate cg) ; There is not a selected predicate
                       (equal (predicate-wm (graph-selected-predicate cg)) fn) ; or not going to the SELECTED WMFN (for decisions and impasse detection)
                       ))
                 (not (eq (node-subtype fn) 'pass-through)) ; This is not a predictive pass through node
                 (not (eq (node-subtype fn) 'function)) ; Don't normalize messages going to predicate function nodes
                 )
        (setq prod
              (if (node-vector vn) 
                  (normalize-plm prod nil product-computed t) 
                (normalize-plm prod nil product-computed))
              ) 
        ) 
      (setq prod (remove-unneeded-slices prod))
      ; If new PLM is epsilon-different from old
      (cond ((plm-e= lc prod arousal) ; Handle cases where initial message not changed, but it should be piecewise constant
             (unless (eq (plm-piecewise-constant lc) (plm-piecewise-constant prod))
               (setf (plm-piecewise-constant lc) (plm-piecewise-constant prod))
               )
             )
            (t
             (setf (aref (link-contents ml) var-index) prod)
             (unless (wm-nodep fn)
               (setf (message-wm-driven m) wm-driven) ; If incoming messages is wm-driven, then so is outgoing
               )
             (setq new-message t)
             )
            )
      )
    new-message)
  )

; Check if a node is a variable node
(defun variable-nodep (n) (eq (node-type n) 'variable))

; Check if a node is a factor node
(defun factor-nodep (n) (eq (node-type n) 'factor))

; Compute average message time
(defun average-message-time ()
  (when (zerop number-of-messages)
    (error "Attempt to compute average message time over zero counted messages")
    )
  (coerce (/ sum-of-message-times number-of-messages) 'short-float)
  )

; Initialize message time variables
(defun init-message-times ()
  (setq trace-message-times t)
  (setq number-of-messages 0)
  (setq sum-of-message-times 0)
  (setq maximum-message-time 0)
  )

; Shortcut for print-message-times
(defun pmt ()
  (print-message-times)
  )

; Create and process an outgoing message from a node
(defun outgoing-message (m wm-driven trace)
  (let ((ml (message-link m))
        message-time new-message)
    (when trace-message-times
        (setq number-of-messages (+ number-of-messages 1))
        (setq message-time (get-internal-run-time)) ; Time before create message
        )
    (setq new-message (if (variable-nodep (link-node ml (message-index m)))
                          (outgoing-var-fact-message m wm-driven )
                        (outgoing-fact-var-message m wm-driven)))
    (when trace-message-times
      (setq message-time (- (get-internal-run-time) message-time)) ; Time to create message
      (setq sum-of-message-times (+ sum-of-message-times message-time))
      (when (> message-time maximum-message-time)
        (setq maximum-message-time message-time)
        )
      )
    (when (or (eq trace t) ; If t, trace all messages
              (and trace ; If non-nil
                   (listp trace) ; and a list
                   ; And either node is in the list of nodes to trace
                   (or (member (node-name (link-node ml 0)) trace)
                       (member (node-number (link-node ml 0)) trace)
                       (member (node-name (link-node ml 1)) trace)
                       (member (node-number (link-node ml 1)) trace)
                       )
                   )
              )
      ; Then print the message
      (print-message (concatenate 'string
                                  (when trace-wm-driven (format nil "{~S}" (message-wm-driven m)))
                                  (format nil ">>~S>> " (if (eq message-protocol 'serial) message-count '-))
                                  )
                     ml (message-index m) symbolic-trace nil t trace-stream)
      )
    new-message)
  )

; Get next message index
(defun next-message-index (mi)
  (mod (+ mi 1) 2))

; Process a message coming into a node
(defun incoming-message (m trace)
  (let* ((ml (message-link m)) ; Incoming messaage link
         (mi (message-index m)) ; Incoming message index
         (nmi (next-message-index mi)) ; Index for outgoing messages
         (in-from (link-node ml mi)) ; Source node for incoming message
         (in-to (link-node ml nmi)) ; Target node for incoming message
         out-to ; Target node for outgoing message
         out-message ; Outgoing message
         (wm-driven (message-wm-driven m)) ; Whether incoming message is wm-driven
         queue-message new-message
         (stale (aref (link-stale ml) mi))
        )
    (setq message-count (1+ message-count)) ; Increment global count of messages processed
    ; Compute message if not fresh and set it to fresh
    (when stale
      (setq new-message (outgoing-message m wm-driven trace))
      (setf (aref (link-stale ml) mi) nil)
      )
    (when (or (not stale) new-message)
      (when (or (eq trace t) ; If t, trace all messages
                (and trace ; If non-nil
                     (listp trace) ; and a list
                   ; And either node is in the list of nodes to trace
                     (or (member (node-name in-from) trace)
                         (member (node-number in-from) trace)
                         (member (node-name in-to) trace)
                         (member (node-number in-to) trace)
                         )
                     )
                )
        ; Then print the message
        (print-message (concatenate 'string
                                    (when trace-wm-driven (format nil "{~S}" (message-wm-driven m)))
                                    (format nil "<<~S<< " message-count)
                                    )
                       (message-link m) (message-index m) symbolic-trace t t trace-stream)
        )
      (dolist (l (node-links in-to)) ; Process all links at target node
        (setq out-to (link-node l mi)) ; Set target node for outgoing message
        (when (and
               (not (eq out-to in-from)) ; Not incoming link
               (link-content l nmi) ; The outgoing link is active in that direction
               (not (node-assumption in-to))
               )
          (setf (aref (link-stale l) nmi) t) ; Mark outgoing link as stale
          (setq queue-message (arc-in-queues l nmi (graph-queues cg)))
          (setq out-message (if queue-message (cadr queue-message) (make-message :link l :index nmi)))
          (setf (message-wm-driven m) wm-driven) ; If incoming messages is wm-driven, then so is outgoing
          (add-to-message-queue out-message)
          )
        )
      )
    t)
  )

; Figure out which depth message queue to pop and pop it
(defun pop-depth-message-queues (dqs)
  (dotimes (i (length dqs))
    (when (queue-not-empty (aref dqs i))
      (return (pop-queue (aref dqs i)))
      )
    )
  )

; Get message off of first queue with content
(defun pop-message-queues (qs)
  (cond ((depth-message-queues-not-empty (aref qs depth-queues-index))
         (pop-depth-message-queues (aref qs depth-queues-index)))    
        (t (pop-queue (aref qs other-queue-index)))
        )
  )

; Mark a link in a direction to signify that a message is incoming
(defun mark-incoming-message (message trace)
  (setf (aref (link-incoming (message-link message)) (message-index message)) t)
  (setq message-count (1+ message-count)) ; Increment global count of messages processed
  (when trace
    (print-message (concatenate 'string
                                (when trace-wm-driven (format nil "{~S}" (message-wm-driven message)))
                                (format nil "<<~S<< " message-count)
                                )
                   (message-link message) (message-index message) symbolic-trace t t trace-stream)
    )
  t)


; Process one message from queue
(defun process-one-message (trace)
  (interrupt-run)
  (let ((message (pop-message-queues (graph-queues cg))))
    (when message
      (setf (aref (link-counts (message-link message)) (message-index message))
            (1+ (aref (link-counts (message-link message)) (message-index message))))
      (if (eq message-protocol 'serial)
          (incoming-message message trace)
        (mark-incoming-message message trace)
        )
      )
    )
  )

; Process message queue until empty or reach limit
(defun process-message-queue (messages trace)
  (let ((max-steps (if messages messages max-messages))
        quiescent
        steps)
    (dotimes (i max-steps)
      (unless (process-one-message trace)
        (setq quiescent t)
        (setq steps i)
        (return steps))
      )
    (when (and (not quiescent) (= max-steps max-messages))
      (format trace-stream "~&Cut off at maximum messages per decision (~S)" max-steps)
      )
    steps)
  )

; Set all but the ith element of a vector to T
(defun set-all-but-i (v length i)
  (dotimes (x length)
    (unless (equal x i) (setf (aref v x) t))
    )
  v)

; Generate vector, one element for each link of a node, with T if should generate an output based on input
(defun generate-output-vector (n index)
  (let* ((num-links (length (node-links n)))
         (generate (init-vector num-links))
         (link-number 0))
    (dolist (l (node-links n))
      (when (aref (link-incoming l) (next-message-index index))
        (set-all-but-i generate num-links link-number))
      (setq link-number (+ link-number 1))
      )
    generate)
  )

; Generate all output messages for a node in parallel mode
(defun generate-node-messages (n index trace)
  (interrupt-run)
  (let ((generate (generate-output-vector n index))
        l)
    ; Generate the output messages for the node
    (do ((ls (node-links n) (cdr ls))
         (i 0 (+ i 1))
         )
        ((null ls) t)
      (setq l (car ls))
      (when (and (aref generate i) ; Should generate based on input
                 (link-content l index) ; The link is defined in this direction
                 )
        (outgoing-message (make-message :link l :index index) nil trace)
        )
      )
    )
  )

; Generate all output messages for a parallel elaboration cycle
(defun generate-outgoing-messages (trace)
  (dolist (n (graph-nodes cg)) ; Process links at all nodes in the graph
    (if (factor-nodep n)
        (generate-node-messages n fact-index trace)
      (generate-node-messages n var-index trace)
      )
    )
  )

; Set all incoming marks back to nil
(defun initialize-incoming-marks ()
  (dolist (l (graph-links cg))
    (setf (aref (link-incoming l) var-index) nil)
    (setf (aref (link-incoming l) fact-index) nil)
    )
  )

; Execute elaboration cycles (in parallel mode)
(defun elaboration-cycles (cycles trace)
  (let (starting-message-count ; Number of messages at beginning of cycle
        messages) ; Number of messages during a cycle
    (dotimes (cycle (if cycles cycles max-elaboration-cycles)) ; For each elaboration cycle
      (unless (message-queues-not-empty (graph-queues cg)) (return cycle))
      (setq starting-message-count message-count)
      (when trace-cycles
        (format trace-stream "~&Cycle ~S" cycle)
        )
      (process-message-queue nil trace) ; Process all of the messages as inputs
      (setq messages (- message-count starting-message-count))
      (generate-outgoing-messages trace) ; Genereate all output messages
      (initialize-incoming-marks) ; Set all incoming marks back nil
      (when trace-cycles
        (format trace-stream "~&~S Messages" messages)
        (setq cycle-message-counts (cons messages cycle-message-counts))
        )
      )
    )
)

; Check if anything is typed in the listener
; If it is, return t and flush the input
; Used for interrupting runs
(defun interrupt-run nil
  (when (listen)
    (clear-input)
    (throw 'interrupt-run interrupt-symbol)
    )
  )

; Load message queues from prequeue
(defun load-queues ()
  (dolist (l (graph-links cg))
    (dotimes (i 2)
      (when (aref (link-prequeue l) i)
        (add-to-message-queue (aref (link-prequeue l) i))
        (setf (aref (link-prequeue l) i) nil)
        )
      )
    )
  )

; Process message queue for default graph and trace values
(defun run (&optional cycles initial-run)
  (let (pre-time ; Time before measurement starts
        run-result) ; T or interrupt-symbol
    (when trace-performance (setq pre-time (get-internal-run-time)))
    (unless (graph-initialized cg)
      (init-graph)
      )
    (when (or initial-run (not have-run))
      (setq message-count 0)
      (when pre-run
        (pre-run) ; Execute pre-run forms
        )
      (update-graph-messages t) ; Reinitialize messages in graph given new WM/evidence
      (load-queues) ; Load messages from prequeue into queues
      )
    (setq have-run t) ; Mark that have already done a run (within the current decision)
    (when (and trace-performance (car global-decision-statistics))
      (setf (decision-statistics-init-time (car global-decision-statistics))
            (- (get-internal-run-time) pre-time))
      )      
    (when trace-performance (setq pre-time (get-internal-run-time)))
    (setq run-result (catch 'interrupt-run
                       (if (eq message-protocol 'serial)
                           (process-message-queue cycles trace-messages)
                         (elaboration-cycles cycles trace-messages)
                         )
                       )) ; Catch returns T if completes run and interrupt-symbol if interrupted
    (when (and trace-performance (car global-decision-statistics))
      (setf (decision-statistics-run-time (car global-decision-statistics))
            (- (get-internal-run-time) pre-time))
      (setf (decision-statistics-messages (car global-decision-statistics))
            message-count)
      )
    (when post-run
      (post-run) ; Execute post-run forms
      )
    run-result)
  )

(defun r (&optional steps do-pre-run) (run steps do-pre-run))
;-----------------------------------------------------------------
; Decision-making processes
; * creating and modifying WM values
; * perception
; * choosing
; * adding/removing states
;----------------------------------------------------------------
; Run a sequence of decisions, each with a max of 5000 run cycles
(defun decide (&optional cycles)
  (let (break ; Send messages but then break before first decision
        continue ; Continue after break, skipping initialization and message sending, and just doing decision
        return-value ; Result of decisions
        pre-time ; Time before measurement starts
        run-result ; Result of executing run
        )
    ; Initialize goals at very beginning of run
    (unless (graph-goals-set cg)
      (dolist (goal (graph-goal-list cg))
        (apply #'evidence (list goal))
        )
      (setf (graph-goals-set cg) t)
      )
    (when (eq cycles 'd) ; Do decision after a (d 0)
      (setq cycles 1)
      (setq continue t)
      )
    (unless cycles (setq cycles max-decisions))
    (when (zerop cycles)
      (setq cycles 1)
      (setq break t)
      )
    (setq return-value
          (catch 'decide
            (dotimes (i cycles)
              (unless continue
                (setq decision-count (+ decision-count 1))
                (when trace-performance
                  (setq global-decision-statistics
                        (cons (make-decision-statistics :number decision-count :messages 0 :run-time 0 :decision-time 0 :init-time 0 :learn-time 0)
                              global-decision-statistics))
                  )
                (when trace-decisions (format trace-stream "~&~%<<< Decision ~S >>>~%" decision-count))
                ; Increment time
                (when (or track-time episodic-learning)
                  (evidence `((,temporal-predicate-name (value ,decision-count))))
                  )
                ; Handle perception
                (when perceive-list
                  (perceive-list) ; Execute perceive forms to update perceive functions in WMFNs
                  )
                (update-global-appraisal-variables)
                (update-perception-memories)
                (setq run-result (run max-messages t)) ; Pass messages until quiescence (or max-messages)
                (setq have-run nil) ; Mark that the next run will be the initial one (for a new decision)
                (when track-graph-messages
                  (setq global-graph-messages (append global-graph-messages (list (graph-message-array))))
                  )
                (when (eq run-result interrupt-symbol) (return interrupt-symbol))
                (when (break-on-positive-messages)
                  (setq break t)
                  )
                )
              ; Make decisions and learn
              (cond (break
                     (format trace-stream "~&~%<<< Break Before Decision >>>~%")
                     (return)
                     )
                    (t
                     (when trace-preferences (print-preferences))
                     (when pre-d
                       (pre-d) ; Execute pre-decision forms
                       )
                     (when trace-performance (setq pre-time (get-internal-run-time)))
                     ; Intitialize variables for impasse detection
                     (cond (multiagent
                            (setq add-new-state (init-vector (graph-agents cg)))
                            (dotimes (i (length bottom-state))
                              (setf (aref delete-lower-states i) (1+ (aref bottom-state i)))
                              )
                            )
                           (t
                            (setq add-new-state nil)
                            (setq delete-lower-states (+ bottom-state 1))
                            )
                       )
                     ; Copy prediction perceptions to original predicates
                     (when diachronic-prediction (copy-diachronic-perception))
                     ; Actually make decisions and change working memory
                     (change-wm)
                     ; Add and delete states for impasses as appropriate
                     (when detect-impasses
                       (adjust-states)
                       ; Rewipe operators based on any changes made during state adjustment
                       (rewipe-operators-after-selection)
                       )
                     (when trace-performance
                       (setf (decision-statistics-decision-time (car global-decision-statistics))
                             (- (get-internal-run-time) pre-time))
                       )
                     (when trace-performance (setq pre-time (get-internal-run-time)))
                     ; Update conditional functions when doing gradient-descent learning
                     (when learn-via-gradient-descent
                       (update-functions-via-gradient)
                       )
                     (when trace-performance
                       (setf (decision-statistics-learn-time (car global-decision-statistics))
                             (- (get-internal-run-time) pre-time))
                       )
                     (compute-goal-progress) ; Compute goal progress
                     (when action-list
                       (action-list) ; Execute list of actions
                       )
                     (when post-d
                       (post-d) ; Execute post-decision forms
                       )
                     (when (haltp)
                       (return halt-symbol)
                       )
                     )
                    )
              )
            )
          )
    (when trace-performance (print-global-decision-statistics))
    return-value)
  )

(defun d (&optional cycles) (decide cycles))

; Rewipe operators based on any changes made during adjust-states
(defun rewipe-operators-after-selection nil
  (let* ((selected-pred (graph-selected-predicate cg))
         (selected-wm (predicate-wm selected-pred))
         )
    (when (and selected-pred (not (plm-full selected-operator-wipe)))
    ; Wipe out any operator for a state which has had a unique predicate change
    ; Do this again after selected predicate is processed in case operators reselected
      (when (and trace-wm-changes
                 (or (atom trace-wm-changes) (member 'selected trace-wm-changes))
                 )
        (format trace-stream "~&PLM to use for wiping out operators in changed SELECTED WM: ")
        (print-plm selected-operator-wipe t)
        )
      (setf (node-function selected-wm)
            (remove-unneeded-slices (combine-plms selected-operator-wipe nil (node-function selected-wm) 'product)))
      (when (and trace-wm-changes
                 (or (atom trace-wm-changes) (member 'selected trace-wm-changes))
                 )
        (format trace-stream "~&SELECTED WM after wiping out operators in changed SELECTED WM with adjusted states: ")
        (print-plm (node-function selected-wm) t)
        )
      )
    )
  )

; Copy perception function from *next predicate to original one
(defun copy-diachronic-perception nil
  (dolist (pred (graph-predicates cg))
    (when (and (predicate-perception pred)
               (predicate-predict pred)
               (not (plm-e= (node-function (predicate-perception pred))
                            (node-function (predicate-perception (predicate-predict pred)))))
               )
      (setf (node-function (predicate-perception pred)) (copy-a-plm (node-function (predicate-perception (predicate-predict pred)))))
      (when save-message-state
        (setf (aref (graph-changes cg) (node-number (predicate-perception pred))) t)
        )
      )
    )
  )



; Compute progress and difference on goals set in predicates based on the Bhattacharyya coefficient
; Also compute attention when there is also a surprise predicate
(defun compute-goal-progress nil
  (dolist (pred (graph-predicates cg))
    (let ((goal-pred (predicate-goal-predicate pred))
          (progress-pred (predicate-progress-predicate pred))
          (difference-pred (predicate-difference-predicate pred))
          (surprise-pred (predicate-surprise-predicate pred))
          (attention-pred (predicate-attention-predicate pred))
          pred-function ; Function used for predicate in computing progress
          goal-function ; Predicates goal function
          divisor-function ; Used to scale progress and difference by total mass of goal (so total is fraction of complete goal achievement)
          constraint-function ; Used in determing which portions of difference to ignore depending on parts of goals don't care about (i.e., parts that are 0)
          progress-function difference-function attention-function goal-based-function
          bc-plm ; BC coefficient
          hd-plm ; HD coefficient
          unique-ds ; Unique dimensions of predicate
          )
      (when progress-pred
        (setq unique-ds (unique-dimensions-predicate pred)) 
        (setq pred-function (if (open-world pred) (vn-posterior pred) (node-function (predicate-wm pred))))
        (setq goal-function (node-function (predicate-wm goal-pred)))
        (when trace-attention
          (when goal-function
            (format trace-stream "~&~%~S Goal Function:~&" (predicate-name pred))
            (print-smart goal-function t trace-stream)
            )
          (when pred-function
            (format trace-stream "~&~%~S Working Memory Function:~&"(predicate-name pred))
            (print-smart pred-function t trace-stream)
            )
          )
        (setq divisor-function (summarize-plm goal-function (all-but-agent-and-state-dimensions-plm goal-pred) 'integral #'vector-sum))
        ; Compute similarity/progress
        (setq bc-plm (bc-plms pred-function goal-function unique-ds))     
        ; Compute difference
        (setq hd-plm (hd-from-bc-plm bc-plm))
        (when trace-attention
          (when bc-plm
            (format trace-stream "~&~%~S Progress (Bhattacharyya Coefficient):~&" (predicate-name pred))
            (print-smart bc-plm t trace-stream)
            )
          (when hd-plm
            (format trace-stream "~&~%~S Difference (Hellinger Distance):~&" (predicate-name pred))
            (print-smart hd-plm t trace-stream)
            )
          )
         ; Constrain differences to 0 when no goal in region
        (setq constraint-function (integral-plm goal-function unique-ds))
        (setq hd-plm (combine-plms hd-plm nil constraint-function 'constrain-by-0))
        (when trace-attention
          (when constraint-function
            (format trace-stream "~&~%~S Constraint function that enables ignoring 0s in the Goal:~&" (predicate-name pred))
            (print-smart constraint-function t trace-stream)
            )
          (when hd-plm
            (format trace-stream "~&~%~S Asymmetric difference ignoring 0s in the Goal:~&" (predicate-name pred))
            (print-smart hd-plm t trace-stream)
            )
          (when divisor-function
            (format trace-stream "~&~%~S Goal mass (for scaling progress and difference):~&" (predicate-name pred))
            (print-smart divisor-function t trace-stream)
            )
          )
        ; Set up progress function
        (setq progress-function
              (strip-and-reorder-plm nil
                                     (node-variables (predicate-perception progress-pred))
                                     (combine-plms bc-plm ; Could be cheaper
                                                   nil
                                                   divisor-function
                                                   'divide-0)))
        (when trace-attention
          (when progress-function
            (format trace-stream "~&~%~S Progress Map:~&" (predicate-name pred))
            (print-smart progress-function t trace-stream)
            )
          )
        (setf (predicate-perception-temp-mem progress-pred) progress-function) ; Local progress function
        ; Set up difference function
        (setq difference-function
              (strip-and-reorder-plm nil
                                     (node-variables (predicate-perception difference-pred))
                                     (combine-plms hd-plm ; Could be cheaper
                                                   nil
                                                   divisor-function
                                                   'divide-0)))
        (when trace-attention
          (when difference-function
            (format trace-stream "~&~%~S Difference Map:~&" (predicate-name pred))
            (print-smart difference-function t trace-stream)
            )
          )
        (setf (predicate-perception-temp-mem difference-pred) difference-function) ; Local difference function
        )
      ; Compute attention
      (when attention-pred
        ; Use normalized difference or progress function, if exists, depending on whether predicate is closed or open world
        (when (and (closed-world pred) difference-function)
          (setq goal-based-function difference-function)
          (when (and (predicate-arguments difference-pred) (not (predicate-no-normalize difference-pred)))
            (setq goal-based-function (normalize-plm goal-based-function))
            )
          (when trace-attention
            (when goal-based-function
              (format trace-stream "~&~%~S Difference Map (Normalized):~&" (predicate-name pred))
              (print-smart goal-based-function t trace-stream)
              )
            )
          )
        (when (and (open-world pred) progress-function)
          (setq goal-based-function progress-function)
          (when (and (predicate-arguments progress-pred) (not (predicate-no-normalize progress-pred)))
            (setq goal-based-function (normalize-plm goal-based-function))
            )
          (when trace-attention
            (when goal-based-function
              (format trace-stream "~&~%~S Progress Map (Normalized):~&" (predicate-name pred))
              (print-smart goal-based-function t trace-stream)
              )
            )
          )
        (if surprise-pred
            (let ((surprise-function (predicate-perception-temp-mem surprise-pred)))
              (setq surprise-function (normalize-plm surprise-function))
              (when trace-attention
                (when surprise-function
                  (format trace-stream "~&~%~S Surprise Map (Hellinger distance) (Normalized):~&" (predicate-name pred))
                  (print-smart surprise-function t trace-stream)
                  )
                )
              (setq attention-function (if goal-based-function
                                           (combine-plms surprise-function nil goal-based-function 'por)
                                         surprise-function))
              )
          (setq attention-function goal-based-function))
        (when trace-attention
          (when attention-function
            (format trace-stream "~&~%~S Attention Map ~S:~&"
                    (predicate-name pred)
                    (if surprise-pred
                        (if progress-pred
                            (if (closed-world pred)
                                "Surprise POR Difference"
                              "Surprise POR Progress")
                          "Surprise")
                      (if (closed-world pred)
                          "Difference"
                        "Progress")))
            (print-smart attention-function t trace-stream)
            )
          )
        (setf (predicate-perception-temp-mem attention-pred) attention-function) ; Local attention function
        )
      )
    )
  )

; Run some number of trials
(defun trials (&optional trials continue)
  (let (decide-result)
    (unless continue ; Start anew
      (setq trial-count 0)
      ; Execute forms to be executed before all trials
      (when pre-ts (pre-ts))
      )
    (unless trials (setq trials 1))
    (catch 'interrupt-trials
      (dotimes (ti trials)
        (setq trial-count (+ trial-count 1))
        (when trace-trials
          (format trace-stream "~&~%>>> Trial ~S <<<~%" trial-count)
          )
        (when (get-state-predicate)
          (evidence '((state (state 0))))
          )
        ; Update temperature
        (setq temperature (funcall temperature-schedule))
        (setq temperature (max temperature temperature-minimum)) ; Avoid overflows when exponentiate the inverse
        (setq one-over-temperature (/ 1 temperature))
        ; Execute pre-trial forms
        (when pre-t (pre-t))
        ; Run until explicit halt (or hit max-decisions)
        (setq decide-result (d))
        (when (eq decide-result interrupt-symbol)
          (throw 'interrupt-trials interrupt-symbol)
          )
        (empty-wms)
        ; Execute post-trial forms
        (when post-t (post-t))
        )
      )
    )
  )
(defun ts (&optional trials) (trials trials))
; Get the predicate STATE if it is defined

(defun get-state-predicate nil
  (find 'state (graph-predicates cg) :key #'predicate-name)
  )


; -----------------------------------------------------------
; Create and modify working memory
; Perception


; Create a working memory factor node (WMFN) for a predicate
(defun init-wm (pred &optional constant)
  (let* (wm-node
         per-node
         (arguments (predicate-arguments pred))
         (rank (length arguments))
         (vars (init-vector rank))
         element type
         unique ; Variable is unique
         unique-args ; Predicate's unique argument(s)
         )
    ; Create the variables for the WMFN
    (dotimes (i rank)
      (setq unique nil)
      (setq element (elt arguments i))
      (setq type (type-from-name (argument-type-name element)))
      (setq unique-args (predicate-unique pred))
      (setq unique (if (symbolp unique-args)
                       (if (eq (argument-name element) unique-args) t nil)
                     (if (member (argument-name element) unique-args) t nil)))
      (setf (aref vars i)
            (make-svariable :name (convert-to-wm-variable-name (argument-name element))
                           :type type
                           :unique unique
                           :select (when unique (predicate-select pred))
                           ))
      )
    (setf (predicate-wm-variables pred) vars)
    ; Create the factor node
    (when (or open-world-wmfns
              (closed-world pred)
              )
      (setq wm-node
            (init-factor-node
             (concat-symbols (list (predicate-name pred) 'wm-fn) t)
             'wm
             vars
             nil ; Start off with no associated variable nodes
             t nil t nil nil nil)
            )
      (setf (node-assumption wm-node) t)
      (setf (node-function wm-node)
            (init-plm vars
                      (if constant constant (if (closed-world pred) 0 1))
                      0 (init-vector (length vars) t)))
      (when (state-predicate pred)
        (if multiagent
            (dotimes (ai (graph-agents cg))
              (delete-lower-states-node pred wm-node 1 ai)
              )
          (delete-lower-states-node pred wm-node 1))
        )
      (setf (predicate-wm pred) wm-node)
      (setf (node-predicate wm-node) pred)
      )
    ; Create a perception factor node if this is a perception predicate
    (when (predicate-perception pred)
      (setq per-node
            (init-factor-node
             (concat-symbols (list (predicate-name pred) 'per-fn) t)
             'perception
             vars
             nil ; Start off with no associated variable nodes
             t nil t nil nil nil)
            )
      (setf (node-assumption per-node) t)
      (setf (node-function per-node)
            (init-plm vars
                      (if constant constant (if (closed-world pred) 0 1))
                      0 (init-vector (length vars) t)))
      (when (state-predicate pred)
        (if multiagent
            (dotimes (ai (graph-agents cg))
              (delete-lower-states-node pred per-node 1 ai)
              )
          (delete-lower-states-node pred per-node 1))
        )
      (setf (predicate-perception pred) per-node)
      (setf (node-predicate per-node) pred)
      )
    wm-node)
  )

; Make a unique change, including zeroing out everything competing with the change when appropriate
(defun update-wm (r pred &optional blank-r)
  (let* ((pfn (predicate-wm pred)) ; WMFN
         (pf (node-function pfn)) ; WM function
         vs ; WM variables
         si ; Index of state in WM
         sd ; State dimension in new region
         ai ; Index of agent dimension (if any)
         ad ; Agent dimension (if any)
         ms ; State location below which should delete everything
         rcp ; Whether regions change PLM
         )
    (when (and (not open-world-wmfns) (open-world pred))
      (error "There is no WMFN for predicate ~S in UPDATE-WM." (predicate-name pred))
      )
    (setq rcp (update-function r pfn (predicate-name pred) blank-r))
    (when (and rcp (closed-world pred)) ; Changing a closed world predicate
      (setq vs (plm-variables pf)) ; Predicate WM variables
      (setq si (stype-index 'state vs)) ; State index
      (when si ; There is a state argument
        (setq sd (aref (region-dimensions r) si)) ; The state dimension in the region
        (when multiagent
          (setq ai (predicate-agent-arg-index pred)) ; Agent index
          (setq ad (aref (region-dimensions r) ai)) ; The agent dimension in the region
          )
        (setq ms (+ (max (if center-discrete-numeric-on-integer (+ (dimension-min sd) 1/2) (dimension-min sd)) base-level-state) 1)) ; Delete all below this maximum
        ; Possibly modify maximum based on delete-lower-states
        (if multiagent
            (do ((i (if center-discrete-numeric-on-integer (+ (dimension-min ad) 1/2) (dimension-min ad)) (+ i 1))) ; Cycle through all agents in region
                ((e>= i (dimension-max ad) t) nil)
              (when (<= ms (aref bottom-state i))
                (setf (aref delete-lower-states i) (min ms (aref delete-lower-states i)))
                )
              )
          (when (<= ms bottom-state) ; Single agent
            (setq delete-lower-states (min ms delete-lower-states)) ; Mark to delete all states lower than this and previous highest
            )
          )
        )
      )
    )
  )

; Empty a working memory
(defun empty-wm (pred)
  (empty-node-function (predicate-wm pred) (if (open-world pred) 1 0))
  (when (and save-message-state debug-descendants)
    (format trace-stream "~&Changing ~S WM" (predicate-name pred))
    )
  )

; Empty all working memories
(defun empty-wms ()
  (dolist (pred (graph-predicates cg))
    (when (and (or open-world-wmfns (closed-world pred))
               (predicate-wm pred))
      (empty-wm pred)
      )
    )
  )

; Create a region from a wme for a predicate
(defun wme-region (wme weight pred &optional evidence)
  (let (dps r span etype)
    (dolist (element wme)
      (setq etype (type-from-predicate-argument (element-argument-name element) pred))
      (unless etype
        (error "When creating a WM region, element argument ~S is not defined in predicate ~S."
               (element-argument-name element) (predicate-name pred))
        )
      (setq span (compute-span (element-content element) etype t))
      (setq dps (cons (cons (element-wm-index element pred)
                            (list (make-slice :location (car span))
                                  (make-slice :location (cadr span)))) dps))
      )
    (setq r (make-discrete-region dps (predicate-wm-variables pred) nil weight 0))
    (when evidence
      (setf (region-evidence r) t)
      )
    r)
  )

; Given a set of arguments for a wme to be added, generate args for the pre-inverse to be added
; The multiple arguments stay the same, but the unique ones expand to full scope of variable/dimension
(defun inverse-args (args pred)
  (let (eaname ia type multiple)
    (dolist (arg args)
      (setq eaname (element-argument-name arg))
      (setq type (type-from-predicate-argument eaname pred))
      (setq multiple (multiple-from-predicate-argument eaname pred))
      (if multiple
          (setq ia (cons arg ia))
        (setq ia (cons (list eaname (if (and (stype-numeric type) (stype-discrete type) center-discrete-numeric-on-integer)
                                        (list (+ (stype-min type) 1/2) (+ (stype-max type) 1/2))
                                      (list (stype-min type) (stype-max type)))
                             )
                       ia
                       )))
      )
    (reverse ia))
  )

; Create an inverse region for wiping out non-selected values
(defun inverse-region (pred fn positive args)
  (let (unique-ds ; Unique dimensions of function
        ias ; Inverses of args
        )
    (setq unique-ds (unique-dimensions (node-function fn) t))
    (when unique-ds
      (setq ias (inverse-args args pred))
      )
    (if (and unique-ds (e= positive 1))
        (wme-region ias 0 pred)
      nil)
    )
  )

; Add a single wme to WM of a predicate
(defun add-wme (pred-name positive args)
  (let ((pred (predicate-from-name pred-name t)) ; Predicate from predicate name
        wmfn ; The WM factor node for the predicate
        )
    (unless pred
      (error "Attempt to add a working memory element for the non-existant predicate ~S!" pred-name)
      )
    (when (and (not open-world-wmfns) (open-world pred))
      (error "There is no WMFN for predicate ~S in ADD-WME" pred-name)
      )
    (setq wmfn (predicate-wm pred))
    ; Update the WM factor function
    (if positive  
        ; Set new value to default weight (1 usually)
        ; Set all values for non-multiple variables (that aren't no-normalize) with a value of 1 for args to 0 as default
        (update-wm (wme-region args positive pred latch-evidence) pred (unless (predicate-no-normalize pred) (inverse-region pred wmfn positive args)))
      ; If closed world, set new value to 0
      (update-wm (wme-region args 0 pred) pred)) ; Just set value to 0 for now, fix later
    ; Update link contents and add messages from WM factor to WM variable nodes to queue when don't already exist
    (when save-message-state
      (setf (aref (graph-changes cg) (node-number wmfn)) t)
      )
    )
  )

; Handle evidence (adding it to appropriate WMs)
(defun evidence (es &optional empty-wms)
  (unless (graph-initialized cg)
    (init-graph)
    )
  (when empty-wms (empty-wms)) ; Useful when starting a new trial with the same rules
  (dolist (e es)
    (when (and (not open-world-wmfns)
               (open-world (predicate-from-name (car e)))
               )
      (error "Evidence cannot be provided for open-world predicates such as ~S when OPEN-WORLD-WMFNS is nil" (car e))
      )
    (let ((mode (cadr e))
          positive arguments)
      (cond ((or (eq mode negation-symbol) (e= mode 0)) ; Negated evidence
             (setq arguments (cddr e))
             )
            ((or (numberp mode) ; Positive valued evidence
                 (and (listp mode) ; Linear function evidence
                      (numberp (car mode)) ; Check this is a linear function rather than an argument
                      )
                 )
              (setq positive mode)
              (setq arguments (cddr e))
              )
             (t ; Positive Boolean evidence
              (setq positive 1)
              (setq arguments (cdr e))
              )
             )
      ; check whether there are new constants introduced in the evidence
      (when extend-type-constants-by-evidence (check-for-new-constants arguments (car e))) 
      (add-wme (car e) positive arguments)
      )
    )
  )

;-----------------------------------------------------------------
; Perception

; Handle perception
(defun perceive (ps &optional empty-wms)
  (unless (graph-initialized cg)
    (init-graph)
    )
  (when empty-wms (empty-wms) (empty-pers)) ; Useful when starting a new trial with the same rules
  (dolist (p ps)
    (let ((pred (predicate-from-name (car p)))
          pvs ; WM Node variables
          pf ; The perceptual function for a predicate
          ir ; Inverse region
          (original-p p) ; Save for printout
          (value 1) ; Default constant for region specified by percept percept
          )
      (unless (or (predicate-perception pred)
                  (and (predicate-predict pred)
                       (predicate-perception (predicate-predict pred))
                       )
                  )
        (error "Attempt to perceive for predicate ~S, which is not a perception predicate" (car p))
        )
      (setq pf (predicate-perception-temp-mem pred))
      (setq pvs (node-variables (if (predicate-perception pred)
                                    (predicate-perception pred)
                                  (predicate-perception (predicate-predict pred)))))
      ; Extract value to assign to region if there is one
      (when (and (> (length p) 1)
                 (numberp (cadr p)))
        (setq value (cadr p))
        (setq p (cdr p)) ; Set up so that the cdr below does the right thing
        )
      ; Check whether new constants are introduced
      (when extend-type-constants-by-evidence (check-for-new-constants (cdr p) (car original-p))) 
      (unless pf ; Need to initialize a new percept function for this predicate
        (setq pf (setf (predicate-perception-temp-mem pred) (make-constant-discrete-plm (number-list (length pvs)) pvs (if (closed-world pred) 0 1) 0)))
        )
      (unless (predicate-no-normalize pred)
        (setq ir (inverse-region pred (if (predicate-perception pred)
                                    (predicate-perception pred)
                                  (predicate-perception (predicate-predict pred)))
                                 value (cdr p)))
        (when ir
          (setq pf (update-region ir pf)) ; Zero out appropriate inverse region
          )
        )
      (setf (predicate-perception-temp-mem pred) (update-region (wme-region (cdr p) value pred) pf)) ; Update perception function with percept
      (when trace-perception
        (format trace-stream "~&~%Perception: ~S" original-p)
        )
      )
    )
  )

; Update perception factor nodes
(defun update-perception-memories nil
  (let (perpred pernode)
    (dolist (pred (graph-predicates cg))
      (setq perpred (if (and diachronic-prediction (predicate-predict pred))
                        (predicate-predict pred)
                      pred))
      (when (and (predicate-perception perpred)
                 (predicate-perception-temp-mem pred)
                 (not (plm-e= (node-function (predicate-perception perpred)) (predicate-perception-temp-mem pred)))
                 )
        (setq pernode (predicate-perception perpred))
        (setf (node-function pernode) (predicate-perception-temp-mem pred))
        (when (state-predicate perpred)
          (if multiagent
              (dotimes (ai (graph-agents cg))
                (delete-lower-states-node perpred pernode (+ (aref bottom-state ai) 1) ai)
                )
            (delete-lower-states-node perpred pernode (+ bottom-state 1)))
          )
        (setf (predicate-perception-temp-mem pred) nil)
        (when trace-perception
          (format trace-stream "~&~%Updated ~S perceptual function: " (predicate-name perpred)) (pplm (node-function pernode))
          )
        (when save-message-state
          (setf (aref (graph-changes cg) (node-number pernode)) t)
          )
        )
      )
    )
  )

; Empty one perceptual memory
(defun empty-per (pred &optional zero)
  (empty-node-function (predicate-perception pred) (if (and (not zero) (open-world pred)) 1 0))
  (when (and save-message-state debug-descendants)
    (format trace-stream "~&Changing ~S PERCEPTION" (predicate-name pred))
    )
  )

; Empty all perceptual memories
(defun empty-pers ()
  (dolist (pred (graph-predicates cg))
    (when (predicate-perception pred)
      (empty-per pred)
      )
    )
  )


; Maximize over selection dimension in a PLM
; If according-to-plm provided, use it to find the index and whether best or expected, rather than the plm itself
; This is to deal with the fact that a selection predicate may receive a change message from a non-selection prediction WMVN
(defun maximize-selection-dimension (plm &optional omit-maximals according-to-plm)
  (let ((max-plm plm)
        (test-plm (if according-to-plm according-to-plm plm))
        selection-ds)
    (dotimes (i (plm-rank plm))
      (if (best-variable (aref (plm-variables test-plm) i))
          (progn
            (setq max-plm (maximize-plm max-plm i omit-maximals selection-ds))
            (setq selection-ds (cons i selection-ds))
            )
        (if (expected-variable (aref (plm-variables test-plm) i))
            (setq max-plm (expected-value-plm max-plm i (not omit-maximals)))))
      )
    max-plm)
  )

; Create a weight vector (of length n+1) with a constant zeroth element and all else 0
(defun constant-weight-vector (n c)
  (let ((v (init-vector (+ n 1) 0)))
    (setf (aref v 0) c)
    v)
  )

; Set the function in a region to a constant weight vector
(defun set-constant-region (r c)
  (assign-function (constant-weight-vector (region-rank r) c) r)
  )

; Compute difference of max and min specified in a list
(defun max-min (pair)
  (- (cadr pair) (car pair))
  )

; Compute the span of a list of maximals
; Each maximal is (min max) so subtract max from min and add
(defun sum-differences (pairs)
  (apply #'+ (mapcar #'max-min pairs))
  )

; Return the point across the maximal subregions of the dimension
; corresponding to a point in the maximal span
(defun point-in-maximal-region (point dmaxs)
  (let (result min max span)
    (dolist (dmax dmaxs) ; dmax is a maximal subregion along dimension (min max)
      (setq min (car dmax)) ; Minimum of maximal subregion
      (setq max (cadr dmax)) ; Maximum of maximal subregion
      (setq span (- max min)) ; Span is length of maximal subregion
      (when (< point span) ; If the point is less than the span
        (setq result (+ min point)) ; The result we want is offset from the min by point
        (return result)
        )
      (setq point (- point span)) ; Reduce point by span
      )
    (unless result
      (error "Didn't find maximal point ~S in maximals ~S." point dmaxs)
      )
    result)
  )

; Determine if there is more than one maximal element
(defun multiple-maximals (mspan v)
  (if (stype-discrete (svariable-type v)) ; Discrete numeric or symbolic variable
      (> mspan 1.1) ; Give a bit of slop
    (> mspan epsilon21)) ; A bit of slop bigger than size of continous regions changed
  )

; Generate an impasse (returning a list of impasse regions)
; sd is the state dimension and ad is the agent dimension
; maximals is the list of operator maximals
; empty is true if the change message for the (selected) predicate is empty
(defun generate-impasse (sd ad maximals type empty)
  (let* ((ip (predicate-from-name 'impasse)) ; Impasse predicate
         (vs (plm-variables (node-function (predicate-wm ip)))) ; Impasse variables
         (ivs (initial-slice-vector vs))
         (si (stype-index 'state vs)); Index of state variable
         (oi (stype-index (graph-operator-type-name cg) vs)) ; Index of operator variable
         (ii (stype-index 'impasse vs)) ; Index of impasse variable
         (ai (predicate-agent-arg-index ip)) ; Index of agent variable
         maxrs ; Regions for maximals
         dps
         (impasse-type (type-from-name 'impasse))
         (sms (+ (if empty base-level-state (dimension-min sd)) 1)); State min slice + 1 (or 2 if change message is empty)
         (stype-index (position type (stype-constants impasse-type))) ; Index of impasse type
         )
    (if maximals
        (dolist (m maximals)
          (setq dps (list (list si ; State dimension bounds
                                (make-slice :location sms)
                                (make-slice :location (+ sms 1))
                                )
                          (list oi ; Operator dimension bounds
                                (make-slice :location (car m))
                                (make-slice :location (cadr m)))
                          (list ii ; Impasse dimension bounds
                                (make-slice :location stype-index)
                                (make-slice :location (+ stype-index 1)))
                          ))
          (when multiagent
            (setq dps (cons (list ai ; Agent dimension bounds
                                  (copy-slice (dimension-min-slice ad))
                                  (copy-slice (dimension-max-slice ad))
                                  )
                            dps)
                  )
            )
          (setq maxrs (cons (make-discrete-region dps vs ivs 1 0) maxrs))
          )
      (progn
        (setq dps (list (list si ; State dimension bounds
                              (make-slice :location sms)
                              (make-slice :location (+ sms 1))
                              )
                        (list ii ; Impasse dimension bounds
                              (make-slice :location stype-index)
                              (make-slice :location (+ stype-index 1)))
                        ))
        (when multiagent
          (setq dps (cons (list ai ; Agent dimension bounds
                                (copy-slice (dimension-min-slice ad))
                                (copy-slice (dimension-max-slice ad))
                                )
                          dps)
                )
          )
        (setq maxrs (cons (make-discrete-region dps vs ivs 1 0) maxrs))
        ))
    maxrs)
  )

; Are two lists of two elements e=?
(defun maximal-contained (x y)
  (and (e>= (car x) (car y) t)
       (e<= (cadr x) (cadr y) t)
       )
  )

; Is current selection one of the maximal changes?
; ms and pms are current and previous maximals for regioin
; us is the dimensions over which maximizing
; pr is 
(defun selection-still-maximal (ms pms us pr)
  (let ((found (not (region-e-empty pr))) ; Whether all current selections found in maximal changes
        msi pmsi)
    (when found
      (dolist (ui us)
        (setq msi (aref ms ui))
        (setq pmsi (aref pms ui))
        ; The only time there should be multiple maximals in the previously selected region is if it is a constant 0 (which has been ruled out above)
        (when (> (length pmsi) 1)
          (error "Not a single unique maximal for previous maximals along dimension ~S in region." ui)
          )
        (when (zerop (length pmsi))
          (setq found nil)
          ;(error "No maximal found for selection dimension ~S in selection-still-maximal" ui)
          )
        (unless (setq found (and found (member (car pmsi) msi :test #'maximal-contained)))
          (return found)
          )
        )
      )
    found)
  )

; Is there a NONE impasse for agent a at state s?
; Under assumption that the impasse function will never be huge, walk through all regions here
; rather than the earlier approach of finding the origin region for a and then s and then NONE
(defun impasse-none (a s)
  (let* ((ip (predicate-from-name 'impasse t))
         (impasse-fun (node-function (predicate-wm ip)))
         (ivs (plm-variables impasse-fun))
         (si (stype-index 'state ivs))
         (ai (predicate-agent-arg-index ip))
         (ii (stype-index 'impasse ivs))
         (iarray (plm-array impasse-fun))
         (n (position 'none (stype-constants (type-from-name 'impasse))))
         ir
         none
         )
    (dotimes (i (array-total-size iarray))
      (setq ir (row-major-aref iarray i))
      (when (and (or (not a) (and (e<= (region-min ir ai) a t) (e< a (region-max ir ai)))) ; Region is for agent a (or no agent)
                 (and (e<= (region-min ir si) s t) (e< s (region-max ir si))) ; Region is for state s
                 (and (e<= (region-min ir ii) n t) (e< n (region-max ir ii))) ; Region is for impasse type NONE
                 (e> (region-constant ir) 0) ; Region is non-empty
                 )
        (return (setq none t))
        )
      )
    none)
  )

; Does impasse match?
(defun impasse-matches-region (a ai s si n ii ir)
  (and (or (not ai) ; There is no agent
            (and (e<= (region-min ir ai) a t) (e> (region-max ir ai) a)) ; Agent within region
            )
       (e<= (region-min ir si) s t) (e> (region-max ir si) s) ; State within region
       (e<= (region-min ir ii) n t) (e> (region-max ir ii) n) ; Impasse type is within regions
       )
  )

; Is there a newly generated none impasse (in impasse-regions) for agent a at state s?
(defun new-impasse-none (a s)
  (let* ((ip (predicate-from-name 'impasse t))
         (ivs (node-variables (predicate-wm ip)))
         (si (stype-index 'state ivs))
         (ai (predicate-agent-arg-index ip))
         (ii (stype-index 'impasse ivs))
         (n (position 'none (stype-constants (type-from-name 'impasse))))
         none
         )
    (dolist (ir impasse-regions)
      (when (impasse-matches-region a ai s si n ii ir)
        (return (setq none t))
        )
      )
    none)
  )

; Create list of dimensions of selection variables in vector of variables
(defun selection-variable-list (vs)
  (let (svs)
    (dotimes (d (length vs))
      (when (selection-variable (aref vs d))
        (setq svs (cons d svs))
        )
      )
    svs)
  )

; Determine if should detect impasses at state (based on detect-impasses predicate)
(defun detect-impasses-state (smin &optional agent)
  (let* ((dip (graph-detect-impasses-predicate cg)) ; Detect-impasses predicate
         (vn (predicate-outgoing-vn dip)) ; Shared outgong vn for detect-impasses predicate if it exiss   
         )
    (if vn
        (eq (value-in-function-state dip (vn-posterior dip) smin 'value agent) 'true)
      t)
    )
  )

; Return a maximal subregion (either first or random) from a region
; Multiple variables keep whole extent
; Pick a maximal value along selection variables
; Assign a constant value of 1 to the region
; Detect impasses as appropriate
(defun maximal-subregion (predicate prev-max r)
  (let* ((pf (node-function (predicate-wm predicate))) ; Predicate WM node function
         (vs (predicate-wm-variables predicate)) ; Predicate WM variables
         (rank (length vs))
         (new-r (copy-region-full r)) ; Copy of original region
         (ds (region-dimensions new-r)) ; Dimensions of region
         (ms (region-maximals new-r)) ; Maximals for region
         (tm trace-maximals)
         (te trace-empty)
         (pname (predicate-name predicate)) ; Name of predicate
         (selected (eq pname 'selected))
         (us (selection-variable-list vs)) ; Positions of unique/selection variables
         (opi (when selected (car us))) ; When this is the selected predicate only one selection variable (operator)
         (pmr (region-point (region-mins-0 r) prev-max)) ; Region in prev-max plm containing min-point of change region r
         (pms (region-maximals pmr)) ; Maximals for region in prev-max
         (mspans (init-vector rank)) ; Total length of maximal span along selection dimensions
         (mvals (init-vector rank)) ; Chosen maximal values for selection dimensions
         (si (stype-index 'state vs)) ; Index of state dimension, if any
         sd ; State dimension, if any
         impasse ai ad an maximal-point
         spans-state ; Whether region spans full state dimension
         dls ; Value for delete-lower-states, whether multiagent or not
         double-none ; Whether generating a none impasse when there is already one at the level above
         )
    ; Compute total length of maximal spans for selection variables
    (dolist (i us)
      (setf (aref mspans i) (sum-differences (aref ms i)))
      )
    (when si (setq sd (aref ds si))) ; State dimension, if any
    (when (and multiagent selected detect-impasses)
      (setq ai (predicate-agent-arg-index predicate)) ; Index of agent dimension, if any
      (when ai
        (setq ad (aref ds ai)) ; Multiagent dimension, if any
        (setq an (region-min r ai)) ; Agent number for this region (assumes shattered so one agent per region)
        )
      )
    (when (and trace-wm-changes
               (or (atom trace-wm-changes) (member pname trace-wm-changes))
               (or (not sd)
                   (<= (dimension-max sd) ; State upper bound on region is less than or equal to
                       (+ (if an ; There is an agent dimension on this predicate
                              (aref bottom-state an)
                            (if (numberp bottom-state) ; There is only one agent
                                bottom-state
                              (reduce #'max bottom-state)))
                            1)) ; Upper bound on bottom-state state
                   )
               )
      (setq trace-maximals t)
      (setq trace-empty t)
      (format trace-stream "~&Computing maximal subregion for region (with selection variables maximized): ")
      (print-region r pf t trace-stream)
      (format trace-stream "~&Previous maximal subregion (with selection variables maximized): ")
      (print-region pmr pf t trace-stream)
      (setq trace-maximals tm)
      (setq trace-empty te)
      )
    (when sd ; There is a state dimension
      (setq spans-state (and (= (dimension-min sd) 0)
                             (= (dimension-max sd) max-state)
                             ))
      (setq dls (if an (aref delete-lower-states an) delete-lower-states))
      )
    ; Detect impasses
    (when (and detect-impasses ; Impasse detection is turned on
               selected ; Only impasse on the operator in selected (which does have a state dimension)
               (< (dimension-min sd) dls) ; When impasse detection not obviated by a higher change in the state hierarchy
               (detect-impasses-state (dimension-min sd))
               )
      (cond ((and (region-e-empty r) ; No maximal choice (maximal value is 0)
                  (region-e-empty pmr) ; Nothing currently selected
                  )
             (if (or (impasse-none (when ai (region-min r ai)) (region-min r si)) ; A none impasse above (keeps from generating an endless hierarchy of none impasses)
                     (new-impasse-none (when ai (region-min r ai)) (region-min r si)) ; A new none impasse above in impasse-regions
                     )
                 (setq double-none t)
               (progn
                 (setq impasse 'none)
                 (setf (aref ms opi) nil)
                 ))
             )
            ((and (not (region-e-empty pmr)) ; Operator is selected
                  (not (region-e-empty r)) ; There is an operator to select (ensuring they aren't all at 0)
                  (selection-still-maximal ms pms us pmr) ; Region shouldn't change (current selection still maximal)
                  )
             (setq impasse 'no-change) ; Then this is a no-change impasse
             (setf (aref ms opi) (aref (region-maximals pmr) opi))
             )
            ((and (multiple-maximals (aref mspans opi) (aref vs opi)) ; There is more than one maximal (none of which are previously selected)
                  (not (region-e-empty r)) ; There is an operator to select (ensuring they aren't all at 0)
                  (setq maximal-point (region-mins r))
                  (setf (aref maximal-point (+ opi 1)) (caar (aref ms opi)))
                  (e< (linear-value (extract-function r) maximal-point) 1) ; The maximal value is not "best"
                  )
             (setq impasse 'tie) ; Then this is a tie impasse
             )
            )
      )
    (cond (double-none
           nil) ; make no change
          (impasse
           (setq impasse-regions (append impasse-regions (generate-impasse sd ad (aref ms opi) impasse spans-state))) ; generate impasse regions
           (when trace-impasses
             (format trace-stream "~&>>> ~S impasse in ~S region " impasse pname)
             (if (eq impasse 'none)
                 (setq trace-maximals nil)
               (setq trace-maximals t))
             (setq trace-empty t)
             (print-region (if (eq impasse 'no-change) pmr r) pf symbolic-trace trace-stream)
             (setq trace-maximals tm)
             (setq trace-empty te)
             )
           (when (or (>= (dimension-max sd) ; State upper bound on region is equal to
                          (min (+ (if an (aref bottom-state an) bottom-state) 1) ; Upper bound on bottom state
                               (if an (aref delete-lower-states an) delete-lower-states))) ; State at which to start deleting    
                     )
             ; Set flag(s) concerning need for a new state
             (if multiagent
                 (setf (aref add-new-state an) t)
               (setq add-new-state t) ; Set flag true
               )
             )
           nil) ; Return nil if there is no change in value (an impasse)
          ((region-e-empty r) ; Signal that nothing is to be selected
           'empty
           )
          (t
           (cond ((selection-still-maximal ms pms us pmr) ; Region shouldn't change (current selection still maximal)
                  (setq new-r nil) ; Mark no change region
                  )
                 ((or (and selected (eq operator-best-select 'random))
                      (and (not selected) (eq non-operator-best-select 'random))
                      )
                  (dolist (ui us)
                    (setf (aref mvals ui) (point-in-maximal-region (random (aref mspans ui)) (aref ms ui))) ; Point in region corresponding to point in span
                    )
                  )
                 (t ; Select first among maximal subregions
                  (dolist (ui us)
                    (setf (aref mvals ui) (caar (aref ms ui)))
                    )
                  )
                 )
           (when new-r
             ; Restrict region along dimension to interval starting at random maximal point
             (dolist (ui us)
               (setf (dimension-min-slice (aref ds ui)) (make-slice :location (aref mvals ui)))
               (setf (dimension-max-slice (aref ds ui)) (make-slice :location (+ (aref mvals ui) (if (stype-discrete (svariable-type (aref vs ui))) 1 epsilon2))))
               )
             (set-constant-region new-r 1)
             (when (and trace-wm-changes
                        (or (atom trace-wm-changes) (member pname trace-wm-changes)))
               (format trace-stream "~&New maximal subregion: ")
               (setq trace-maximals nil)
               (setq trace-empty t)
               (print-region new-r pf t trace-stream)
               (setq trace-maximals tm)
               (setq trace-empty te)
               )
             )
           new-r) ; Return new region if there is a change (which is nil if existing is to be kept)
          )
    )
  )

; Ensure that a predicate WM with selection variables has only one value per combination of multiple variables
; First set entire region to 0 and then add one element with maximum value at 1
(defun change-wm-selection (predicate prev-max changes-max)
  (let* ((crarray (plm-array changes-max))
         changed-regions
         (pname (predicate-name predicate))
         point cr zero-region ds d v
         (rank (plm-rank changes-max))
         (vs (predicate-wm-variables predicate))
         (piecewise-constant (plm-piecewise-constant changes-max))
         )
    (dotimes (i (array-total-size crarray))
      (setq cr (row-major-aref crarray i))
      (when (or (eq pname 'selected) ; Always call for selected so can detect impasses
                (not (region-e-empty cr piecewise-constant)) ; Make changes if change region is non-empty
                )
        (setq point (maximal-subregion predicate prev-max cr)) ; Pick one maximal subregion from region
        (when point ; If select a point (no impasse)
          (setq zero-region (set-constant-region cr 0))
          (when (and trace-wm-changes
                     (or (atom trace-wm-changes) (member pname trace-wm-changes))
                     )
            (format trace-stream "~&Region zeroed before unique changes in predicate ~S: " pname)
            (setq ds (region-dimensions cr))
            (dotimes (i rank)
              (setq d (aref ds i))
              (setq v (aref vs i))
              (format trace-stream "~S: " (svariable-name v))
              (print-dimension (dimension-min d) (dimension-max d) v t)
              (format trace-stream "; ")
              )
            )
          (if (eq point 'empty)
              (update-wm zero-region predicate) ; Whole region should be zeroed
            (update-wm point predicate zero-region)) ; Set all of region r in pred-wm to 0 and then maximal point to 1
          (setq changed-regions (cons cr changed-regions))
          )
        )
      )
    changed-regions)
  )

; Create an empty region for selected-operator-wipe corresponding to state span of unique change region (of another predicate)
; uc is a unique region that has been changed
; uc-vars is the vector of variables for the changed region
(defun selected-region-from-unique-change (uc uc-vars uc-pred)
  (let ((selected-vars (plm-variables selected-operator-wipe)) ; Variables in selected predicate
        wipe-region ; Region of selected predicate to wipe
        wr-si ; State index in wipe-region
        uc-si ; State index in unique change
        wr-sd ; State dimension in wipe region
        wr-ai ; agent index in wipe-region
        uc-ai ; agent index in unique change
        wr-ad ; agent dimension in wipe region
        )
    (setq wipe-region (make-spanning-region selected-vars nil 0 0))
    ; Restrict state dimension to state(s) in unique change
    (setq wr-si (stype-index 'state selected-vars))
    (setq uc-si (stype-index 'state uc-vars))
    (setq wr-sd (aref (region-dimensions wipe-region) wr-si))
    (setf (dimension-min-slice wr-sd) (make-slice :location (region-min uc uc-si)))
    (setf (dimension-max-slice wr-sd) (make-slice :location (region-max uc uc-si)))
    ; When multiagent, restrict state dimension to agent(s) in unique change
    (when multiagent
      (setq wr-ai (predicate-agent-arg-index (predicate-from-name 'selected)))
      (setq uc-ai (predicate-agent-arg-index uc-pred))
      (setq wr-ad (aref (region-dimensions wipe-region) wr-ai))
      (setf (dimension-min-slice wr-ad) (make-slice :location (region-min uc uc-ai)))
      (setf (dimension-max-slice wr-ad) (make-slice :location (region-max uc uc-ai)))
      )
    wipe-region)
  )

; Update WM based on actions
(defun change-predicate-wm (predicate)
  (let* (prev-max ; Previous WM with unique variables maxed out
         changes-max ; Changes with unique variables maxed out
         (pred-wm (predicate-wm predicate)) ; Predicate WMFN node
         (wm-plm (node-function pred-wm)) ; WM function
         (wm-vars (predicate-wm-variables predicate)) ; Variables in WM function
         (changes (wm-change-message predicate)) ; Change PLM
         (pred-name (predicate-name predicate))
         (selected (eq pred-name 'selected))
         unique-changes ; Unique regions changed
         sv ; Selection variable
         changed-negative ; Whether actually make any negative changes
         ai ; Agent variable index
         (tm trace-maximals)
         )
    (when (and trace-wm-changes
               (or (atom trace-wm-changes) (member pred-name trace-wm-changes))
               )
      (format trace-stream "~&~%")
      )
    ; Shatter PLMs on agent dimension if this is the selected predicate and are multiple agents and we're detecting impasses
    (when (and selected multiagent detect-impasses)
      (setq ai (predicate-agent-arg-index predicate))
      (setq wm-plm (shatter-plm wm-plm ai))
      (setf (node-function pred-wm) wm-plm) ; Put shattered plm back into WMFN so maximal-regions can find it
      (when changes
        (setq changes (shatter-plm changes ai))
        )
      )
    (when (and selected (not (plm-full selected-operator-wipe)))
      ; Wipe out any operator for a state which has a unique predicate change
      ; Need to do this after all predicates other than selected are processed but
      ; before selected is processed to avoid generating impasses for wiped operators
      ; Assumes selected is the last predicate processed
      (when (and trace-wm-changes
                 (or (atom trace-wm-changes) (member pred-name trace-wm-changes))
                 )
        (format trace-stream "~&SELECTED WM before wiping out operators: ")
        (print-plm wm-plm t)
        (format trace-stream "~&PLM to use for wiping out operators in SELECTED upon unique state changes: ")
        (print-plm selected-operator-wipe t)
        )
      ; Wipe out operators based on unique state changes
      (setq wm-plm
            (remove-unneeded-slices (combine-plms selected-operator-wipe nil wm-plm 'product)))
      (when (and (and trace-wm-changes (or (symbolp trace-wm-changes) (member 'selected trace-wm-changes)))
                 (or (atom trace-wm-changes) (member pred-name trace-wm-changes))
                 )
        (format trace-stream "~&SELECTED WM after wiping out operators (but before changing SELECTED WM): ")
        (print-plm wm-plm t)
        )
      )
    (when changes ; There is a change message
      (when (and trace-wm-changes
                 (or (atom trace-wm-changes) (member pred-name trace-wm-changes))
                 )
        (format trace-stream "~&~S WM before updating via actions: " pred-name)
        (print-plm wm-plm symbolic-trace)
        (format trace-stream "~&~%Change message: ")
        (print-plm changes symbolic-trace)
        (format trace-stream "~&")
        )
      (setq sv (selection-variables wm-plm))
      (cond (sv ; There are selection variables in the predicate
             (when (member (predicate-select predicate) '(prob-match boltzmann))
               (if (> (length sv) 1)
                   (error "Probability matching and Boltmann selection only defined for a single selection variable, not the multiple in predicate ~S" pred-name)
                 (setq sv (car sv)))
               )
             (setq prev-max (maximize-selection-dimension wm-plm)) ; Maximize over selection variables in WM 
             (setq changes-max
                   (case (predicate-select predicate)
                     ((prob-match) (prob-match-plm changes sv))
                     ((boltzmann) (prob-match-plm changes sv #'boltzmann-function))
                     (t (maximize-selection-dimension changes nil wm-plm))
                     ))
             (when (and trace-wm-changes
                        (or (atom trace-wm-changes) (member pred-name trace-wm-changes))
                        )
               (format trace-stream "~&Change message with unique variables maximized: ")
               (setq trace-maximals t)
               (print-plm changes-max t)
               (setq trace-maximals tm)
               (format trace-stream "~&")
               )
             (multiple-value-setq (prev-max changes-max) (share-slices prev-max changes-max))
             ; Add best positive value (retaining existing value if still maximal)
             (setq unique-changes (change-wm-selection predicate prev-max changes-max))
             (when (or unique-changes changed-negative)
               (setq wm-plm (remove-unneeded-slices wm-plm))
               )
             ; When unique changes to state, and there are operators, set appropriate part of selected-operator-wipe to 0
             (when (graph-operator-type-name cg) ; there is an operator type
               (setq wm-vars (plm-variables wm-plm))
               (when (and (not selected) ; Not relevant for changes in the selected predicate
                          unique-changes ; Only do when there are unique changes
                          (stype-index 'state wm-vars) ; Only do when the predicate includes the state
                          )
                 (dolist (uc unique-changes)
                   (setq selected-operator-wipe (update-region (selected-region-from-unique-change uc wm-vars predicate) selected-operator-wipe pred-name))
                   )
                 )
               )
             )
            (t (setf (node-function pred-wm) changes))
            )
      ; When some change has been made to WM function for predicate
      (when save-message-state
        (setf (aref (graph-changes cg) (node-number (predicate-wm predicate))) t)
        (when debug-descendants
          (format trace-stream "~&Changing ~S WM" (predicate-name predicate))
          )
        )
      (when (and trace-wm-changes
                 (or (atom trace-wm-changes) (member pred-name trace-wm-changes))
                 )
        (cond ((plm-empty (node-function (predicate-wm predicate)))
               (format trace-stream "~&~S WM Empty After Changes~&" pred-name)
               )
              (t
               (format trace-stream "~&~S WM After Changes: " pred-name)
               (print-plm (node-function (predicate-wm predicate)) t)
               (format trace-stream "~&")
               )
              )
        )
      )
    )
  )

; Update WM based on actions
(defun change-wm ()
  (let ((selected-pred (graph-selected-predicate cg))
        selected-wm
        selected-vars ; Variables in selected predicate
        )
    ; If selection predicate defined, initialize function used to wipe out operators for states that have been changed via unique predicates
    (when selected-pred
      (setq selected-wm (predicate-wm selected-pred))
      (setq selected-vars (predicate-wm-variables selected-pred)) ; Variables in selected predicate
      (setq selected-operator-wipe (make-constant-discrete-plm (number-list (length selected-vars)) selected-vars 1 0))
      (setf (plm-piecewise-constant selected-operator-wipe) t)
      )
    (dolist (predicate (graph-predicates cg))
      (when (or open-world-wmfns (closed-world predicate))
        (change-predicate-wm predicate) ; Make changes to standard predicate
        ; When this is the selection predicate and there are some state changes, wipe corresponding operators
        ; This wipes out operators selected on this cycle (and before episodic memory is changed for the selected predicate)
        (when (and (eq (predicate-name predicate) 'selected) (not (plm-full selected-operator-wipe)))
          ; Wipe out any operator for a state which has had a unique predicate change
          ; Do this again after selected predicate is processed in case operators reselected
          (setf (node-function selected-wm)
                (remove-unneeded-slices (combine-plms selected-operator-wipe nil (node-function selected-wm) 'product)))
          (when (and trace-wm-changes
                     (or (atom trace-wm-changes) (member 'selected trace-wm-changes))
                     )
            (format trace-stream "~&SELECTED WM after wiping out operators (and changing SELECTED WM): ")
            (print-plm (node-function selected-wm) t)
            )
          )
        )
      )
    )
  )

; -----------------------------------------------------------
; Compute probability match (including Boltzmann) choice across one dimension of a PLM

; Return a region for a discrete point
; Handle case where we're centering on integers
(defun discrete-point (x)
  (let ((imin (floor x)))
    (list imin (+ imin 1)))
  )

; Compute probability matching choice over dimensions of a PLM, yielding a new PLM
; Given an optional transform to use before choice
; Doesn't actually eliminate the dimensions from the PLM, but makes them inactive
; Meaning is ambiguous for multiple dimensions, so works for one
(defun prob-match-plm (p d &optional transform)
  (let* ((rank (plm-rank p))
         rarray sizev sizev-1 size np rarrayn sizeln sizen
         integrals; Cumulative integrals by summary region
         rands ; Random numbers by summary region
         rintegral ; Integral of region
         discrete ; Whether dimension d is discrete
         r ; Region
         temp-sum ii ii0
        bp bpoint brand
        destructive-normalize
        )
    (setq discrete (stype-discrete (svariable-type (aref (plm-variables p) d))))
    (when trace-summarize
      (format trace-stream "~&~%PROBABILITY MATCHING")
      (format trace-stream "~&~%P: ") (print-plm p symbolic-trace trace-stream)
      (format trace-stream "~&~%DIMENSION: ~S" d)
      )
    (setq bp p)
    ; Convert incoming PLM to a normalized Boltzmann form (where functions are divided by temperature and exponentiated)
    (when (eq transform #'boltzmann-function)
      (setq bp (transform-plm transform p))
      (when trace-summarize
        (format trace-stream "~&~%BOLTZMANN TRANSFORM: ") (print-plm bp symbolic-trace trace-stream)
        )
      (when trace-summarize
        (format trace-stream "~&~%NORMALIZED BOLTZMANN TRANSFORM: ") (print-plm bp symbolic-trace trace-stream)
        )
      (setq destructive-normalize t)
      )
    (setq bp (normalize-plm bp d destructive-normalize))
    ; Initialize what would normally be done in LET, but needed to wait until bp was defined to be safe
    (setq rarray (plm-array bp))
    (setq sizev (dimension-sizes-v bp))
    (setq sizev-1 (vector-1 sizev))
    (setq size (array-total-size rarray))
    (setq np (init-summarize-plm bp d))
    (setq rarrayn (plm-array np))
    (setq sizeln (dimension-sizes np))
    (setq sizen (array-total-size rarrayn))
    (setq integrals (make-array sizeln :initial-element 0))
    (setq rands (make-array sizeln))
    ; Set random numbers by summary regions
    (dotimes (i sizen)
      (setf (row-major-aref rands i) (random 1.0))
      )
    ; Traverse regions of original PLM, determining probability matching points
    (setq ii (make-list rank :initial-element 0))
    (dotimes (i size)
      (setf r (row-major-aref rarray i))
      (setq rintegral (aref (integral-region r (list d)) 0)) ; Constant in region's integration along d
      ; Zero index along d
      (setq ii0 (copy-seq ii))
      (setf (nth d ii0) 0)
      (when (and (not (aref (region-maximals (apply #'aref rarrayn ii0)) d)) (> rintegral 0)) ; Haven't already found point for region and there is a positive integral over the region
        (setq temp-sum (+ rintegral (apply #'aref integrals ii0))) ; Add integral to running total
        (setq brand (apply #'aref rands ii0))
        (when (< brand temp-sum) ; Random number is less than cumulative integral after region
          (setq bpoint (+ (region-min r d) (* (/ (- brand (apply #'aref integrals ii0)) rintegral) (region-span r d))))
          (setf (aref (region-maximals (apply #'aref rarrayn ii0)) d) (list (if discrete (discrete-point bpoint) (continuous-point bpoint))))
          )
        (setf (apply #'aref integrals ii0) temp-sum)
        )
      (setq ii (next-index-list ii sizev-1 rank))
      )
    ; Copy integrals to region-constants of summary regions (exact values don't matter, but zero versus positive does)
    (dotimes (i sizen)
      (setf (region-constant (row-major-aref rarrayn i)) (row-major-aref integrals i))
      )
    ; Set selection dimension inactive
    (setf (aref (plm-active np) d) nil)
    (when (plm-piecewise-constant p)
      (setf (plm-piecewise-constant np) t)
      )
    np)
  )

;----------
; Determine if region would change any values in PLM if used to update it
(defun region-changes-plm (ur p)
  (let (differ
        (rarray (plm-array p))
        r
        )
    (dotimes (i (array-total-size rarray))
      (setq r (row-major-aref rarray i))
      (when (and (regions-overlap ur r)
                 (not (vector-e= (extract-function ur) (extract-function r)))
                 )
        (return (setq differ t))
        )
      )
    differ)
  )

; Determine whether any of the regions in the list alter the function
(defun regions-change-plm (urs p)
  (let (differ
        )
    (dolist (ur urs)
      (when (region-changes-plm ur p)
        (return (setq differ t))
        )
      )
    differ)
  )

; Create a list of regions from two regions where the values correspond to the second only where not overlapped by the first
; The predicate should be unique and the first region should cover a subrange of the second along the unique dimensions (ds)
(defun overlay-region (r1 r2 ds)
  (let ((rs (list r1))
        tr)
    (when (numberp ds) (setq ds (list ds))) ; Make sure there is always a list here
    (dolist (d ds)
      ; See if need to add an r2-based region that spans the scope before r1 starts
      (unless (e= (region-min r1 d) (region-min r2 d) t)
        (setq tr (copy-region-full r2))
        (setf (dimension-max-slice (aref (region-dimensions tr) d))
              (make-slice :location (region-min r1 d)))
        (setq rs (cons tr rs))
        )
      ; See if need to add an r2-based region that spans the scope after r1 ends
      (unless (e= (region-max r1 d) (region-max r2 d) t)
        (setq tr (copy-region-full r2))
        (setf (dimension-min-slice (aref (region-dimensions tr) d))
              (make-slice :location (region-max r1 d)))
        (setq rs (cons tr rs))
        )
      )
    rs)
  )

; Make a unique change, including zeroing out everything competing with the change when appropriate
(defun update-function (r node pred-name &optional blank-r)
  (let* ((pf (node-function node)) ; WM function
         (rcp (regions-change-plm (if blank-r (overlay-region r blank-r (unique-dimensions pf)) (list r)) pf))
         )
    (when rcp
      (when blank-r
        (setf pf (update-region blank-r pf pred-name))
        )
      (setf pf (update-region r pf pred-name))
      )
    (setf (node-function node) pf)
    rcp)
  )

; Shatter a PLM along a discrete dimension, yielding regions for each domain element
(defun shatter-plm (p d)
  (let* ((ptype (svariable-type (aref (plm-variables p) d)))
         (new-slices (init-vector (plm-rank p)))
         )
    (unless (stype-discrete ptype)
      (format trace-stream "~&~%Attempt to shatter a continuous dimension ~S of PLM: " d)
      (pplm p)
      (error "")
      )
    (dotimes (i (stype-span ptype))
      (setf (aref new-slices d) (cons (make-slice :location (+ i 1)) (aref new-slices d)))
      )
    (setf new-slices (sort-slice-list-array new-slices))
    (setq p (apply-slices new-slices nil p))
    p)
  )

; Modify two PLMs so that they have the same slices
(defun share-slices (p1 p2)
  (let ((s1 (plm-slices p1))
        (s2 (plm-slices p2)))
    (values (apply-slices s2 nil p1) (apply-slices s1 nil p2))
    )
  )

; Create an empty PLM with all active variables
(defun empty-plm (vars)
  (let ((p (init-plm vars 0 0 (init-vector (length vars) t))))
    (setf (plm-piecewise-constant p) t)
    p)
  )

; Create a full PLM with all active variables
(defun full-plm (vars)
  (let ((p (init-plm vars 1 0 (init-vector (length vars) t))))
    (setf (plm-piecewise-constant p) t)
    p)
  )

; -----------------------------------------------------------
; Add/remove states

; Find index of type in variable sequence
(defun stype-index (type vs)
  (position type vs :key #'(lambda (v) (stype-name (svariable-type v))))
  )

; Find highest slice in a list
(defun highest-slice (slices)
  (let (highest)
    (setq highest (car slices))
    (setq slices (cdr slices))
    (dolist (s slices)
      (when (e> (slice-location s) (slice-location highest)) ; New highest slice
        (setq highest s)
        )
      )
    highest)
  )

; Find lowest slice in a list
(defun lowest-slice (slices)
  (let (lowest)
    (setq lowest (car slices))
    (if (and (slice-index lowest) (= (slice-index lowest) 0))
        lowest
      (progn
        (setq slices (cdr slices))
        (dolist (s slices)
          (when (e< (slice-location s) (slice-location lowest)) ; New highest slice
            (setq lowest s)
            )
          )
        lowest))
    )
  )

; Find second highest slice in a list (upper bound on latest state)
(defun second-highest-slice (slices)
  (let (highest second)
    (setq highest (car slices))
    (setq slices (cdr slices))
    (dolist (s slices)
      (cond ((e> (slice-location s) (slice-location highest)) ; New highest slice
             (setq second highest)
             (setq highest s)
             )
            ((or (not second) ; There isn't already a second highest slice
                 (e> (slice-location s) (slice-location second))) ; Slice is higher than current second highest
             (setq second s)
             )
            )
      )
    second)
  )

; Fill impasse state for open-world predicates
(defun fill-open-world-state (bottom-state &optional agent-index)
  (let (pwm ; Predicate WM FN node
        p ; Function in pwm
        r ; Full region to use in modifying p
        bs ; Bottom state to use
        )
    (if agent-index
        (setq bs (aref bottom-state agent-index))
      (setq bs bottom-state)
      )
    (dolist (sp (graph-state-predicates cg)) ; Process every open-world predicate that has the state as an argument
      (unless (or (member (predicate-name sp) '(impasse selected)) ; Skip these predicates (which are now closed world, but keep for future in case)
                  (closed-world sp) ; Predicate is closed world
                  )
        (setq pwm (predicate-wm sp)) ; Predicate WM FN node
        (setq p (node-function pwm)) ; PLM in predicate's WM
        (setq r (make-spanning-region (plm-variables p) nil 1 0)) ; Create a full region for entire PLM
        ; Create a new restricted dimension for state
        ; Need to create a new dimension rather than modify old because dimension is shared by PLM
        (setf (aref (region-dimensions r) (stype-index 'state (plm-variables p)))
              (make-dimension :min-slice (make-slice :location bs)
                              :max-slice (make-slice :location (+ bs 1))
                              :weight 0)
              )
      ; Create a new restricted dimension for agent if there is one
      ; Need to create a new dimension rather than modify old because dimension is shared by PLM
        (when agent-index
          (setf (aref (region-dimensions r) (predicate-agent-arg-index sp))
                (make-dimension :min-slice (make-slice :location agent-index)
                                :max-slice (make-slice :location (+ agent-index 1))
                                :weight 0)
                )
          )
        (setq p (update-region r p))
        (when save-message-state
          (setf (aref (graph-changes cg) (node-number pwm)) t)
          )
        )
      )
    )
  )

; Cloning state at one higher location in state dimension
(defun clone-state (bottom-state) ; &optional agent-index
  (let (slice ; Slice to be moved
        loc ; Location of the slice
        pwm ; Predicate WM FN node
        p ; Function in pwm
        sd ; State dimension in p
        )
    (dolist (sp (graph-state-predicates cg)) ; Process every predicate that has the state as an argument
      (unless (or (member (predicate-name sp) '(impasse selected)) ; Skip these predicates
                  (and (not open-world-wmfns) (open-world sp)) ; Skip open-world predicates when don't have WMFNs
                  )
        (setq pwm (predicate-wm sp)) ; Predicate WM FN node
        (setq p (node-function pwm)) ; PLM in predicate's WM
        (setq sd (stype-index 'state (plm-variables p))) ; State dimension in PLM
        (setq slice (second-highest-slice (aref (plm-slices p) sd))) ; Upper (smaller) slice for previous state
        (setq loc (slice-location slice))
        (when (e> loc 0) ; There is  a substate in the WM function
          (when (e= loc bottom-state t) ; When there is content in the next highest state
            (setf (slice-location slice) (+ loc 1)) ; Create new state and copy previous to new state
            (when save-message-state
              (setf (aref (graph-changes cg) (node-number pwm)) t)
              )
            )
          )
        )
      )
    )
  )
; Get name of agent (when symbolic) or number
(defun agent-name (agent-index)
  (let ((at (graph-agent-type cg)))
    (if (stype-constants at)
        (nth agent-index (stype-constants at))
      agent-index)
    )
  )

; Get agent number from name (or number)
(defun agent-number (agent-name)
  (constant-index agent-name (graph-agent-type cg))
  )

; Delete lower states in a PLM than snum
; sp is the predicate, and p is the PLM
(defun delete-lower-states-function (sp p snum &optional agent-index)
  (let (empty-r ; Empty region for deleting lower states
        ai ; agent-index
        agent-type-min) ; Minimum value for agent type
    (setq empty-r (make-spanning-region (plm-variables p) nil 0 0)) ; Create an empty region for entire PLM
    ; Create a new restricted dimension for state
    ; Need to create a new dimension rather than modify old because dimension is shared by PLM
    (setf (aref (region-dimensions empty-r) (stype-index 'state (plm-variables p)))
          (make-dimension :min-slice (make-slice :location (if center-discrete-numeric-on-integer (- snum 1/2) snum))
                          :max-slice (make-slice :location (stype-max (type-from-name 'state)))
                          :weight 0)
          )
    ; Create a new restricted dimension for agent if there is one
    ; Need to create a new dimension rather than modify old because dimension is shared by PLM
    (when agent-index
      (setq ai (predicate-agent-arg-index sp))
      (setq agent-type-min (stype-min (svariable-type (aref (plm-variables p) ai))))
      (setf (aref (region-dimensions empty-r) ai)
            (make-dimension :min-slice (make-slice :location (+ agent-type-min agent-index))
                            :max-slice (make-slice :location (+ agent-type-min agent-index 1))
                            :weight 0)
            )
      )
    (setq p (update-region empty-r p)) ; Delete all of the information in the lower states (merging with empty region at end)
    )
  )

; Delete all states at snum and below and a node
; sp is the predicate for the node
(defun delete-lower-states-node (sp node snum &optional agent-index)
  (setf (node-function node) (delete-lower-states-function sp (node-function node) snum agent-index))
  (when (and save-message-state (graph-changes cg)) ; Don't do this if the graph-changes vector has not yet been defined
    (setf (aref (graph-changes cg) (node-number node)) t)
    )
  )

; Delete all states at snum and below
(defun delete-lower-states (snum &optional agent-index)
  (let (bs ; Bottom state (for agent)
        pn ; Perception node
        )
    (if agent-index
        (setq bs (aref bottom-state agent-index))
      (setq bs bottom-state)
      )
    (when trace-states
      (if (= snum bs)
          (progn
            (format trace-stream "~&Removing state ~S" snum)
            (when multiagent
              (format trace-stream " for agent ~S" (agent-name agent-index))
              )
            )
        (when (< snum bs)
          (format trace-stream "~&Removing states ~S to ~S" snum bs)
          (when multiagent
            (format trace-stream " for agent ~S" (agent-name agent-index))
            )
          )
        )
      )
    (if agent-index
        (setf (aref bottom-state agent-index) (- snum 1))
      (setq bottom-state (- snum 1))
      )
    (dolist (sp (graph-state-predicates cg)) ; Process every predicate that has the state as an argument
      (unless (and (not open-world-wmfns) (open-world sp)) ; Skip if open world and not WMFN
        (delete-lower-states-node sp (predicate-wm sp) snum agent-index)
        )
      (setq pn (predicate-perception sp))
      (when pn
        (delete-lower-states-node sp pn snum agent-index)
        )
      )
    )
  )

; Add and delete states for impasses as appropriate
(defun adjust-states nil
  (let (impasse-predicate impasse-state-index impasse-agent-index impasse-state-dim bs blank-r impasse-type-index impasse-type-dim impasse-type impasse-fun impasse-vars)
    (cond (multiagent
           ; Delete lower states in hierarchy as appropriate
           (dotimes (ai (graph-agents cg))
             (when (aref delete-lower-states ai)
               (delete-lower-states (aref delete-lower-states ai) ai)
               )
             )
           ; Move the bottom state for each agent to which adding a new state
           (dotimes (i (length add-new-state))
             (when (aref add-new-state i)
               (setf (aref bottom-state i)
                     (+ (aref bottom-state i) 1))
               (when trace-states
                 (format trace-stream "~&Adding state ~S for agent ~S" (aref bottom-state i) (agent-name i))
                 )
               (when open-world-wmfns
                 (fill-open-world-state bottom-state i)
                 )
               (evidence `((state (state ,(aref bottom-state i)))))
               )
             )
           )
          (t
           ; Delete lower states in hierarchy as appropriate
           (when delete-lower-states
             (delete-lower-states delete-lower-states)
             )
           ; Move the bottom state
           (when add-new-state
             (setq bottom-state (+ bottom-state 1))
             (when trace-states
               (format trace-stream "~&Adding state ~S" bottom-state)
               )
             (when open-world-wmfns
               (if impasse-copy-state
                   (clone-state bottom-state)
                 (fill-open-world-state bottom-state))
               )
             (evidence `((state (state ,bottom-state))))
             )
           )
          )
    (setq impasse-predicate (predicate-from-name 'impasse t))
    (when impasse-regions
      (setq impasse-state-index (stype-index 'state (predicate-wm-variables impasse-predicate)))
      (when multiagent
        (setq impasse-agent-index (predicate-agent-arg-index impasse-predicate))
        )
      (when impasse-predicate
        ; When saving message state, mark that the impasse predicate has been changed
        (when save-message-state
          (setf (aref (graph-changes cg) (node-number (predicate-wm impasse-predicate))) t)
          )
        (when debug-descendants
          (format trace-stream "~&Changing ~S WM" (predicate-name impasse-predicate))
          )
        )
      )
    (setq impasse-fun (node-function (predicate-wm impasse-predicate)))
    ; Add impasse regions to WM
    (dolist (ir impasse-regions)
      (setq bs (if multiagent (aref bottom-state (region-min ir impasse-agent-index)) bottom-state))
      (when (e<= (region-min ir impasse-state-index) bs t) ; Only update if region overlaps with active states
        (when (and (e> (region-span ir impasse-state-index) 1) ; Region covers more than one state
                   (e> (region-max ir impasse-state-index) (+ bs 1)) ; State upper bound exceeds bottom state
                   )
          (setq impasse-state-dim (aref (region-dimensions ir) impasse-state-index))
          (setf (dimension-min-slice impasse-state-dim) (make-slice :location (+ bs 1))) ; Cut off region at upper bound of bottom state
          )
        (setq blank-r (empty-region (copy-region-full ir)))
        (setq impasse-type-index (stype-index 'impasse (node-variables (predicate-wm impasse-predicate))))
        (setq impasse-type-dim (aref (region-dimensions blank-r) impasse-type-index))
        (setq impasse-type (type-from-name 'impasse))
        (setf (dimension-min-slice impasse-type-dim) (make-slice :location (stype-min impasse-type)))
        (setf (dimension-max-slice impasse-type-dim) (make-slice :location (stype-max impasse-type)))
        ; Wipe operators in regions for which a new impasse has been generated for the state above
        (when (region-changes-plm ir impasse-fun)
          (setq impasse-vars (plm-variables impasse-fun))
          (setq selected-operator-wipe (update-region (selected-region-from-unique-change ir impasse-vars impasse-predicate) selected-operator-wipe 'impasse))
          )
        (update-wm ir impasse-predicate blank-r)
       )
      )
    (setq impasse-regions nil)
    )
  )


; Learning
; --------
; Function for controlling what learning is turned on
; Given a call, only those forms of learning explicitly mentioned will be on
; except that gradient descent must always be on if diachronic prediction is
(defun learn (&optional ons)
  (dolist (on ons)
    (unless (member on '(:gd :gradient-descent :e :episodic :open :no-normal :action-model :am :perception-model :pm :rl :reinforcement-learning))
      (error "Unrecognized keyword ~S in (LEARN ~S).~&Known keywords are :gd :gradient-descent :e :episodic :open :no-normal :action-model :am :perception-model :pm :rl :reinforcement-learning." on ons)
      )
    )
  (setq episodic-learning (if (or (member ':e ons)
                                  (member ':episodic ons))
                              t
                            nil))
  (when (and episodic-learning (not track-time))
    (error "Can't turn on episodic learning unless TRACK-TIME is set to T before INIT is run.")
    )
  (setq automatic-action-models (if (or (member ':am ons)
                                        (member ':action-model ons))
                                    t
                                  nil))
  (setq automatic-perception-models (if (or (member ':pm ons)
                                            (member ':perception-model ons))
                                        t
                                      nil))
  (setq automatic-reinforcement-learning (if (or (member ':rl ons)
                                                 (member ':reinforcement-learning ons))
                                             t
                                           nil))
  (setq diachronic-prediction (if (or automatic-action-models
                                      automatic-perception-models
                                      automatic-reinforcement-learning
                                      episodic-learning)
                                  t
                                nil))
  (setq learn-via-gradient-descent (if (or (member ':gd ons)
                                           (member ':gradient-descent ons)
                                           automatic-action-models
                                           automatic-perception-models
                                           episodic-learning
                                           automatic-reinforcement-learning)
                                       t
                                     nil))
  (setq learn-open (member ':open ons))
  (setq learn-no-normal (member ':no-normal ons))
  (when episodic-learning
      (init-temporal-conditional)
      )
  (when learn-via-gradient-descent
    (setq feedback-to-functions t))
  (or learn-via-gradient-descent episodic-learning) ; Return T if any form of learning is turned on
  )

; -----------------------------------------------------------
; Episodic learning

; Initialize temporal predicates for episodic memory
(defun init-temporal-conditional nil
  (let ((pred (predicate-from-name temporal-predicate-name))
        )
    (setf (predicate-function pred) `((,smoothing-parameter *) (,(* 2 smoothing-parameter) 0)))
    (setf (predicate-learning-rate pred) .00000002)
    (compile-predicate-function pred)
    ; Temporal predicate and conditional for episodic memory
    (when episodic-learning
      (predicate temporal-predicate-name-episodic
                 :arguments (list (list 'value temporal-predicate-name distribution-symbol))
                 :function temporal-predicate-name
                 :learning-rate .0002)
      )
    )
  )

; For closed-world arguments, make them open-world by replacing ! with %
(defun convert-argument-open-world (arg)
  (if (eq (third arg) best-symbol)
      (list (first arg) (second arg) distribution-symbol)
    (copy-seq arg))
  )

; Define episodic memory predicates and conditionals for a newly defined predicate
(defun init-predicate-em (pred)
  (let* ((pname (predicate-name pred)) ; Name of predicate
         (pargs (predicate-arguments pred)) ; Predicate's argument list
         (opargs (mapcar #'convert-argument-open-world pargs)) ; Open world version of predicate arguments
         pelements ; List of elements for arguments to use in defining pattern
         lname ; Name of learning predicate
         sname ; Name of selection predicate
         rname ; Name of retrieval predicate
         epname ; Name of episodic memory version of predicate (open world)
         ep ; Episodic memory version of predicate (open world)
         )
    ; Create STATE predicate if doesn't already exist
    (unless (predicate-from-name 'state t)
      (system-predicate 'state :world 'closed :arguments (if multiagent '((agent agent) (state state)) '((state state))))
      )
    (setq epname (concat-symbols (list pname episodic-suffix) nil))
    (setq ep (predicate epname :arguments opargs)) ; Create episodic predicate
    (setq pelements (mapcar #'argument-to-element pargs))
    ; Episodic Learning
    (setq lname (concat-symbols (list temporal-predicate-name epname 'learn) t)) ; Episodic learning function predicate
    (predicate lname ; Episodic learning predicate
               :arguments (cons (list temporal-predicate-name temporal-predicate-name) opargs)
               :function 1
               :learning-rate .2
               :episodic t
               )
    (apply #'conditional (concat-symbols (list lname '*c)) ; Create conditional for learning episodic memory
           :conditions (list '(state (state (state)))
                               (list temporal-predicate-name (list 'value (list temporal-predicate-name)))
                               (cons pname pelements))
           :condacts (list (append (list lname `(,temporal-predicate-name (,temporal-predicate-name))) pelements))
;           :episodic t ; Just used for printing EM
           nil)
    ; Episodic Selection
    (setq sname (concat-symbols (list temporal-predicate-name epname 'select) t)) ; Episodic selection function predicate
    (predicate sname ; Episodic selection predicate
               :arguments (cons (list temporal-predicate-name temporal-predicate-name) opargs)
               :function lname
               :learning-rate 0
               )
    (apply #'conditional (concat-symbols (list sname '*c)) ; Create conditional for learning episodic memory
           :conditions (list '(state (state (state)))
                              (cons (concat-symbols (list pname prediction-suffix)) pelements))
           :condacts (list (list temporal-predicate-name-episodic (list 'value (list temporal-predicate-name)))
                           (append (list sname `(,temporal-predicate-name (,temporal-predicate-name))) pelements))
;           :episodic t ; Just used for printing EM
           nil)
    ; Episodic Retrieval
    (setq rname (concat-symbols (list temporal-predicate-name epname 'retrieve) t)) ; Episodic retrieval function predicate
    (predicate rname ; Episodic retrieval predicate
               :arguments (cons (list temporal-predicate-name temporal-predicate-name) opargs)
               :function lname
               :learning-rate 0
               )
    (apply #'conditional (concat-symbols (list rname '*c)) ; Create conditional for learning episodic memory
           :conditions (list '(state (state (state)))
                              (list temporal-predicate-name-episodic (list 'value (list temporal-predicate-name))))
           :condacts (list (cons epname pelements)
                           (append (list rname `(,temporal-predicate-name (,temporal-predicate-name))) pelements))
           :map t
;           :episodic t ; Just used for printing EM
           nil)
    (setf (predicate-em pred) (predicate-function-node (predicate-from-name lname)))
    (setf (predicate-em-predicate pred) ep)
    )
  )

; -----------------------------------------------------------
; Automatically create conditionals based on predicates for action models and perceptual prediction (perception and map functions)
; Gradient descent with diachronic processing takes care of the rest

; List of (closed-world unique state) predicates for which shouldn't learn because they depend on other predicates
(defun no-prediction-predicates nil
  (let (no-preds ; List of predicate names for which not to do prediction
        dwmfn ; Descendant wmfn node
        pred ; Predicate for descendant wmfn node
        )
    (dolist (n (graph-nodes cg))
      (when (wm-fnp n)
        (dolist (d (node-descendant-links n))
          (setq dwmfn (node-from-number (descendant-link-to d)))
          (setq pred (node-predicate dwmfn))
          (when (and (wm-fnp dwmfn)
                     (closed-world pred)
                     (predicate-unique pred)
                     (state-predicate pred)
                     (not (= (node-number n) (descendant-link-to d))) ; Ignore dependance on self
                     (not (and (predicate-predict pred)
                               (eq (predicate-name (node-predicate n)) (predicate-name (predicate-predict pred))) ; Ignore dependance on prediction predicate
                               ))
                     )
            (setq no-preds (adjoin (predicate-name pred) no-preds))
            )
          )
        )
      )
    (remove 'selected no-preds))
  )

; Create a list containing a variablized pattern, the list of variables, the list of types, and the list of arguments, for a predicate
; Retain-args is a list argument variable pairs where want to retain the variables
(defun variablize-predicate (predicate variable-count &optional retain-args)
  (let (var variables elements arguments preds types an found (pname (predicate-name predicate)))
    (dolist (arg (predicate-arguments predicate))
      (setq an (argument-name arg))
      (cond ((eq an 'state)
             (setq elements (cons '(state (s)) elements))
             )
            ((setq found (assoc an retain-args))
             (setq elements (cons (list an (cadr found)) elements))
             )
            (t
             (setq var (concat-symbols (list an variable-count) t))
             (setq variables (cons var variables))
             (setq types (cons (argument-type-name arg) types))
             (setq elements (cons (list an (list var)) elements))
             (setq arguments (cons an arguments))
             (setq preds (cons pname preds))
             )
            )
      )
    (list (cons pname (reverse elements)) (reverse variables) (reverse types) (reverse arguments) (reverse preds))
    )
  )
; Convert an argument with an original name to one with predicate name prepended to argument name
(defun convert-argument-predicate-name (arg pname)
  (cons (concat-symbols (list pname (car arg)) t) (cdr arg))
  )

; Convert argument names of a list of arguments
(defun convert-arguments-predicate-name (args pname)
  (mapcar #'(lambda (arg) (convert-argument-predicate-name arg pname)) args)
  )

; Create reinforcement learning
(defun create-reinforcement-learning nil
  (let (unique-state-predicates ; All of the unique close-world state predicates
        regular-variables ; The variables from regular (closed-world unique state) predicates that define the context for the learned functions
        types ; Types of variables
        arguments ; Arguments names for variables
        prediction-variables ; The variables from prediction (*next) predicates that define the context for the learned functions
        regular-argument-list ; Arguments from regular predicates to use in created predicates
        predicate-name-list ; Name of predicate that goes with each argument
        prediction-argument-list ; Arguments from prediction predicates to use in created predicates
        condition-list ; List of conditions to be used in prediction
        variablization ; A list containing a pattern, a list of variables, and a list of types for a predicate
        (context-variable-count 0) ; The count of how many context variables there are
        pred ; Predicate to use in conditional
        operator-variable ; Variable name used in selected predicate
        regular-predicate-arguments ; Arguments from the regular (closed-wold unique state) predicates
        prediction-predicate-arguments ; Arguments from the prediction (*next) predicates
        psp
        projected*next-value-variable ; Variable used for the value in projected*next
        reward-value-variable ; Variable used for the value in reward
        q-pred ; Q predicate
        selected-pattern ; Pattern for selected predicate
        regular-condition-list ; List of conditions for regular (closed-world state selection) predicates
        implicit-q-condition ; Pattern for use of implicit Q values as a condition
        )
    ; Determine all of the closed world unique state predicates that aren't no-models
    (dolist (predicate (graph-predicates cg))
      (when (and (closed-world predicate)
                 (not (predicate-no-models predicate))
                 (predicate-unique predicate)
                 (state-predicate predicate)
                 (not (member (predicate-name predicate) '(selected impasse))) ; Ignore selected and impasse predicates
                 )
        (setq unique-state-predicates (cons predicate unique-state-predicates))
        )
      )
    ; Create condition lists plus the variables and types to be used in the conditionals
    (dolist (usp unique-state-predicates)
      ; Regular predicate
      (setq variablization (variablize-predicate usp context-variable-count))
      (setq condition-list (cons (car variablization) condition-list))
      (setq regular-variables (append (cadr variablization) regular-variables))
      (setq types (append (caddr variablization) types))
      (setq arguments (append (cadddr variablization) arguments))
      (setq context-variable-count (+ (length (cadr variablization)) context-variable-count))
      (setq regular-predicate-arguments (append (convert-arguments-predicate-name (remove 'state (cdar variablization) :key #'car) (predicate-name usp)) regular-predicate-arguments))
      (setq predicate-name-list (append (nth 4 variablization) predicate-name-list))
      (setq regular-condition-list condition-list)
      ; Prediction predicate
      (setq psp (predicate-predict usp))
      (setq variablization (variablize-predicate psp context-variable-count))
      (setq condition-list (cons (car variablization) condition-list))
      (setq prediction-variables (append (cadr variablization) prediction-variables))
      (setq context-variable-count (+ (length (cadr variablization)) context-variable-count))
      (setq prediction-predicate-arguments (append (convert-arguments-predicate-name (remove 'state (cdar variablization) :key #'car) (predicate-name usp)) prediction-predicate-arguments))
      )
    (setq prediction-predicate-arguments (remove 'state prediction-predicate-arguments :key #'car))
    ; Create argument lists for predicates
    (do ((cns predicate-name-list (cdr cns))
         (cas arguments (cdr cas))
         (cts types (cdr cts)))
        ((null cns))
      (setq regular-argument-list (cons (list (concat-symbols (list (car cns) (car cas)) t) (car cts)) regular-argument-list))
      )
    (do ((cns predicate-name-list (cdr cns)) ; Argument names for both regular and *next state taken from the 
         (cas arguments (cdr cas))
         (cts types (cdr cts)))
        ((null cns))
      (setq prediction-argument-list (cons (list (concat-symbols (list (car cns) (car cas)) t) (car cts)) prediction-argument-list))
      )
    ; When it exists, add the selected predicate to the condition list
    (when (graph-selected-predicate cg)
      (setq variablization (variablize-predicate (predicate-from-name 'selected) context-variable-count))
      (setq selected-pattern (car variablization))
      (setq condition-list (cons selected-pattern condition-list))
      (setq operator-variable (caadr variablization)) ; Assumes operator variable is the first/only variable listed (since state is ignored)
      (setq context-variable-count (+ (length (cadr variablization)) context-variable-count))
      )

    ; Create types and predicates
    (new-type 'utility :numeric t :discrete t :min 0 :max 20)
    ; Predicate PROJECTED
    (setq pred (predicate 'projected :arguments (append regular-argument-list '((value utility %))) :function 1))
    (setq variablization (variablize-predicate pred context-variable-count regular-predicate-arguments))
    (setq context-variable-count (+ (length (cadr variablization)) context-variable-count))
    ; Predicate PROJECTED*NEXT
    (setq pred (predicate (concat-symbols (list 'projected prediction-suffix)) :arguments (append prediction-argument-list '((value utility %))) :function 'projected))
    (setq variablization (variablize-predicate pred context-variable-count prediction-predicate-arguments))
    (setq condition-list (cons (car variablization) condition-list)) 
    (setq context-variable-count (+ (length (cadr variablization)) context-variable-count))
    (setq projected*next-value-variable (caadr (assoc 'value (cdar variablization))))
    ; Predicate REWARD
    (setq pred (predicate 'reward :perception t :arguments (append prediction-argument-list '((value utility %)))
                          :function (list (append '(0) (stars (length prediction-argument-list)) '((0 20)))
                                          (append '(.1) (stars (length prediction-argument-list)) '((0 10))))))
    (setq variablization (variablize-predicate pred context-variable-count prediction-predicate-arguments))
    (setq condition-list (cons (car variablization) condition-list)) 
    (setq context-variable-count (+ (length (cadr variablization)) context-variable-count))
    (setq reward-value-variable (caadr variablization))
    ; Predicate Q
    (setq q-pred (predicate 'q :arguments (append regular-argument-list `((operator ,(graph-operator-type-name cg)) (value utility %))) :function 1))
    (setq variablization (variablize-predicate q-pred context-variable-count))
    (setq context-variable-count (+ (length (cadr variablization)) context-variable-count))

    ; Add implicit Q to conditions of backup conditionals
    (setq implicit-q-condition (append `(q (operator (,operator-variable))) regular-predicate-arguments '((value (q (:filter (* 0 .05)))))))
    (setq condition-list (cons implicit-q-condition condition-list))

    (setq regular-condition-list (reverse regular-condition-list))
    (setq condition-list (reverse condition-list))

    ; Create conditionals
    ;;; Conditional Q-C (retrieve Q values for current state)
    (conditional 'q-c
                 :conditions (cons '(state (state (s))) regular-condition-list)
                 :condacts (list (car (variablize-predicate q-pred context-variable-count regular-predicate-arguments)))
                 )

  ;;; Conditional SELECT-OPERATOR (select operator based on Q value)
  (conditional 'select-operator
               :conditions (append (cons '(state (state (s))) regular-condition-list)
                                   (list implicit-q-condition))
               :actions (list selected-pattern)
               )

    ;;; Conditional BACKUP-PROJECTED
    (conditional 'backup-projected
                 :conditions (cons '(state (state (s))) condition-list)
                 :actions (list (cons 'projected
                                      (append regular-predicate-arguments
                                              `((value (,projected*next-value-variable (:coefficient .95 :offset ,reward-value-variable :pad 0 :apply-coefficient-to-offset t))))
                                              ))
                                )
                 )

    ;;; Conditional BACKUP-Q
    (conditional 'backup-q
                 :conditions (cons '(state (state (s))) condition-list)
                 :actions (list (cons 'q (append regular-predicate-arguments `((operator (,operator-variable)) (value (,projected*next-value-variable (:coefficient .95 :offset ,reward-value-variable :pad 0 :apply-coefficient-to-offset t)))))))
                 )

    )
  )

; -----------------------------------------------------------
; Learn (gradient descent)

; Determine whether to trace learning for a node
(defun trace-gdl (node)
  (and trace-gdl
       (or (not (consp trace-gdl)) ; If its a symbol then assume true for all nodes
           (member (node-number node) trace-gdl)
           (member (node-name node) trace-gdl)
           (member (node-function-name node) trace-gdl)
           )
       )
  )

; Initialize a weighted gradient with the learning rate (i.e., the weight)
; D-length is the length of the normalization dimension, when provided
; lr is the learning rate
(defun initialize-weighted-gradient (variables lr)
  (make-constant-discrete-plm (number-list (length variables)) variables lr 0)
  )

; Compute integral over all dimensions of a PLM
; Just return value
(defun integral-over-all-dimensions-plm (plm)
  (dotimes (i (length (plm-variables plm)))
      (setq plm (integral-plm plm i))
      )
  (region-constant (plm-origin plm))
  )

; Compute integral over all dimensions of a PLM except for the state dimension if there is one
; Just return value
(defun integrate-out-all-but-state-dimension-plm (plm)
  (dotimes (i (length (plm-variables plm)))
    (unless (eq (stype-name (svariable-type (aref (plm-variables plm) i))) 'state)
      (setq plm (integral-plm plm i))
      )
    )
  plm
  )

; Compute average over all dimensions of a PLM
; Just return value
(defun average-over-all-dimensions-plm (plm)
  (dotimes (i (length (plm-variables plm)))
      (setq plm (average-plm plm i))
      )
  (region-constant (plm-origin plm))
  )

; Compute integral of function-message product at a conditional factor function node (a single number)
; Multiply incoming message times factor function and then integrate out all dimensions
; Currently assumes there are no universal variables or that it is okay to integrate over them
; Currently uses normalized incoming message rather than raw version
(defun integral-function-message-product (mf map nf tgdl)
  (let (f v)
    (setq f (combine-plms mf map nf 'product))
    (when tgdl
      (format trace-stream "~&Product of existing factor function and raw update function: ")
      (pplm f)
      )
    (setq v (integral-over-all-dimensions-plm f))
    (when tgdl
      (format trace-stream "~&Result of integrating over dimensions of product: ~S" v)
      )
    v)
  )

; Normalize over all dimensions of a PLM
; Intended to be used when no normalization dimension is provided
(defun normalize-over-all-dimensions-plm (plm &optional destructive)
  (let ((integral plm))
    (dotimes (i (length (plm-variables plm)))
      (setq integral (integral-plm integral i))
      )
    (transform-plm #'scale-function plm (/ 1 (region-constant (plm-origin integral))) nil destructive)
    )
  )

; Determing the volume of the span of the parents of a learned function
(defun parent-span (node)
  (let ((volume 1)
        (nd (node-normal node))
        (nvs (node-variables node))
        )
    (dotimes (d (length nvs))
      (unless (or (and (numberp nd) (= d nd)) (member d nd))
        (setq volume (* volume (stype-span (svariable-type (aref nvs d)))))
        )
      )
    volume)
  )

; Determing the volume of the span of a function's dimensions
(defun function-span (node)
  (let ((volume 1)
        (nvs (node-variables node))
        (nn (node-normal node))
        )
    (dotimes (d (length nvs))
      (when (member d nn)
        (setq volume (* volume (stype-span (svariable-type (aref nvs d)))))
        )
      )
    volume)
  )

; Compute the weighted gradient to be used in updating the node's function
; Assumes there is only one message into the node that has the same dimensions/variables as the node
(defun compute-weighted-gradient (node smooth)
  (let* ((link (car (node-links node)))
         (update (link-var-content link)) ; Feedback to use in updating
         (map (link-map link))
         (normal (node-normal node)) ; Index of the variable to normalize over, if any
         (nf (node-function node)) ; Previous factor function
         (vs (plm-variables nf))
         (tgdl (trace-gdl node))
         ifmp ; Value to divide by in scaling update
         epg-sub ; Subtractor for exponential-product gradient
         (lr (if (node-learning-rate node)
                 (node-learning-rate node)
               (if learning-rate-fraction-of-smoothing-parameter
                   (* learning-rate-fraction-of-smoothing-parameter smooth)
                 learning-rate)))
         (alr (if arousal (* arousal lr) lr))
         (wg (initialize-weighted-gradient vs alr))  ; Initialize plm with learning rate
         average ; Average function for subtraction
         ifmp-vars
         max-update ; Maximum value(s) of update function along normalization dimension(s)
         (predicate-argument-unique-positions (init-vector (length vs))) ; Which variables (by position) are unique arguments for GDL in predicate
         up ; unique position
         (pred (node-predicate node)) ; Predicate for node
         )
    (setf (plm-piecewise-constant wg) t)
    (when tgdl
      (format trace-stream "~&~%~%Gradient descent on node ~A with learning rate ~A" (node-name node) lr)
      (when arousal
        (format trace-stream " (and arousal rate of ~A, for an effective learning rate ~A)" arousal alr)
        )
      (format trace-stream ": ")
      (format trace-stream "~&Existing factor function: ")
      (pplm nf)
      (format trace-stream "~&~%Raw update function: ")
      (pplm update)
      (format trace-stream "~&~%")
      )
    (cond ((or (eq gdl-divide 'newer) ; Integrate over all variables that are unique in the conditional
               exponential-product-gradient ; Always use this with the exponential gradient
               )
;           (when (= (node-number node) 110) (break))
           (setq ifmp (combine-plms update map nf 'product))
           (when tgdl
             (format trace-stream "~&Product of existing factor function and raw update function: ")
             (pplm ifmp)
             )
           (setq ifmp-vars (plm-variables ifmp))
           ; Determine positions of unique variables from predicate
           (when pred
             (dolist (an (predicate-unique-for-gdl pred))
               (setq up (position-of-predicate-argument an pred))
               (when up
                 (setf (aref predicate-argument-unique-positions up) t)
                 )
               )
             )
           (dotimes (d (length ifmp-vars))
             (when (or (svariable-unique (aref ifmp-vars d))
                       (and pred
                            (aref predicate-argument-unique-positions d)
                            )
                       )
               (setq ifmp (integral-plm ifmp d))
               (setf (aref (plm-active ifmp) d) t) ; Mark integrated out dimension as active so that division works right
               )
             )
           (setq update (combine-plms update map ifmp 'divide-0))
           (when tgdl
             (format trace-stream "~&Divisor function for normalization (integral over unique dimensions of product): ")
             (pplm ifmp)
             (format trace-stream "~&Update function after normalization via integral over product: ")
             (pplm update)
             )
           )
          ((and (eq gdl-divide 'new) normal) ; Integrate over just the normal variable
           (setq ifmp (combine-plms update map nf 'product))
           (when tgdl
             (format trace-stream "~&Product of existing factor function and raw update function: ")
             (pplm ifmp)
             )
           (if (numberp normal)
               (progn
                 (setq ifmp (integral-plm ifmp normal))
                 (setf (aref (plm-active ifmp) normal) t) ; Mark integrated out dimension as active so that division works right
                 )
             (dolist (n normal)
               (setq ifmp (integral-plm ifmp n))
               (setf (aref (plm-active ifmp) n) t) ; Mark integrated out dimension as active so that division works right
               ))
           (setq update (combine-plms update map ifmp 'divide-0))
           (when tgdl
             (format trace-stream "~&Divisor function for normalization (integral over normal dimension of product): ")
             (pplm ifmp)
             (format trace-stream "~&Update function after normalization via integral over product: ")
             (pplm update)
             )
           )
          (gdl-divide ; Integrate over all variables
           (setq ifmp (integral-function-message-product update map nf tgdl))
           (unless (= ifmp 0) ; Only divide if not by 0
             (setq update (transform-plm #'scale-function update (/ 1 ifmp) nil t))
             )
           (when tgdl
             (if (= ifmp 0)
                 (format trace-stream "~&Update function not divided by integral because it is 0")
               (format trace-stream "~&Update function after division by integral (~S): " ifmp)
               )
             (pplm update)
             )
           )
          (normal ; Old normalization
           (if (numberp normal)
               (setq update (normalize-plm update normal t))
             (dolist (n normal)
               (setq update (normalize-plm update n t))
               ))
           (when tgdl
             (format trace-stream "~&Update function normalized over variable(s) ~S (dimension(s) ~S): "
                     (if (numberp normal)
                         (svariable-name (aref (node-variables node) normal))
                       (mapcar #'(lambda (n) (svariable-name (aref (node-variables node) n))) normal))
                     normal)
             (pplm update)
             )
           )
          (t (error "~&~%No way to normalize gradient in learning!"))
          )
    (when (and gradient-subtract-average ; Subtract the function's average from the function
               (not exponential-product-gradient) ; Never do with exponential-product gradient
               )
      (if normal
          (progn
            (setq average (if (numberp normal) (average-plm update normal) (average-plm-ds update normal)))
            (when tgdl
              (format trace-stream "~&Average to be subtracted from function:")
              (pplm average)
              )
            (setq update (combine-plms update nil average 'difference))
            )
        (progn
          (setq average (average-over-all-dimensions-plm update))
          (when tgdl
              (format trace-stream "~&Average to be subtracted from function: ~S" average)
              )
          (setq update (transform-plm #'add-to-function update (- average) nil t))
          ))
      (when tgdl
        (format trace-stream "~&Update function after average subtracted: ")
        (pplm update)
        )
      )
    ; When doing exponential product gradient, subtract divisor from update and multiply result by original factor function
    (when exponential-product-gradient
      (setq epg-sub (combine-plms update nil nf 'product))
      (when tgdl
        (format trace-stream "~&Unintegrated subtractor for exponential-product gradient: ")
        (pplm epg-sub)
        )
      (setq epg-sub (normalize-plm epg-sub normal t))
      (when tgdl
        (format trace-stream "~&Integrated subtractor (over child/normal variable(s)) for exponential-product gradient: ")
        (pplm epg-sub)
        )
      (setq update (combine-plms update nil epg-sub 'difference))
      (when tgdl
        (format trace-stream "~&Update function after subtraction: ")
        (pplm update)
        )
      (setq update (combine-plms nf nil update 'product))
      (when tgdl
        (format trace-stream "~&Update function multiplied times existing factor function: ")
        (pplm update)
        )
      )
    ; Multiply gradient by learning rate
    (setq update (combine-plms update map wg 'product))
    (when tgdl
      (format trace-stream "~&Update function discounted by learning rate of ~S: " alr)
      (pplm update)
      )
    ; Optionally limit maximum value in gradient
    (when max-gdl-increment
      (setq max-update update)
      (if (listp normal)
          (dolist (n normal)
            (setq max-update (maximize-plm max-update n))
            )
        (setq max-update (maximize-plm max-update normal)))
      (setq update (combine-plms max-update nil update 'gdl-scale))
      (when tgdl
        (format trace-stream "~&Max values in update function over normalization dimensions: ")
        (pplm max-update)
        (format trace-stream "~&Update function limited to maximum increment of ~S: " max-gdl-increment)
        (pplm update)
        )
      )
    ; When doing exponential product gradient, exponentiate the result (which currently is always a constant value)
    (when exponential-product-gradient
      (setq update (transform-plm #'exponentiate-constant-function update nil nil t))
      (when tgdl
        (format trace-stream "~&Update function exponentially transformed: ")
        (pplm update)
        )
      )
  update)
  )

; Span (product) across multipe stypes
(defun stype-spans (ts)
  (let ((prod 1))
    (dolist (tx ts)
      (setq prod (* prod (stype-span tx)))
      )
    prod)
  )

; Update the node's function by adding in the weighted gradient
(defun update-via-gradient (node)
  (let (new
        (normald (node-normal node)) ; The dimension to normalize over, if any
        min-new ; Smallest value in weighted gradient
        (tgdl (trace-gdl node))
        wg ; Weighted gradient
        smooth ; The value to use for smoothing
        smoothed ; Whether have done smooothing
        surprise-function
        (vector (node-vector node)) ;is a vector being learnt 
        )
    (setq smooth
          (if (node-smoothing-parameter node) ; Override
              (node-smoothing-parameter node)
            (if (and adaptive-smoothing normald)
                (/ .1 (+ (node-changes node) (if (numberp normald)
                                                 (stype-span (svariable-type (aref (node-variables node) normald)))
                                               (stype-spans (mapcar #'(lambda (x) (svariable-type (aref (node-variables node) x))) normald)))))
              smoothing-parameter)))
    (if vector (setq wg (compute-vector-gradient node smooth)) 
      (setq wg (compute-weighted-gradient node smooth))
      )
    (unless (plm-empty wg)
      (setf (node-changes node) (1+ (node-changes node)))
      (setq new (combine-plms (node-function node) nil wg (if exponential-product-gradient 'product 'sum)))
      (setq min-new (plm-extreme new #'< infinity))
      (when tgdl
        (format trace-stream "~&Updated function (unnormalized): ")
        (pplm new)
        )
      (cond (vector ;only perform vector normalization, no need for smoothing and resmoothing 
             ;(setq new (normalize-plm new normald t)) ;vector learning normalization required multiple iterations for learning, not normalizing learns quicker 
             (when tgdl
               (format trace-stream "~&Vector normalized updated function: ")
               (pplm new)
               )
             )
            (t ;default gradient descent case applies here if not processing vectors
             ; Need to shift whole gradient function up so that is above parameter (smoothing)
             (when (< min-new smooth)
               (setq smoothed t)
               (setq new (smooth-plm new smooth)) ; Shift up values below threshold
               (when tgdl
                 (format trace-stream "~&Smoothed (~S) unnormalized updated function: " smooth)
                 (pplm new)
                 )
               )
             (when normald ; There are normalization dimensions
               ; Both here and below, must be able to use subtractive when no normalization dimension as well
               (if (and gdl-subtractive-normalization (not exponential-product-gradient))
                   (setq new (subtractive-normalize-plm new smooth normald))
                 (setq new (normalize-plm new normald t)))
               )
             (when tgdl
               (format trace-stream "~&Normalized ")
               (when smoothed
                 (format trace-stream "smoothed ")
                 )
               (format trace-stream "updated function: ")
               (pplm new)
               )
             ; If normalization creates very small numbers (more than a factor of 10 smaller than parameter), redo smoothing and normalization
             (setq min-new (plm-extreme new #'< infinity))
             (when (< min-new (* smooth .1)) ; Need to shift whole gradient function up so that is above parameter (smoothing)
               (setq new (smooth-plm new smooth))
               (when tgdl
                 (format trace-stream "~&Resmoothed updated function: ")
                 (pplm new)
                 )
               (if normald ; There is a normalization dimension
                   (if (and gdl-subtractive-normalization (not exponential-product-gradient))
                       (setq new (subtractive-normalize-plm new smooth normald))
                     (setq new (normalize-plm new normald t)))
                 (setq new (normalize-over-all-dimensions-plm new t)))
               (when tgdl
                 (format trace-stream "~&Renormalized resmoothed updated function: ")
                 (pplm new)
                 )
               )
             )
            )
      ; Constrain any regions that were 0 in the original function to remain 0
      (setq new (combine-plms (node-restriction node) nil new 'product))
      ; Update the surprise function (unless :no-surprise or not computing)
      (when (and (node-predicate node) (predicate-surprise-predicate (node-predicate node)))
        (setq surprise-function (hd-plms (node-function node) new (unique-dimensions (node-function node))))
        (setq surprise-function (strip-and-reorder-plm
                                 (build-smap (node-variables (predicate-perception (node-surprise-predicate node))) (plm-variables surprise-function))
                                 (node-variables (predicate-perception (node-surprise-predicate node))) surprise-function))
        (when trace-attention
          (when surprise-function
            (format trace-stream "~&~%~S Surprise Map (Hellinger distance):~&" (predicate-name (node-predicate node)))
            (print-smart surprise-function t trace-stream)
            )
          )
        (setf (predicate-perception-temp-mem (node-surprise-predicate node)) surprise-function) ; Local surprise function
        )
      ; Update node function
      (setf (node-function node) new)
      ; Store the new function into all of the other CFF nodes that share the same function
      (dolist (shared (node-shared-functions node))
        (setf (node-function shared) new)
        )
      (when tgdl
        (format trace-stream "~&Function constrained by original zeros: ")
        (pplm new)
        )
      (when save-message-state
        (setf (aref (graph-changes cg) (node-number node)) t)
        (when debug-descendants
          (format trace-stream "~&Changing ~S Function" (node-name node))
          )
        (dolist (shared (node-shared-functions node))
          (setf (aref (graph-changes cg) (node-number shared)) t)
          (when debug-descendants
            (format trace-stream "~&Changing ~S Function" (node-name shared))
            )
          )
        )
      )
    )
  )

; Update all factor functions via their gradients
(defun update-functions-via-gradient ()
  (dolist (n (graph-nodes cg))
    (when (and (function-nodep n)
               (node-function-name n)
               (not (member (node-function-name n) do-not-learn))
               )
      (unless (or (not (link-var-content (car (node-links n)))) ; Link not active towards function
                  (plm-empty (link-var-content (car (node-links n)))) ; Empty message to function
                  (equal (node-learning-rate n) 0) ; Learning rate is 0
                  )
        (update-via-gradient n)
        )
      )
    )
  )

; -----------------------------------------------------------
; Create a Naive Bayes classifier for a UCI ML dataset and process data

; Define an attribute
(defun define-attribute (attribute value &optional category unsupervised)
  (if (eq (car value) 'symbolic) ; symbolic attribute
      (new-type attribute :constants (cdr value))
    (new-type attribute :numeric t :discrete (eq (car value) 'discrete) :min (cadr value) :max (caddr value)))
  (predicate attribute :perception t :world 'open :arguments `((,attribute ,attribute %)))
  (when (and category
             unsupervised
             (not (and (eq (car value) 'discrete)
                       (= (cadr value) 0)))
             )
    (error "The unsupervised category type ~S must be discrete numeric and start at 0!" attribute)
    )
  )
 
; Create a conditional with a uniform prior on the category
; Arguments are the name of the category and the number of values
(defun category-prior (cat-name nvs)
  (conditional (intern (concatenate 'string "PRIOR-" (format nil "~S" cat-name)))
               :condacts `((,cat-name (,cat-name (,cat-name))))
               :function-variable-names `(,cat-name)
               :normal cat-name
               :function `((,(/ 1.0 nvs) *))
               )
  )

; Generate random (in [0,1]) vector of length
(defun random-vector (length)
  (let ((v (init-vector length)))
    (dotimes (i length)
      (setf (aref v i) (random 1.0))
      )
    v)
  )

; Normalize vector
(defun normalize-vector (v)
  (let ((sum (reduce #'+ v)))
    (map 'vector #'(lambda (x) (/ x sum)) v)
    )
  )

; Generate a (normalized) random distribution in a vector
(defun random-distribution (length)
  (normalize-vector (random-vector length))
  )
(defun rd (length) (random-distribution length))

; Create a conditional with a uniform likelihood for the category and an attribute
; If the learning is unsupervised (i.e., if the optional types are specified) use a random likelihood function instead
(defun likelihood (att-name cat-name nvs atype ctype &optional unsupervised)
  (let (ca-pname pfun)
    (setq pfun (if unsupervised ; Generate random function for unsupervised learning
                   (let (fn d)
                     (dotimes (c (if center-discrete-numeric-on-integer (+ (stype-max ctype) 1/2) (stype-max ctype)))
                       (unless (stype-discrete atype)
                         (error "Unsupervised learning with continuous attribute (~S) is not yet supported!" att-name)
                         )
                       (setq d (random-distribution nvs))
                       (dotimes (a nvs)
                         (setq fn (cons (list (aref d a)
                                              c
                                              (if (stype-constants atype) (get-symbol-name a atype) (+ a (stype-min atype))))
                                        fn))
                         )
                       )
                     (reverse fn))
                 1))
    (setq ca-pname (predicate-name (predicate (concat-symbols (list cat-name att-name) t)
                                              :arguments `((,cat-name ,(stype-name ctype)) (,att-name ,(stype-name atype) %))
                                              :function pfun)))
    (conditional (intern (concatenate 'string "LIKELIHOOD" (format nil "-~S" cat-name) (format nil "-~S" att-name)))
                 :condacts `((,cat-name (,cat-name (,cat-name)))
                             (,att-name (,att-name (,att-name)))
                             (,ca-pname (,cat-name (,cat-name)) (,att-name (,att-name))))
                 )
    )
  )

; Define a data set with an initially uniform naive Bayes classifier for supervised learning
; If unsupervised is non-nil do clustering with a new category predicate
; avs is a list, for each of which the car is the name of the attribute and the cdr is its values
; The values can be a list of symbols or list within a list of (discrete/continuous :min :max)
; Assumes the category is the last attribute provided unless the first element of a sublist is * (category-symbol)
(defun define-data-set (avs &optional unsupervised trace)
  (let (type cat-type cat-pred)
    (init)
    (setq trace-gdl trace)
    (setq data-set-attributes nil) ; Reinitialize list of attributes (including category) in data set
    (setq data-set-category nil)
    ; Define types and predicates for attributes and category
    (dolist (av avs)
      (if (eq (car av) category-symbol)
          (progn
            (setq av (cdr av))
            (setq data-set-category (car av))
            (define-attribute (car av) (cadr av) t unsupervised)
            )
        (define-attribute (car av) (cadr av))
        )
      (setq data-set-attributes (cons (car av) data-set-attributes))
      )
    (unless data-set-category ; When no attribute is explicitly marked as the category
      (setq data-set-category (car data-set-attributes)) ; Assume it is the last category
      )
    (unless unsupervised
      (setq cat-pred (predicate-from-name data-set-category))
      (setf (predicate-function cat-pred) 1)
      (compile-predicate-function cat-pred)
      )
    (setq data-set-attributes (reverse data-set-attributes)) ; Yield attributes in order presented
    (setq cat-type (type-from-name data-set-category))
    ; Create conditionals and predicates for attribute-category pairs
    (dolist (av avs)
      (unless (or (eq (car av) category-symbol) (eq (car av) data-set-category)) ; Not the category
        (setq type (type-from-name (if (eq (car av) category-symbol) (cadr av) (car av))))
        (likelihood (car av) data-set-category (stype-span type) type cat-type unsupervised)
        )
      )
    )
  )

; Naive Bayes gradient-descent learning from data files

; Data stream for reading in instances
(defvar data-stream)

; Set things up to track results of testing
(defstruct gd-test-results attribute current true-positives true-negatives false-positives false-negatives)
(defvar gd-test-results)
(defun init-gd-test-results (att)
  (make-gd-test-results :attribute att :true-positives 0 :true-negatives 0 :false-positives 0 :false-negatives 0)
  )
(defun total-gd-test-results (tr)
  (+ (gd-test-results-true-positives tr) (gd-test-results-true-negatives tr)
     (gd-test-results-false-positives tr) (gd-test-results-false-negatives tr)
     )
  )

; Find test-result structure for an attribute
(defun find-gd-test-results (att)
  (find att gd-test-results :key #'gd-test-results-attribute)
  ); Update gd-test results (to be used within post-d)
; Only works if attribute uses T and F as its two values
(defun update-gd-test-results (atts)
       (let (tr current best)
         (dolist (att atts)
           (setq tr (find-gd-test-results att))
           (setq current (gd-test-results-current tr))
           (setq best (best-in-plm (vnp att)))
           (if (eq current t)
               (if (eq best t)
                   (setf (gd-test-results-true-positives tr)
                         (+ (gd-test-results-true-positives tr) 1))
                 (setf (gd-test-results-false-negatives tr)
                       (+ (gd-test-results-false-negatives tr) 1)))
             (if (eq best t)
                 (setf (gd-test-results-false-positives tr)
                       (+ (gd-test-results-false-positives tr) 1))
               (setf (gd-test-results-true-negatives tr)
                     (+ (gd-test-results-true-negatives tr) 1))))
           )
         )
       )


; Set up file to process one instance per decision
(defun setup-gd (file-name &optional test omit not-in-data)
  (let* (category-name)
    (setq data-stream (open file-name))
;    (setq pre-d '())
    (setq post-d `((update-gd-test-results ',omit)))
;    (setq post-t '())
    (learn (unless test '(:gd)))
    (when not-in-data ; assumes category is first in not-in-data, if exists
      (setq category-name (car not-in-data))
      )
    (when test
      (when category-name
        (setq pre-d `((format trace-stream "~&~%") (ppvn ',category-name)))
        )
      (setq gd-test-results (mapcar #'init-gd-test-results omit))
      )
    (setq perceive-list `((unless (listen data-stream)
                            (format trace-stream "*** No more instances in file. ***")
                            (throw 'decide t)
                            )
                          (instance (read-line data-stream) ',omit ',not-in-data) ; Set up perception for a test instance
                          )
          )
    t)
  )

; Create evidence for an instance specified as a comma-delimited string (one line from data set)
; If omit is provided, it is a list of attributes for which evidence shouldn't be specified
; The attributes in not-in-data are not even in the data
(defun instance (inst-s &optional omit not-in-data)
  (let (value comma-loc)
    (format trace-stream "~&~%*** Instance:")
    (empty-pers) ; Empty perceptual memories before adding the evidence
    (dolist (att-name data-set-attributes)
      (multiple-value-setq (value comma-loc) (read-from-string inst-s))
      (if (member att-name omit)
          (progn
            (setf (gd-test-results-current (find-gd-test-results att-name)) value)
            (format trace-stream " [~S:~S]" att-name value)
            )
        (unless (member att-name not-in-data) ; Create evidence for the attribute-value pair
          (format trace-stream " ~S:~S" att-name value)
          (perceive `((,att-name (,att-name ,(if (stype-discrete (type-from-name att-name)) value (list value (+ value epsilon2)))))))
          )
        )
      (when (< comma-loc (length inst-s)) ; There is another entry in the string
        (setq inst-s (subseq inst-s (+ comma-loc 1))) ; Move to next entry in the string
        )
      )
    )
  )

; -----------------------------------------------------------
; Dynamically extend a constant type

(defun check-for-new-constants (args pname) 
  (dolist (arg args)
    (let* ((pred (predicate-from-name pname))
           (constants (stype-constants (type-from-predicate-argument (car arg) pred)))
           checked-type
           )
      (when (and 
             constants ; there are constants
             (not (star-element (cadr arg))) ; the constant is not a star-element                
             (not (member (cadr arg) constants)) ; the constant is new
             )          
        (setf checked-type (type-from-predicate-argument (car arg) pred))
        (setf (stype-constants checked-type) (append (stype-constants checked-type) (list (cadr arg)))) ;update the type 
        (setf  (stype-max checked-type) (+  (stype-max checked-type) 1) )  ;update the number of constants for the type    
        (find-functions-using-type checked-type (cadr arg))   ; check the functions that use this type        
        )
      )
    )
  )

;the function types are explicitly stated; if new function types are introduced, this function needs to be updated.
(defun find-functions-using-type (checked-type new-constant)
  (let (nvs)
    (dolist (n (graph-nodes cg))
      (when (factor-nodep n)
        (setf nvs (node-variables n))
        (dotimes (i (length nvs)) 
          (when (eq (stype-name checked-type) (stype-name (svariable-type (aref nvs i)))) 
            (case (node-subtype n)
              (function (update-function-factors n checked-type new-constant))
              (beta (update-beta-factors n))
              (wm (update-wm-factors n))
              )
            )
          )
        )
      )
    )
  )

(defun update-function-factors (node checked-type new-constant)
  (let (condi condi-vars condi-normal p-vars (param 1) func)
    (setf condi (conditional-from-name (node-conditional-name node)))
    (setf condi-vars (conditional-function-variable-names condi))
    (setf condi-normal (conditional-normal condi))
    (setq p-vars (node-variables (conditional-last-memory condi)))
    
    (dotimes (i (length p-vars)) 
      (if (string-equal (svariable-name (aref p-vars i)) (stype-name checked-type)) (update-max-slice (aref (plm-slices (node-function node)) i)))
      )
      
    ;setting the conditional probability 
    (if condi-normal
        (setf param (/ param (if (symbolp condi-normal)
                                 (stype-span (type-from-name condi-normal))
                               (stype-spans (mapcar #'type-from-name condi-normal)))))
      (setf param (/ 1 (length (stype-constants checked-type))))   ; if there is normal defined, how do we do this?   
      )
   
    ;create the function
    (setf func `(,param))
    (dolist (cv condi-vars)
      (if (eq (stype-name checked-type) cv)
          (setf func (append func `(,new-constant)))
        (setf func (append func '(*)))
        ) 
      )

    (setf (node-function node) (update-region (cpt-region condi-vars func p-vars t) (node-function node)))
    (setf (aref (graph-changes cg) (node-number node)) t)
  )
)

(defun update-max-slice (slices)
  (let (max-slice)
    (dotimes (i (length slices)) (if 
                                     (or
                                      (eq max-slice nil)
                                      (> (slice-location (nth i slices)) (slice-location max-slice))
                                      ) 
                                     (setf max-slice (nth i slices))
                                   )
      )
    (setf (slice-location max-slice) (+ (slice-location max-slice) 1))
 )
)

(defun update-beta-factors (node) 
  (let (beta-node-vs beta-function)
    (setf beta-node-vs (node-variables node))
    (setq beta-function (init-plm beta-node-vs
                                  1
                                  0 (init-vector (length beta-node-vs) t)))
    (setf (node-function node) beta-function)
    (setf (aref (graph-changes cg) (node-number node)) t)
    )
  )

(defun update-wm-factors (node)
  (let (vars)
    (setf vars (node-variables node))
    (setf (node-function node)
          (init-plm vars
                    1
                    0 (init-vector (length vars) t)))
    (setf (aref (graph-changes cg) (node-number node)) t)
    )
  )
; -------------------------------------------------------------
; Progress and similarity/difference measures between two piecewise-constant unique PLMs

; Compute the within-integral portion of the Bhattacharyya coefficient over two constant values
(defun inner-bc-constants (p q)
    (sqrt (* p q))
  )

; Compute the Bhattacharyya coefficient for all pairs of regions in two PLMS
(defun bc-plms (pp qp ds)
  (unless (and (plm-piecewise-constant pp) (plm-piecewise-constant qp))
    (error "Attempt to compute the Bhattacharyya coefficient on a piecewise-linear PLM; Must be piecewise-constant")
    )
  (integral-plm (combine-plms pp nil qp 'inner-bc) ds)
  )

; Compute the Hellinger difference from the Bhattacharyya coefficient for one constant function
(defun hd-from-bc (bc &optional r piecewise-constant)
  (declare (ignore r piecewise-constant))
  (sqrt (- 1 (min bc 1))) ; In case bc ended up a smidgen over 1, reduce it back to 1 and compute difference
  )

; Compute the Hellinger difference from the Bhattacharyya coefficient for one PLM
(defun hd-from-bc-plm (bcp)
  (transform-plm #'hd-from-bc bcp)
  )

; Compute the Hellinger difference for all pairs of regions in two plms
(defun hd-plms (pp qp ds)
  (unless (and (plm-piecewise-constant pp) (plm-piecewise-constant qp))
    (error "Attempt to compute the Hellinger difference on a piecewise-linear PLM; Must be piecewise-constant")
    )
  (hd-from-bc-plm (bc-plms pp qp ds))
  )

; Compute the Bhattacharyya difference from the Bhattacharyya coefficient for one constant function
(defun bd-from-bc (bc &optional r piecewise-constant)
  (declare (ignore r piecewise-constant))
  (- (log bc))
  )

; Compute the Bhattacharyya difference from the Bhattacharyya- oefficient for one PLM
(defun bd-from-bc-plm (bcp)
  (transform-plm #'bd-from-bc bcp)
  )

; Return a list of the unique dimensions of a predicate
(defun unique-dimensions-predicate (pred)
  (let ((args (predicate-arguments pred)))
    (mapcar #'(lambda (arg-name) (position arg-name args :key #'car)) (predicate-unique pred))
    )
  )

; Return a list of all of the dimension numbers except for the state and agent
(defun all-but-agent-and-state-dimensions-plm (pred)
  (let (ds
        (count 0))
    (dolist (arg (predicate-arguments pred))
      (unless (member (car arg) '(state agent))
        (setq ds (cons count ds))
        )
      (setq count (1+ count))
      )
    ds)
  )

; Is a function 0?
(defun vector-0 (f)
  (every #'(lambda (x) (e= x 0)) f)
  )

; Return 0 if second function is 0 otherwise first function
(defun constrain-by-0-function (f1 f2 &optional piecewise-constant)
  (if piecewise-constant
      (if (e= f2 0) 0 f1)
    (if (vector-0 f2) (copy-seq f2) (copy-seq f1)))
  )

; Convert any form of unique argument to selection
(defun make-unique-argument-select (arg)
  (if (> (length arg) 2)
      (list (car arg) (cadr arg) '!)
    arg)
  )
(defun make-unique-arguments-select (args)
  (mapcar #'make-unique-argument-select args)
  )

; Yield an argument list by removing all of the unique arguments from a predicate's argument list
; Make all of the rest, other than state and agent arguments, distribution
(defun meta-arguments (pred)
  (let ((unique (predicate-unique pred))
        meta-arguments
        )
    ; Extract out universal arguments
    (dolist (arg (predicate-arguments pred))
      (unless (member (car arg) unique)
        (setq meta-arguments (if (member (car arg) '(state agent)) ; Keep these arguments universal
                                 (cons (list (car arg) (cadr arg)) meta-arguments)
                               (cons (list (car arg) (cadr arg) '%) meta-arguments)))
        )
      )
    (setq meta-arguments (nreverse meta-arguments))
    meta-arguments)
  )

; Yield a variable map from an appraisal function to its regular predicate function
(defun meta-map (pred)
  (let* ((unique (predicate-unique pred))
         (appraisal-index 0) ; Index in appraisal function's variables
         (predicate-index 0) ; Index in predicate fucntion's variables
         (vfactor (init-vector (- (length (predicate-arguments pred)) (length unique))))
        )
    ; Extract out universal arguments
    (dolist (arg (predicate-arguments pred))
      (unless (member (car arg) unique)
        (setf (aref vfactor appraisal-index) predicate-index)
        (setq appraisal-index (1+ appraisal-index))
        )
      (setq predicate-index (1+ predicate-index))
      )
    (make-smap :vfactor vfactor))
  )


; Print out link directions with messages that are not marked as piecewise constant
(defun npc nil
  (dolist (l (graph-links cg))
    (dotimes (i 2)
      (when (and (aref (link-contents l) i) (not (plm-piecewise-constant (aref (link-contents l) i))))
        (format t "~S->~S~%" (node-number (aref (link-nodes l) i)) (node-number (aref (link-nodes l) (- 1 i))))
        )
      )
    )
  )

; Is a region's function constant?
(defun region-function-variablep (r)
  (find-if #'(lambda (x) (not (zerop x))) (region-dimensions r) :key #'dimension-weight)
  )

; Determine if a PLM is piecewise constant
(defun plm-piecewise-constantp (plm)
  (let ((rarray (plm-array plm))
        (piecewise-constant t))
    (dotimes (i (array-total-size rarray))
      (when (region-function-variablep (row-major-aref rarray i))
        (setq piecewise-constant nil)
        (return)
        )
      )
    piecewise-constant)
  )


; Make variables active in new PLM if active in either of old ones
; Assumes new active is already a copy of second old one
(defun update-combine-active (a1 map a2 an)
  (let (mapv d)
    (when map
      (setq mapv (smap-vfactor map))
      )
    (dotimes (i (length a1))
      (setq d (if mapv (aref mapv i) i))
      (when (and (aref a1 i) (not (aref a2 d)))
        (setf (aref an d) t)
        )
      )
    )
  )

; Summarize a global meta-predicate function to yield a total appraisal value
; Divisor is the number of active predicates of this type
(defun global-summarized-predicate-plm (plm divisor)
  (let* (d ; Dimension along which to summarize
         (ovs (plm-variables plm)) ; Variables in original PLM
         (nlength (1- (length ovs))) ; Length of new variable vector
         (nvs (init-vector nlength)) ; Variables for result PLM
        )
    (if (= nlength 0)
        (progn
          (setq d 0)
          (setq nvs (vector))
          )
      (if (eq (stype-name (svariable-type (aref (plm-variables plm) 0))) 'predicate) ; Assumes nlength can only be 1 if not 0
          (progn
            (setq d 0)
            (setq nvs (vector (aref ovs 1)))
            )
        (progn
          (setq d 1)
          (setq nvs (vector (aref ovs 0)))
          )))
    (strip-and-reorder-plm nil nvs (transform-plm #'scale-function (integral-plm plm d) (/ 1.0 divisor)))
    )
  )

; Update global appraisal variables (both distributions and single values)
(defun update-global-appraisal-variables nil
  (when (graph-surprise-distribution-predicate cg)
    (setf (predicate-perception-temp-mem (graph-surprise-distribution-predicate cg)) (global-meta-predicate-plm 'surprise t)) ; Global surprise distribution
    (setf (predicate-perception-temp-mem (graph-surprise-predicate cg))
          (global-summarized-predicate-plm (predicate-perception-temp-mem (graph-surprise-distribution-predicate cg)) (length (graph-surprise-predicates cg)))) ; Global surprise
    )
  (when (graph-progress-distribution-predicate cg)
    (setf (predicate-perception-temp-mem (graph-progress-distribution-predicate cg)) (global-meta-predicate-plm 'progress t)) ; Global progress distribution
    (setf (predicate-perception-temp-mem (graph-progress-predicate cg))
          (global-summarized-predicate-plm (predicate-perception-temp-mem (graph-progress-distribution-predicate cg)) (length (graph-progress-predicates cg)))) ; Global progress
    )
  (when (graph-difference-distribution-predicate cg)
    (setf (predicate-perception-temp-mem (graph-difference-distribution-predicate cg)) (global-meta-predicate-plm 'difference t)) ; Global difference distribution
    (setf (predicate-perception-temp-mem (graph-difference-predicate cg))
          (global-summarized-predicate-plm (predicate-perception-temp-mem (graph-difference-distribution-predicate cg)) (length (graph-difference-predicates cg)))) ; Global difference
    )
  (when (graph-attention-distribution-predicate cg)
    (setf (predicate-perception-temp-mem (graph-attention-distribution-predicate cg)) (global-meta-predicate-plm 'attention t)) ; Global attention distribution
    (setf (predicate-perception-temp-mem (graph-attention-predicate cg))
          (global-summarized-predicate-plm (predicate-perception-temp-mem (graph-attention-distribution-predicate cg)) (length (graph-attention-predicates cg)))) ; Global attention
    )
  )

;------------
; Enable remove-unneeded slices with an absolute comparison of region functions for attention

; Determine if constants are equal for two regions
(defun constant-equal (r1 r2 &optional absolute)
  (e= (region-constant r1) (region-constant r2) absolute))

; Determine if the weights along a dimension are equal for two regions
(defun weight-equal (r1 r2 d &optional absolute)
  (e= (region-weight r1 d) (region-weight r2 d) absolute arousal))

; Determine if the functions defined by two regions are equal
(defun function-equal (r1 r2 &optional absolute)
  (if (and (constant-equal r1 r2 absolute)
           (eq (region-exponential r1) (region-exponential r2))
           )
      (dotimes (d (region-rank r1) t)
        (unless (weight-equal r1 r2 d absolute)
          (return nil)
          )
        )
    nil)
  )


; Compute exponential of (* function mult) (actually exponentiating mult times the constant while ignore dimension weights)
(defun exponentiate-constant-times-function (f r mult &optional piecewise-constant)
  (if piecewise-constant
      (exp (* f mult))
    (let (nf)
      r ; dummy so no warning about r not being used
      (setq nf (init-vector (length f) 0))
      (setf (aref nf 0) (exp (* (aref f 0) mult)))
      nf))
  )

; Create a list counting up to 1- number
(defun rank-list (n)
  (let (l)
    (dotimes (i n)
      (setq l (cons i l))
      )
    (nreverse l)
    )
  )

; Recur on average-regions-in-span
(defun average-regions-in-span-recur (ur rarray i sizev starting-indices rank regions-included sum-of-functions)
  (cond ((< i rank)
         (let ((sis (copy-seq starting-indices)))
           (do ((si sis (region-after-index-list si i (1- (aref sizev i))))) ; Destructive
               ((or (null si) (e> (region-max (apply #'aref rarray si) i) (region-max ur i))) nil)
             (multiple-value-setq (regions-included sum-of-functions) (average-regions-in-span-recur ur rarray (1+ i) sizev si rank regions-included sum-of-functions))
             )
           )
         )
        ((= i rank)
         (let ((r (apply #'aref rarray starting-indices)))
;           (format t "~S" starting-indices)
           (when (within-region r nil ur)
             (setq regions-included (1+ regions-included))
             (setq sum-of-functions (vector-sum sum-of-functions (extract-function r)))
             )
           )
         )
        )
  (values regions-included sum-of-functions)
  )

; Avearge PLM regions within span of specified region
(defun average-regions-in-span (ur p sizev starting-indices)
  (let (regions-included sum-of-functions average-function)
;    (format t "~&~S ~S: " (region-mins ur) (region-maxs ur))
    (multiple-value-setq (regions-included sum-of-functions)
        (average-regions-in-span-recur ur (plm-array p) 0 sizev starting-indices (plm-rank p) 0 (init-vector (1+ (plm-rank p)) 0)))
    (setq average-function (init-vector (length sum-of-functions)))
    (dotimes (i (length sum-of-functions))
      (setf (aref average-function i) (/ (aref sum-of-functions i) regions-included))
      )
    average-function)
  )

; Eliminate slices from a needed dimensional vector in afun if not already in pfun
(defun remove-moot-slices-d (ndv asl psl)
  (let* (ploc ; Location of slice in pfun
         (alength (length asl))
         (plength (length psl))
         (result (init-vector plength))
         (i 0)
         )
    (if (= plength alength) ; Already have same slices
        ndv
      (progn
        (dolist (ps psl)
          (setq ploc (slice-location ps))
          (do ((asc asl (cdr asc)))
              ((null asc) (error "Couldn't find original slice in appraisal slices in REMOVE-MOOT-SLICES-D"))
            (when (e= ploc (slice-location (car asc)) t)
              (setf (aref result i) (aref ndv (slice-index (car asc)))) ; Assign old needed to new
              (setq asl (cdr asc))
              (setq i (1+ i))
              (return)
              )
            )
          )
        result)
      )
    )
  )

; Eliminate slices from afun needed if already not in pfun
(defun remove-moot-slices-ds (needed aslices pslices)
  (let* ((length (length needed))
         (nn (init-vector (length needed)))
         )
    (dotimes (i length)
      (setf (aref nn i) (remove-moot-slices-d (aref needed i) (aref aslices i) (aref pslices i)))
      )
    nn)
  )

; Maximize out all unique dimensions
(defun maximize-unique-dimensions (p)
  (dolist (d (unique-dimensions p))
    (setq p (maximize-plm p d))
    )
  p)

; Given a PLM, scale values in universal regions so that largest value is equal to max
(defun scale-max-plm (p max); 
  (let (mp
        maximum ; Result of maximizing out unique dimensions
        )
    (when trace-transform
      (format trace-stream "~&~%SCALE TO MAX:")
      (format trace-stream "~&~%P: ") (print-smart p symbolic-trace trace-stream)
      )
    (setq maximum (maximize-unique-dimensions p))
    (setf (plm-active maximum) (init-vector (plm-rank maximum) t))
    (setq mp (combine-plms p nil maximum 'divide-0))
    (setq mp (transform-plm #'scale-function mp max nil t))
    (when trace-transform
      (format trace-stream "~&~%SCALE TO MAX RESULT: ") (print-smart mp symbolic-trace trace-stream)
      )
    mp)
  )

; Apply attention function to a predicate function
(defun apply-attention (pred pfun)
  (let* ((afun (node-function (predicate-perception (predicate-attention-predicate pred)))) ; Attention map for predicate
         (rank (plm-rank pfun))
         sizev ; Sizes of dimensions
         needed ; Slices needed based on attention
         (pred-name (predicate-name pred))
         )
    (unless (predicate-no-normalize (predicate-attention-predicate pred))
      (setq afun (scale-max-plm afun attention-exponential-numerator))
      (when trace-attention
        (format trace-stream "~&~%~S Attention Map ~S (Scaled):~&"
                (predicate-name pred)
                (if (predicate-surprise-predicate pred)
                    (if (predicate-progress-predicate pred)
                        (if (closed-world pred)
                            "Surprise POR Difference"
                          "Surprise POR Progress")
                      "Surprise")
                  (if (closed-world pred)
                      "Difference"
                    "Progress")))
        (parray afun nil nil trace-stream)
        )
      )
    (setq afun (transform-plm #'exponentiate-constant-function afun))
    (when trace-attention
      (format trace-stream "~&~%~S Attention Map (Exponentially Transformed but Unnormalized):" pred-name)
      (pa afun nil nil trace-stream)
      )
    (setq afun (normalize-plm afun (rank-list (plm-rank afun))))
    (when trace-attention
      (format trace-stream "~&~%~S Attention Map (Exponentially Transformed and Normalized):" pred-name)
      (pa afun nil nil trace-stream)
      )
    (setq afun (combine-plms afun (meta-map pred) pfun 'product nil nil t))
    (when trace-attention
      (format trace-stream "~&~%~S Product of Attention Map and Node Function:" pred-name)
      (pa afun nil nil trace-stream)
      )
    (setq sizev (dimension-sizes-v afun))
    (setq needed (slices-needed afun rank sizev (dimension-multipliers sizev) t))
    (setq needed (remove-moot-slices-ds needed (plm-slices afun) (plm-slices pfun))) ; Remove from needed slices already not in pfun
    (setf (plm-removed-unneeded-slices pfun) nil) ; Force a new removal
    (normalize-plm (remove-unneeded-slices pfun needed 'average nil t))
    )
  )


;--------------
; Update global meta-predicates

; Create a CPT entry from a constant region of a PLM
(defun region-cpt-entry (r rank active)
  (let (cpt)
    (dotimes (j rank)
      (when (aref active j)
        (push (list (region-min r j) (region-max r j)) cpt))
      )
    (cons (region-constant r) (reverse cpt)))
  )

; Convert a meta-predicate to a CPT with all dimensions but agent (if exists) summarized out, and original predicate added as first dimension
; For use in updating a global meta-predicate
(defun meta-predicate-plm-to-cpt (plm pred-args original-pred-name)
  (let (cpt
        entry
        array
        (rank (plm-rank plm))
        (active (plm-active plm))
        )
    (dotimes (d rank)
      (when (and (aref active d)
                 (not (and multiagent
                           (eq (caar pred-args) 'agent)
                           ))
                 )
        (setq plm (integral-plm plm d))
        )
      (setq pred-args (cdr pred-args))                 
      )
    (setq array (plm-array plm))
    (setq active (plm-active plm))
    (dotimes (i (array-total-size array))
      (setq entry (region-cpt-entry (row-major-aref array i) rank active))
      (setq cpt (cons (cons (car entry) (cons original-pred-name (cdr entry)))  cpt))
      )
    cpt)
  )

; Combine open/progress and closed/difference based global attention distributions into one based on worlds of predicates
; Assumes that predicates in graph-predicates and predicate names in predicate type are the same and in the same order
(defun combine-open-closed-world-attention-distributions (att-open att-closed)
  (let ((predicate-index (position 'predicate (plm-variables att-open) :key #'(lambda (v) (stype-name (svariable-type v)))))
        oarray
        carray
        (worlds (mapcar #'predicate-world (graph-predicates cg)))
        )
    ; Shatter the two distributions along the predicate dimension so that can easily track predicate world
    (setq att-open (shatter-plm att-open predicate-index))
    (setq att-closed (shatter-plm att-closed predicate-index))
    ; Get region arrays
    (setq oarray (plm-array att-open))
    (setq carray (plm-array att-closed))
    (if multiagent
        (progn
          )
      (progn
        (dotimes (i (length worlds))
          (when (eq (car worlds) 'open)
            (setf (region-constant (aref carray i)) (region-constant (aref oarray i)))
            )
          (setq worlds (cdr worlds))
          )
        (remove-unneeded-slices att-closed)))
    )
  )

; Compute global attention distribution from global surprise, progress and distribution rather than summarizing over predicate attention functions
(defun compute-global-attention-distribution nil
  (let* ((predicate-worlds (mapcar #'predicate-world (graph-attention-predicates cg)))
         (open (member 'open predicate-worlds))
         (closed (member 'closed predicate-worlds)))
    (if (graph-surprise-distribution-predicate cg)
        (if (graph-progress-distribution-predicate cg)
            (if open
                (if closed
                    (combine-open-closed-world-attention-distributions
                     (combine-plms (predicate-perception-temp-mem (graph-surprise-distribution-predicate cg)) nil (predicate-perception-temp-mem (graph-progress-distribution-predicate cg)) 'por)
                     (combine-plms (predicate-perception-temp-mem (graph-surprise-distribution-predicate cg)) nil (predicate-perception-temp-mem (graph-difference-distribution-predicate cg)) 'por))
                  (combine-plms (predicate-perception-temp-mem (graph-surprise-distribution-predicate cg)) nil (predicate-perception-temp-mem (graph-progress-distribution-predicate cg)) 'por))
              (when closed
                (combine-plms (predicate-perception-temp-mem (graph-surprise-distribution-predicate cg)) nil (predicate-perception-temp-mem (graph-difference-distribution-predicate cg)) 'por)
                ))
          (predicate-perception-temp-mem (graph-surprise-distribution-predicate cg)))
      (if (graph-progress-distribution-predicate cg)
          (if open
              (if closed
                  (combine-open-closed-world-attention-distributions
                   (predicate-perception-temp-mem (graph-progress-distribution-predicate cg))
                   (predicate-perception-temp-mem (graph-difference-distribution-predicate cg)))
                (predicate-perception-temp-mem (graph-progress-distribution-predicate cg)))
            (when closed
              (predicate-perception-temp-mem (graph-difference-distribution-predicate cg))
              ))))
    )
  )

; Create a CPT for full global meta-predicate
(defun global-meta-predicate-plm (mp-type &optional use-temp-perception-memory)
  (let ((pnames (stype-constants (graph-predicate-type cg)))
        pred-access
        global-pred
        cpt
        mp-pred
        vs
        )
    (case mp-type
      ((attention)
       (setq pred-access #'predicate-attention-predicate)
       (setq global-pred (graph-attention-distribution-predicate cg))
       )
      ((surprise)
       (setq pred-access #'predicate-surprise-predicate)
       (setq global-pred (graph-surprise-distribution-predicate cg))
       )
      ((progress)
       (setq pred-access #'predicate-progress-predicate)
       (setq global-pred (graph-progress-distribution-predicate cg))
       )
      ((difference)
       (setq pred-access #'predicate-difference-predicate)
       (setq global-pred (graph-difference-distribution-predicate cg))
       )
      )
    (if (eq mp-type 'attention) ; Combine distribution from surprise and progress/difference rather than summarizing over *attention
        (compute-global-attention-distribution)
      (progn
        (dolist (pname pnames) ; Summarize appropriately over functions for each predicate
          (setq mp-pred (apply pred-access (list (predicate-from-name pname))))
          (when mp-pred ; The predicate has this type of appraisal
            (setq cpt (if use-temp-perception-memory
                          (if (predicate-perception-temp-mem mp-pred)
                              (append (meta-predicate-plm-to-cpt (predicate-perception-temp-mem mp-pred) (predicate-arguments mp-pred) pname) cpt)
                            nil)
                        (append (meta-predicate-plm-to-cpt (node-function (predicate-perception mp-pred)) (predicate-arguments mp-pred) pname) cpt)))
            )
          )
        (setq vs (node-variables (predicate-perception global-pred))) 
        (cpt-function-array-plm (variable-names vs) cpt vs 0)
        ))
    )
  )


;-----------
; Test program for parallel visual search for yellow via top-down attentional input (via a goal for an open-world predicate)
; It also checks for visual surprise and for what happens to surprise when a blank screen intervenes
(defun visual-search (&optional blackout no-attention)
  (init)
  (learn '(:gd))
    (unless no-attention
      (setq compute-surprise t)
      (setq compute-progress t)
      (setq compute-attention t)
      (setq trace-attention t)
      )
;  (setq trace-gdl t)
  (setq perceive-list '((perceive '((image (x 0) (y 1) (color yellow))
                                    (image (x 1) (y 0) (color yellow))
                                    (image (x 2) (color blue)) (image (x 3) (color red))
                                    (image (y 2) (color red)) (image (y 3) (color blue))
                                    (image (x 0) (y 0) (color green))
                                    (image (x 1) (y 1) (color green))))))
  (new-type 'color :constants '(red yellow green blue black))
  (new-type 'dimension :numeric t :discrete t :min 0 :max 4)
  (predicate 'image :perception t :arguments '((x dimension) (y dimension) (color color %)) :function 1
             :goal '((image*goal (color yellow))))
  (predicate 'result :world 'closed :arguments '((x dimension) (y dimension) (color color !)))

  (conditional 'compare
               :conditions '((image (x (x)) (y (y)) (color (color)))
                             (image*goal (x (x)) (y (y)) (color (color)))
                             )
               :actions '((result (x (x)) (y (y)) (color (color))))
               )
  (d 2)
  (pimage)
  (pgoal)
  (d 20)
  (when blackout
    (format T "~&~%*** Changing perception of entire image to black.")
    (setq perceive-list '((perceive '((image (color black))))))
    (d 3)
    (format T "~&~%*** Results after changing perception to black (and 3 decisions)")
    (pimage)
    (pgoal)
    (pppfns)
    )
  (format T "~&~%*** Changing perception of location 0,3 to green.")
  (setq perceive-list '((perceive '((image (x 0) (y 1) (color yellow))
                                    (image (x 1) (y 0) (color yellow))
                                    (image (x 2) (color blue)) (image (x 3) (color red))
                                    (image (y 2) (color red)) (image (y 3) (color blue))
                                    (image (x 0) (y 0) (color green))
                                    (image (x 1) (y 1) (color green))
                                    (image (x 0) (y 3) (color green))))))
  (d 3)
  (format T "~&~%*** Results after change in perception (and 3 decisions)")
  (pimage)
  (pgoal)
  (pppfns)
  )

(defun pimage ()
  (format t "~&~%Perceptual image: ~&")
  (pa (node-function (predicate-perception (predicate-from-name 'image))) nil '((argmax wm-color)))
  )
(defun pgoal ()
  (format t "~&~%Search image: ~&")
  (pa (node-function (predicate-wm (predicate-goal-predicate (predicate-from-name 'image)))) nil '((argmax wm-color)))
  )

; Generate a visual field with random colors
(defun vf-colors (n colors change-x change-y change-color)
  (let ((cs (length colors))
        vf)
    (dotimes (x n)
      (dotimes (y n)
        (if (and (= x change-x) (= y change-y))
            (setq vf (cons `(image (x ,x) (y ,y) (color ,change-color)) vf))
          (setq vf (cons `(image (x ,x) (y ,y) (color ,(nth (random cs) colors))) vf)))
        )
      )
    vf)
  )

; Program for testing surprise and attention with a large visual field (change happens in location 0,0)
(defun large-surprise (n &optional no-attention)
  (let* ((pes (vf-colors n '(red yellow green blue) 0 0 'blue))
         (pes-l (list pes)) ; For use with perceive in an apply form
         )
    (init)
    (learn '(:gd))
    (unless no-attention
      (setq compute-surprise t)
      (setq compute-attention t)
      (setq trace-attention t)
      )
;    (setq trace-gdl t)
    (setq perceive-list `((apply #'perceive ',pes-l)))
    (new-type 'color :constants '(red yellow green blue))
    (new-type 'dimension :numeric t :discrete t :min 0 :max n)
    (predicate 'image :perception t :arguments '((x dimension) (y dimension) (color color %)) :function 1)
    (predicate 'result :world 'closed :arguments '((x dimension) (y dimension) (color color !)))
    
    (d 2)
    (d 20)
    (format T "~&~%*** Changing perception of location 0,0 to green.")
    (setq pes (cons `(image (x 0) (y 0) (color green)) (remove-if #'(lambda (x) (and (equal (cadr x) '(x 0)) (equal (caddr x) '(y 0)))) pes)))
    (setq pes-l (list pes))
    (setq perceive-list `((apply #'perceive ',pes-l)))
    (d 3)
    )
  )

; Generate a visual function with random colors
(defun vfun-colors (n colors)
  (let ((cs (length colors))
        vf)
    (dotimes (x n)
      (dotimes (y n)
          (setq vf (cons (list 1 x y (nth (random cs) colors)) vf))
        )
      )
    vf)
  )

; Program for testing goals and attention with a large visual field
(defun large-goal (n &optional no-attention)
  (let* (pfn ; Predicate function node
         )
    (init)
    (learn nil)
    (setq compute-surprise nil)
    (if no-attention
        (progn
          (setq compute-progress nil)
          (setq compute-attention nil)
          (setq trace-attention nil)
          )
      (progn
        (setq compute-progress t)
        (setq compute-attention t)
        (setq trace-attention nil)
        )
      )
    (new-type 'color :constants '(red yellow green blue))
    (new-type 'dimension :numeric t :discrete t :min 0 :max n)
    (predicate 'location :world 'closed :perception t :arguments '((x dimension !) (y dimension !)))
    (predicate 'lcolor :world 'closed :arguments '((color color !)))
    (predicate 'image :perception t :arguments '((x dimension) (y dimension) (color color %))
               :function 1 :goal '((image*goal (x 0) (y 0))) :learning-rate 0)
    (setq pfn (predicate-function-node (predicate-from-name 'image)))
    (predicate 'result :world 'closed :arguments '((x dimension) (y dimension) (color color !)))

    (conditional 'location-color1
                 :conditions '((location (x (x)) (y (y)))
                               (image (x (x)) (y (y)) (color (c))))
                 :actions '((lcolor (color (c))))
                 )

    (conditional 'location-color2
                 :conditions '((location (x (x)) (y (y)))
                               (image (x (x)) (y (y)) (color (c))))
                 :actions '((lcolor (color (c))))
                 )


    (conditional 'location-color3
                 :conditions '((location (x (x)) (y (y)))
                               (image (x (x)) (y (y)) (color (c))))
                 :actions '((lcolor (color (c))))
                 )

    (conditional 'location-color4
                 :conditions '((location (x (x)) (y (y)))
                               (image (x (x)) (y (y)) (color (c))))
                 :actions '((lcolor (color (c))))
                 )

    (conditional 'location-color5
                 :conditions '((location (x (x)) (y (y)))
                               (image (x (x)) (y (y)) (color (c))))
                 :actions '((lcolor (color (c))))
                 )

    (conditional 'location-color6
                 :conditions '((location (x (x)) (y (y)))
                               (image (x (x)) (y (y)) (color (c))))
                 :actions '((lcolor (color (c))))
                 )

    (conditional 'location-color7
                 :conditions '((location (x (x)) (y (y)))
                               (image (x (x)) (y (y)) (color (c))))
                 :actions '((lcolor (color (c))))
                 )


    (evidence '((location (x 0) (y 0))))
    
    (d 1)
    (ppwm 'lcolor)

    ; Replace original uniform function with a complex one
    (setf (node-function pfn) (cpt-function-array-plm '(wm-x wm-y wm-color) (vfun-colors n '(red yellow green blue)) (node-variables pfn) 0))
    (setf (aref (graph-changes cg) (node-number (predicate-function-node (predicate-from-name 'image)))) t)

    (d 1)
    (ppwm 'lcolor)
    (message-statistics)
    )
  )

;--------------
; A program for exploring needs/drives/urges

(defun needs nil
  (init)
  (setq trace-attention t)
  (predicate 'hunger :world 'closed :arguments '((exists boolean %)) :goal '((hunger*goal (exists false))))
  (predicate 'thirst :world 'closed :arguments '((exists boolean %)) :goal '((thirst*goal (exists false))))
  (evidence '((hunger .3 (exists true)) (hunger .7 (exists false))
              (thirst .8 (exists true)) (thirst .2 (exists false))))
  (d 2)
  (pppfns)
  )

;--------------
; A program for testing mixture of open-world and closed-world appraisal predicates

(defun mixed-world-attention nil
  (init)
  (setq trace-attention t)
  (setq perceive-list '((perceive '((thirst .8 (exists true)) (thirst .2 (exists false))))))
  (predicate 'hunger :world 'closed :arguments '((exists boolean %)) :goal '((hunger*goal (exists false))))
  (predicate 'thirst :perception t :arguments '((exists boolean %)) :goal '((thirst*goal (exists false))))
  (conditional 'fake :conditions '((thirst (exists true))))
  (evidence '((hunger .3 (exists true)) (hunger .7 (exists false))))
  (d 2)
  (pppfns)
  )
; basic sigma print functions which do not require the CAPI library

; Print for which assumption nodes a node number is a descendant
(defun print-node-progenitors (node-number)
  (dolist (n (graph-nodes cg))
    (when (member node-number (node-descendants n) :key #'(lambda (d) (node-number (descendant-node d))))
      (format trace-stream "~S " (node-name n))
      )
    )
  )


; Print link depths
(defun print-link-depths (&optional stream)
  (unless stream (setq stream trace-stream))
  (format stream "~&")
  (dolist (l (graph-links cg))
    (dotimes (i 2)
      (when (aref (link-contents l) i) ; Link is active in direction
        (if (aref (link-depths l) i) ; There is a depth in direction
            (format stream "[~S->~S:~S]" (node-number (aref (link-nodes l) i)) (node-number (aref (link-nodes l) (- 1 i))) (aref (link-depths l) i))
          (format stream "(~S->~S:~S)" (node-number (aref (link-nodes l) i)) (node-number (aref (link-nodes l) (- 1 i))) (aref (link-loop-depths l) i))
          )
        )
      )
    )
  )
(defun plds (&optional stream) (print-link-depths stream))


; Print message times
(defun print-message-times (&optional stream)
  (unless stream (setq stream trace-stream))
  (unless trace-message-times
    (error "Attempt to print message times without having initially set trace-message-times to T")
    )
  (format stream "~&Messages: ~S; Average time: ~4,1F msec; Maximum time: ~7,1F msec"
          number-of-messages (average-message-time) maximum-message-time)
  )

; Print incoming marks for all links in graph
(defun print-incoming-marks ()
  (dolist (n (graph-nodes cg))
    (when (factor-nodep n)
      (dolist (l (node-links n))
        (format trace-stream "~&~S ~S: ~S" (node-name (aref (link-nodes l) 0)) (node-name (aref (link-nodes l) 1)) (link-incoming l))
        )
      )
    )
  )


; Compute aggregates needed for printing global-decision-statistics
(defun sum-decision-statistics (key) (reduce #'+ global-decision-statistics :key key))

; Convert a real to a rounded integer
(defun rri (n) (coerce (round n) 'integer))

; Print global-decision-statistics
(defun print-global-decision-statistics (&optional stream)
  (unless stream (setq stream trace-stream))
  (let* ((messages (sum-decision-statistics #'decision-statistics-messages))
         (run-time (sum-decision-statistics #'decision-statistics-run-time))
         (decision-time (sum-decision-statistics #'decision-statistics-decision-time))
         (learn-time (sum-decision-statistics #'decision-statistics-learn-time))
         (init-time (sum-decision-statistics #'decision-statistics-init-time))
         (total-time (+ run-time decision-time learn-time init-time))
         (cycles (length global-decision-statistics))
         (rcycles (* 1.0 cycles)) 
         )
    (format stream "~&~%Total time ~,2,,,F sec" (/ total-time 1000.0))
    (when (> trial-count 0)
      (format stream "~&Trials: ~S; Msec per trial: ~S" trial-count (/ total-time (* trial-count 1.0)))
      )
    (format stream "~&Decision cycles: ~S; Msec per decision cycle: ~S (init: ~S, messages: ~S, decision: ~S, learn: ~S)"
            cycles (rri (/ total-time rcycles)) (rri (/ init-time rcycles)) (rri (/ run-time rcycles)) (rri (/ decision-time rcycles)) (rri (/ learn-time rcycles)))
    (format stream "~&Total messages: ~S; Messages per decision: ~S"
            messages (rri (/ messages rcycles))
            )
    (when (> messages 0)
      (format stream "; Msec per message: ~,2,,,F" (/ (* 1.0 run-time) messages))
      )
    t)
  )
(defun pgds nil (print-global-decision-statistics))


; Print link counts > minimum (or just nhighest > minimum if specified)
(defun print-link-counts (&optional nhighest minimum)
  (unless nhighest (setq nhighest infinity))
  (unless minimum (setq minimum 1))
  (let (lcs (c 0))
    ; Create a list of dotted lists, one for each active link-direction
    (dolist (l (graph-links cg))
      (when (aref (link-contents l) var-index)
        (setq lcs (cons (cons (aref (link-counts l) var-index)
                              (concat-symbols (list (node-name (aref (link-nodes l) var-index))
                                                    '->
                                                    (node-name (aref (link-nodes l) fact-index)))))
                        lcs))
        )
      (when (aref (link-contents l) fact-index)
        (setq lcs (cons (cons (aref (link-counts l) fact-index)
                              (concat-symbols (list (node-name (aref (link-nodes l) fact-index))
                                                    '->
                                                    (node-name (aref (link-nodes l) var-index)))))
                        lcs))
        )
      )
    ; Sort list by highest to lowest by count
    (setq lcs (sort lcs #'> :key #'car))
    ; Print nhighest
    (dolist (lc lcs)
      (when (or (>= c nhighest) ; Stop when have printed nhighest link directions
                (< (car lc) minimum) ; Stop once reach link directions along which no messages sent
                )
        (return)
        )
      (format trace-stream "~&~S: ~S~&" (car lc) (cdr lc))
      (setq c (1+ c))
      )
    t)
  )
(defun plc (&optional nhighest minimum)
  (print-link-counts nhighest minimum)
  )

; Print link message sizes > minimum (or just nhighest > minimum if specified)
(defun print-link-message-sizes (&optional nhighest minimum)
  (unless nhighest (setq nhighest infinity))
  (unless minimum (setq minimum 1))
  (let (lms (c 0))
    ; Create a list of dotted lists, one for each active link-direction
    (dolist (l (graph-links cg))
      (when (aref (link-contents l) var-index)
        (setq lms (cons (cons (plm-size (aref (link-contents l) var-index))
                              (concat-symbols (list (node-name (aref (link-nodes l) var-index))
                                                    '->
                                                    (node-name (aref (link-nodes l) fact-index)))))
                        lms))
        )
      (when (aref (link-contents l) fact-index)
        (setq lms (cons (cons (plm-size (aref (link-contents l) fact-index))
                              (concat-symbols (list (node-name (aref (link-nodes l) fact-index))
                                                    '->
                                                    (node-name (aref (link-nodes l) var-index)))))
                        lms))
        )
      )
    ; Sort list by highest to lowest by count
    (setq lms (sort lms #'> :key #'car))
    ; Print nhighest
    (dolist (lm lms)
      (when (or (>= c nhighest) ; Stop when have printed nhighest link directions
                (< (car lm) minimum) ; Stop once reach link directions along which no messages sent
                )
        (return)
        )
      (format trace-stream "~&~S: ~S~&" (car lm) (cdr lm))
      (setq c (1+ c))
      )
    t)
  )
(defun plms (&optional nhighest minimum)
  (print-link-message-sizes nhighest minimum)
  )



; Print an array of node outgoing messages
(defun print-gma (a)
  (dotimes (i (length a))
    (format trace-stream "~&~S: " i)
    (dolist (np (aref a i))
      (format trace-stream "<~S> " (car np))
      (print-plm (cdr np) t trace-stream)
      )
    )
  nil)

; Print gd-test results (to be used within post-t for test runs)
(defun print-gd-test-results (atts)
  (let (tr total)
    (dolist (att atts)
      (setq tr (find-gd-test-results att))
      (setq total (total-gd-test-results tr))
      (when (> total 0)
        (format trace-stream "~&~%RESULTS FOR ATTRIBUTE ~S~&TP: ~S, TN: ~S~&FP: ~S, FN: ~S"
                att
                (* 1.0 (/ (gd-test-results-true-positives tr) total))
                (* 1.0 (/ (gd-test-results-true-negatives tr) total))
                (* 1.0 (/ (gd-test-results-false-positives tr) total))
                (* 1.0 (/ (gd-test-results-false-negatives tr) total)))
        )
      )
    )
  t)

; Print a variable name and number
(defun print-svariable (v &optional stream)
  (unless stream (setq stream trace-stream))
  (format stream "~S(~S)" (svariable-name v) (stype-name (svariable-type v)))
  )

; Print a value in a function (either constant or weight)
(defun print-function-value (v &optional stream)
  (unless stream (setq stream trace-stream))
  (format stream (if (integerp v)
                         "~D"
                       (if (and (>= (abs v) .001) (< (abs v) 1000)) "~F"
                         "~G")) v)
  t)

; Print dimension d (variable v)
; Weight determines if print weight
(defun print-dimension (d-min d-max &optional v symbolic stream printvs weight)
  (unless stream (setq stream trace-stream))
  (let (type)
    (when printvs (format stream " "))
    ; Deal with either a single variable or a list of them
    (cond ((null v))
          ((listp v)
           (setq type (svariable-type (car v)))
           (when printvs (print-svariables v stream)))
          (t
           (setq type (svariable-type v))
           (when printvs (print-svariable v stream))
           )
          )
    (cond ((and symbolic type
                (not (< d-min (stype-min type))) (not (> d-max (stype-max type))) ; This can happen during traces of affine transformations
                )
           (cond ((dimension-full-scope d-min d-max type)
                  (format stream "[*>")
                  )
                 ((and (stype-numeric type)
                       (stype-discrete type)
                       )
                  (if (e= d-max (+ d-min 1) t)
                      (format stream "[~S]" (if center-discrete-numeric-on-integer (+ d-min 1/2) d-min))
                    (if center-discrete-numeric-on-integer
                        (format stream "[~S ~S>" (+ d-min 1/2) (+ d-max 1/2))
                      (format stream "[~S ~S>" d-min d-max))
                    )
                  )
                 ((not (stype-numeric type))
                  (format stream "[")
                  (cond ((e= d-max (+ d-min 1) t) ; Dimension only includes one constant
                         (format stream "~S" (get-symbol-name d-min type))
                         )
                        (t ; Dimension includes two or more constants
                         (do ((cd d-min (+ cd 1)))
                             ((e= cd d-max t))
                           (format stream "~S" (get-symbol-name cd type))
                           ; Print a space if there are more to come
                           (unless (e= (+ cd 1) d-max t) (format stream " "))
                           )
                         )
                        )
                  (format stream "]")
                  )
                 (t
                  (format stream "[~S ~S>" d-min d-max)
                  )
                 ))
          (t
           (format stream "[~S ~S>" d-min d-max)
           )
          )
    (when (and weight
               (or (not symbolic)
                   (and (numberp weight) (not (e= weight 0)))))
      (format stream ":")
      (print-function-value weight stream)
      )
    nil)
  )

; Print maximals
(defun print-maximals (ms v &optional symbolic stream)
  (unless stream (setq stream trace-stream))
    (format stream "<")
    (unless ms
      (format stream "NIL")
      )
    (dolist (m ms)
      (if symbolic
          (print-dimension (car m) (cadr m) v symbolic stream nil)
        (format stream "~S" ms)
        )
      )
    (format stream ">")
    )

; Print a region
(defun print-region (r p &optional symbolic stream piecewise-constant)
  (unless stream (setq stream trace-stream))
  (let ((vs (plm-variables p))
        d v
        (msv (region-maximals r))
        ms
        (rc (region-constant r))
        )
    (when (or ;(not symbolic)
              (and (or trace-empty
                       (not (region-e-empty r piecewise-constant)))
                   (or trace-full
                       (not (region-e-full r piecewise-constant)))
                   ))
      (when print-regions-on-separate-lines
        (format stream "~%")
        )
      (format stream "(")
      (when (region-exponential r)
        (format stream "E ")
        )
      (print-function-value rc stream)
      (when (region-evidence r)
        (format stream "@"))
      (format stream ":")
      (dotimes (i (region-rank r))
        (setq d (dimension r i))
        (setq v (aref vs i))
        (when (or (not symbolic)
                  (dimension-active p i)
                  trace-maximals)
          (print-dimension (dimension-min d) (dimension-max d) v symbolic stream t (dimension-weight d))
          (setq ms (aref msv i))
          (when (and trace-maximals ms)
            (print-maximals ms v symbolic stream)
            )
          )
        )
      (format stream ") ")
      )
    nil)
  )

; Print the slices in a PLM
(defun print-plm-slices (p &optional symbolic stream)
  (unless stream (setq stream trace-stream))
  (let (vars rank rank-1)
    (setq rank (plm-rank p))
    (setq rank-1 (- rank 1))
    (dotimes (i rank)
      (when (aref (plm-slices p) i)
        (setq vars (aref (plm-variables p) i))
        (if (listp vars)
            (do ((vl vars (cdr vl)))
                ((null vl))
              (format stream "~S"
                      (svariable-name (car vl))
                      )
              (unless (null (cdr vl)) (format stream "*"))
              )
          (format stream "~S"
                      (svariable-name vars)
                      )
          )
        (unless symbolic
          (format stream ": ~S" (sort-slice-list (aref (plm-slices p) i)))
          )
        (when (< i rank-1) (format stream ", "))
        )
      )
    )
  )

; Print one PLM
(defun print-one-plm (p &optional symbolic stream limits)
  (unless stream (setq stream trace-stream))
  (let (limits-v r
        (rarray (plm-array p))
        (piecewise-constant (plm-piecewise-constant p)))
    (setq limits-v (compute-limits limits (plm-variables p)))
    (unless (eq (type-of p) 'plm) (error "Attempt to print an object of type ~S as a PLM." (type-of p)))
    (cond ((not (eq (type-of p) 'plm)) (format stream "~S" p)) ; Handles deltas and other things
          (p
           (unless symbolic ; Print slices when not symbolic
             (print-plm-slices p symbolic stream)
             (format stream "~&")
             )
           (dotimes (i (array-total-size rarray))
             (setq r (row-major-aref rarray i))
             (when (region-within-limits r limits-v)
               (print-region r p symbolic stream piecewise-constant)
               )
             )
           )
          )
    nil)
  )

; Print PLM
(defun print-plm (p &optional symbolic stream limits)
  (unless stream (setq stream trace-stream))
  (let (newp)
    (setq newp (find-plm p))
    (unless newp
      (error "Could not identify PLM to print in PRINT-PLM.")
      )
    (if (listp newp)
        (dolist (np newp)
          (case (car np)
            ((wm)
             (format stream "WM function for predicate ~S:~&" p)
             (print-one-plm (cdr np) symbolic stream limits)
             (format stream "~& ~%")
             )
            ((pfun)
             (format stream "Predicate function for predicate ~S:~&" p)
             (print-one-plm (cdr np) symbolic stream limits)
             (format stream "~& ~%")
             )
            ((cfun)
             (format stream "Conditional function for conditional ~S:~&" p)
             (print-one-plm (cdr np) symbolic stream limits)
             (format stream "~& ~%")
             )
            )
          )
      (print-one-plm newp symbolic stream limits))
    nil)
  )
; Short cut for symbolic printing of a plm
(defun pplm (p) (print-plm p t))

; String of spaces
(defun space-string (n)
  (make-string n :initial-element '#\Space)
  )

; Print centered in field
; no longer needed???
(defun print-centered (x max-field &optional stream)
  (unless stream (setq stream trace-stream))
  (let* ((field (length (princ-to-string x)))
        (pad (/ (- max-field field) 2))
        )
    (if (< max-field field)
        (error "Attempt to print ~S in field of width ~S" x max-field)
      (format stream "~A~S~A" (space-string (floor pad)) x (space-string (ceiling pad)))
      )
    t)
  )

; Print right justified in field
(defun print-right-justified (x max-field &optional stream)
  (unless stream (setq stream trace-stream))
  (let* ((field (length (if (stringp x) x (princ-to-string x))))
        (pad (- max-field field))
        )
    (if (< max-field field)
        (error "Attempt to print ~S in field of width ~S" x max-field)
      (progn
        (format stream "~A" (space-string pad))
        (if (stringp x)
            (format stream x)
          (format stream "~S" x))
        )
      )
    t)
  )

; Find length of label with longest name in type
(defun longest-label (vt)
  (let ((pm (stype-min vt))
        (field-max 0))
    (if (stype-numeric vt)
        (setq field-max (max (length (princ-to-string (if center-discrete-numeric-on-integer (+ (stype-min vt) 1/2) (stype-min vt))))
                             (length (princ-to-string (if center-discrete-numeric-on-integer (+ (stype-max vt) 1/2) (stype-max vt))))
                             ))
      (dotimes (i (- (stype-max vt) pm))
        (setq field-max (max field-max (length (princ-to-string (nth (+ i pm) (stype-constants vt))))))
        )
      )
    field-max)
  )

; Compute a label
(defun compute-label (name vt)
  (if (stype-numeric vt)
      (when center-discrete-numeric-on-integer
        (setq name (+ name 1/2))
        )
    (setq name (nth name (stype-constants vt)))
    )
  name)

; Compute a label string
(defun compute-label-string (name vt)
  (princ-to-string (compute-label name vt))
  )

; Print a label
(defun print-label (name vt field-max &optional dash stream)
  (unless stream (setq stream trace-stream))
  (print-right-justified (concatenate 'string "[" (compute-label-string name vt) (if dash ":>" "]")) field-max stream)
  )


; Define a range label over two values
(defun range-label (a b vt)
  (concatenate 'string '"[" (compute-label-string a vt) (if (stype-discrete vt) ":" "-") (compute-label-string b vt) ">")
  )

; Print labels along X axis
(defun print-x-headers (rarray ar vt index &optional pad ranges stream)
  (unless stream (setq stream trace-stream))
  (let* (field-max rs)
    (setq field-max (longest-label vt))
    (setq field-max (if ranges
                        (+ (* 2 field-max) range-field-beyond-label) ; 2 for brackets, 1 for separator
                      (+ field-max field-beyond-label))) ; 2 for brackets, 1 for space and 1 for possibility of dash
    (setq field-max (max minimal-parray-field field-max))
    (when pad
      (format stream (space-string pad))
      )
    (do ((r ar (region-after-old r index rarray)))
        ((null r))
      (setq rs (region-span r index))
      (cond (ranges
             (print-right-justified (range-label (region-min r index) (region-max r index) vt) field-max stream)
             )
            ((and (null (region-after-old r index rarray))
                  (stype-numeric vt)
                  (> rs max-final-discrete)
                  )
             (print-label (region-min r index) vt field-max t stream)
             )
            (t
             (let ((rm (region-min r index)))
               (dotimes (i rs)
                 (print-label (+ i rm) vt field-max nil stream)
                 )
               )
             )
          )
        )
    (format stream "~&")
    field-max)
  )

; Print a 0D function with an argmax
(defun parray-print-0d (p argmax argmax-type &optional stream)
  (unless stream (setq stream trace-stream))
  (let ((r (plm-origin p)))
    (unless (region-e-empty r)
      (format stream "~S" (compute-label (caar (aref (region-maximals r) argmax)) argmax-type))
      )
    )
  )

; Print across one dimension of a PLM as an array (possibly of regions), starting from axial region
; Ignores dimension weights if they exist
(defun parray-print-1d (rarray ar index vt field-size &optional regions argmax argmax-type stream)
  (unless stream (setq stream trace-stream))
  (let (format-string rc rs)
    (do ((r ar (region-after-old r index rarray)))
        ((null r))
      (setq rc (if argmax
                   (if (region-e-empty r)
                       ""
                     (compute-label (caar (aref (region-maximals r) argmax)) argmax-type))
                 (if (region-is-variable r)
                     '*linear*
                   (if (= (region-constant r) 0) ; Deal with bad formatting for 0.0
                       0
                     (region-constant r)))))
      (if (numberp rc)
        (setq format-string (concatenate 'string "~" (princ-to-string field-size)
                                         (if (integerp rc)
                                             "D"
                                           (if (and (< rc 100) (> rc .01))
                                               "F"
                                             "G"))
                                         )
              )
        (setq format-string nil)                                      
        )
      (setq rs (region-span r index))
      (if (and (stype-numeric vt) ; Never use regions for symbolic variables
               (or regions
                   (not (stype-discrete vt)) ; Always use regions with continuous variables
                   (and (null (region-after-old r index rarray)) ; Use region for terminal region if large
                        (> rs max-final-discrete))
                   )
               )
          (if format-string
              (format stream format-string rc)
            (print-right-justified rc field-size stream))
        (dotimes (i rs)
          (if format-string
              (format stream format-string rc)
            (print-right-justified rc field-size stream))
          )
        )
      )
    t)
  )

; Print a 1D function as an array
; Ignores dimension weights if they exist
(defun parray-1d (p &optional regions argmax argmax-type stream)
  (unless stream (setq stream trace-stream))
  (let ((as (plm-active p))
         index field-size v vt)
    (unless (= (active-variables as) 1)
      (error "Attempt to print as an array a 1D function that doesn't have exactly one active dimension: ~S" p)
      )
    (setq index (position t (plm-active p))) ; Index of first active dimension
    (setq v (aref (plm-variables p) index))
    (setq vt (svariable-type v)) 
    (format stream "~&      ~S:~&" (svariable-name v))
    (setq field-size (print-x-headers (plm-array p) (plm-origin p) vt index nil (and (or regions (not (stype-discrete vt))) (stype-numeric vt)) stream))
    (parray-print-1d (plm-array p) (plm-origin p) index (svariable-type v) field-size regions argmax argmax-type stream)
    t)
  )

; Print across two dimensions of a PLM as an array, starting from axial region
; Ignores dimension weights if they exist
(defun parray-print-2d (rarray ar index1 index2 v1t v2t &optional regions argmax argmax-type stream)
  (unless stream (setq stream trace-stream))
  (let (y-size rm2 rs2 field-size)
    (setq y-size (longest-label v2t))
    (setq field-size  (print-x-headers rarray ar v1t index1
                                       (if (or regions (not (stype-discrete v2t)))
                                           (+ (* 2 y-size) range-field-beyond-label)
                                         (+ y-size field-beyond-label))
                                       (and (or regions (not (stype-discrete v1t))) (stype-numeric v1t)) stream))
    (do ((r ar (region-after-old r index2 rarray)))
        ((null r))
      (setq rs2 (region-span r index2))
      (setq rm2 (region-min r index2))
      (if (and (stype-numeric v2t) ; Never use regions for symbolic variables
               (or regions
                   (not (stype-discrete v2t)) ; Always use regions with continuous variables
                   (and (null (region-after-old r index2 rarray)) ; Use region for terminal region if large
                        (> rs2 max-final-discrete))
                   )
               )
          (progn
            (if (or regions (not (stype-discrete v2t)))
                (print-right-justified (range-label rm2 (region-max r index2) v2t) (+ (* 2 y-size) range-field-beyond-label) stream)
              (print-label rm2 v2t (+ y-size field-beyond-label) t stream))
            (parray-print-1d rarray r index1 v1t field-size regions argmax argmax-type stream)
            (format stream "~&")
            )

        (dotimes (i rs2)
          (print-label (+ rm2 i) v2t (+ y-size field-beyond-label) nil stream)
          (parray-print-1d rarray r index1 v1t field-size regions argmax argmax-type stream)
          (format stream "~&")
          )
        )
      )
    t)
  )

; Print a 2D function as an array
; Ignores dimension weights if they exist
(defun parray-2d (p &optional regions argmax argmax-type stream)
  (unless stream (setq stream trace-stream))
  (let ((as (plm-active p))
         index1 index2 v1 v2 v1t v2t)
    (setq index1 (position t (plm-active p))) ; Index of first active dimension
    (setq index2 (position t (plm-active p) :start (+ index1 1))) ; Index of second active dimension
    (unless (= (active-variables as) 2)
      (error "Attempt to print a 2D function as an array that doesn't have exactly two active dimensions: ~S" p)
      )
    (setq v1 (aref (plm-variables p) index1))
    (setq v1t (svariable-type v1))
    (setq v2 (aref (plm-variables p) index2))
    (setq v2t (svariable-type v2))
    (format stream "~&      ~S x ~S:~&" (svariable-name v1) (svariable-name v2))
    (parray-print-2d (plm-array p) (plm-origin p) index1 index2 v1t v2t regions argmax argmax-type stream)
    t)
  )

; Print across three dimensions of a PLM as an array, starting from axial region
; Iterates over first dimension
; Ignores dimension weights if they exist
(defun parray-print-3d-1 (p index1 index2 index3 v1t v2t v3t &optional regions argmax argmax-type stream)
  (unless stream (setq stream trace-stream))
  (let (y-size rm1 rs1 ar)
    (setf ar (plm-origin p))
    (setq y-size (longest-label v1t))
    (do ((r ar (region-after-old r index1 (plm-array p))))
        ((null r))
      (setq rs1 (region-span r index1))
      (setq rm1 (region-min r index1))

      (if (and (stype-numeric v1t) ; Never use regions for symbolic variables

               (or regions
                   (not (stype-discrete v1t)) ; Always use regions with continuous variables
                   (and (null (region-after-old r index1 (plm-array p))) ; Use region for terminal region if large
                       (> rs1 max-final-discrete))
                   )
               )
          (progn
            (format stream "~%")
            (print-right-justified (range-label rm1 (region-max r index1) v1t) (+ (* 2 y-size) range-field-beyond-label) stream)
            (format stream "~&")
            (parray-print-2d (plm-array p) r index2 index3 v2t v3t regions argmax argmax-type stream)
            (format stream "~&")
            )

        (dotimes (i rs1)
          (format stream "~%")
          (print-label (+ rm1 i) v1t (+ y-size field-beyond-label) nil stream)
          (format stream "~&")
          (parray-print-2d (plm-array p) r index2 index3 v2t v3t regions argmax argmax-type stream)
          (format stream "~&")
          )
        )
      )
    t)
  )
(defun parray-print-4d-1 (p index1 index2 index3 index4 v1t v2t v3t v4t &optional regions argmax argmax-type stream)
  (unless stream (setq stream trace-stream))
  (let (y-size rm1 rs1 ar)
    (setf ar (plm-origin p))
    (setq y-size (longest-label v1t))
    (do ((r ar (region-after-old r index1 (plm-array p))))
        ((null r))
      (setq rs1 (region-span r index1))
      (setq rm1 (region-min r index1))

      (if (and (stype-numeric v1t) ; Never use regions for symbolic variables

               (or regions
                   (not (stype-discrete v1t)) ; Always use regions with continuous variables
                   (and (null (region-after-old r index1 (plm-array p))) ; Use region for terminal region if large
                       (> rs1 max-final-discrete))
                   )
               )
          (progn
            (format stream "~%")
            (print-right-justified (range-label rm1 (region-max r index1) v1t) (+ (* 2 y-size) range-field-beyond-label) stream)
            (format stream "~&")
            (parray-print-3d-1 p index2 index3 index4 v2t v3t v4t regions argmax argmax-type stream)
            (format stream "~&")
            )

        (dotimes (i rs1)
          (format stream "~%")
          (print-label (+ rm1 i) v1t (+ y-size field-beyond-label) nil stream)
          (format stream "~&")
          (parray-print-3d-1 p index2 index3 index4 v2t v3t v4t regions argmax argmax-type stream)
          (format stream "~&")
          )
        )
      )
    t)
  )

; Print a 3D function as an array
; Ignores dimension weights if they exist
(defun parray-3d (p &optional regions argmax argmax-type stream)
  (unless stream (setq stream trace-stream))
  (let ((as (plm-active p))
         index1 index2 index3 v1 v2 v3 v1t v2t v3t uniquevars universalvars pvs allvars thisvar)
    (unless (= (active-variables as) 3)
      (error "Attempt to print a 3D function as an array that doesn't have exactly three active dimensions: ~S" p)
      )
    (setq pvs (plm-variables p))
    (dotimes (i (length pvs))
      (setf thisvar (cons (aref pvs i) i))
      (if (aref (plm-active p) i) ;if it's active
	  (if (multiple-variable (aref pvs i)) ;if it's universal
	      (progn 
	      (setf universalvars (cons thisvar universalvars)))
	     (setf uniquevars (cons thisvar uniquevars)))
	      )
	  )
    (setf allvars (append universalvars uniquevars))

    (setq index1 (cdr (nth 0 allvars))) ; Index of first active dimension
    (setq index2 (cdr (nth 1 allvars))) ; Index of 2nd active dimension
    (setq index3 (cdr (nth 2 allvars))) ; Index of 3rd active dimension

    (setq v1 (car (nth 0 allvars)))
    (setq v2 (car (nth 1 allvars)))
    (setq v3 (car (nth 2 allvars)))

    (setq v1t (svariable-type v1))
    (setq v2t (svariable-type v2))
    (setq v3t (svariable-type v3))
    (format stream "~&      ~S x [~S x ~S]:~&" (svariable-name v1) (svariable-name v2) (svariable-name v3))
    (parray-print-3d-1 p index1 index2 index3 v1t v2t v3t regions argmax argmax-type stream)
    t)
)

(defun parray-4d (p &optional regions argmax argmax-type stream)
  (unless stream (setq stream trace-stream))
  (let ((as (plm-active p))
         index1 index2 index3 index4 v1 v2 v3 v4 v1t v2t v3t v4t)
    (unless (= (active-variables as) 4)
      (error "Attempt to print a 4D function as an array that doesn't have exactly 4 active dimensions: ~S" p)
      )
    (setq index1 (position t (plm-active p))) ; Index of first active dimension
    (setq index2 (position t (plm-active p) :start (+ index1 1))) ; Index of second active dimension
    (setq index3 (position t (plm-active p) :start (+ index2 1))) ; Index of second active dimension
    (setq index4 (position t (plm-active p) :start (+ index3 1))) ; Index of second active dimension
    (setq v1 (aref (plm-variables p) index1))
    (setq v1t (svariable-type v1))
    (setq v2 (aref (plm-variables p) index2))
    (setq v2t (svariable-type v2))
    (setq v3 (aref (plm-variables p) index3))
    (setq v3t (svariable-type v3))
    (setq v4 (aref (plm-variables p) index4))
    (setq v4t (svariable-type v4))
    (format stream "~&  ~S x    ~S x [~S x ~S]:~&" (svariable-name v1) (svariable-name v2) (svariable-name v3) (svariable-name v4))
    (parray-print-4d-1 p index1 index2 index3 index4 v1t v2t v3t v4t regions argmax argmax-type stream)
    t)
  )

; print plm of any dimension as an array
(defun parray-all (p &optional regions argmax argmax-type stream)
  (unless stream (setq stream trace-stream))
  (let (index1 index2 v1 v2 uniquevars universalvars pvs allvars thisvar nvars currvar1 currvar2)
    (setq pvs (plm-variables p))
    (dotimes (i (length pvs))
      (setf thisvar (cons (aref pvs i) i))
      (if (string= (svariable-name (car thisvar)) "WM-STATE") ; it's sate save for later
	  (setf universalvars (cons thisvar universalvars))
	 (progn
	   (if (aref (plm-active p) i) ;if it's active
	       (if (multiple-variable (aref pvs i)) ;if it's universal
		   (setf universalvars (cons thisvar universalvars))
		  (setf uniquevars (cons thisvar uniquevars)))
	       ))
	   ))
    (setf allvars (append universalvars uniquevars))
    (setf nvars (length allvars))
    (dotimes (i (- nvars 3))
      (if (> (length allvars) 2)
	 (progn  
	   (setq currvar1 (pop allvars))
	   (setq v1 (car currvar1))
	   (setq index1 (cdr currvar1))
	   (setq currvar2 (pop allvars))
	   (setq v2 (car currvar2))
	   (setq index2 (cdr currvar2))
	   (format t "~&~%[ ~S x ~S ] ~&" (svariable-name v1) (svariable-name v2))
	   (parray-print-all p (plm-array p) (plm-origin p) index1 index2 v1 v2 allvars regions argmax argmax-type stream)
	   (format t "~%"))))))

(defun parray-print-all (p rarray ar index1 index2 v1 v2 restvars &optional regions argmax argmax-type stream)
  (unless stream (setq stream trace-stream))
  (let (y-size rm rs v vt index vname v3cons v3 index3 currvar)
  (if (= (length restvars) 1)
      (progn
	(setf v3cons (pop restvars))
	(setf v3 (car v3cons))
	(setf index3 (cdr v3cons))
	(parray-print-3d-1 p index1 index2 index3 (svariable-type v1) (svariable-type v2) (svariable-type v3) regions argmax argmax-type stream)
	(format stream "~%"))
      (progn 
	  (setq currvar (pop restvars))
	  (setq v (car currvar))
	  (setq vt (svariable-type v))
	  (setq index (cdr currvar))
	  (setq vname (svariable-name v))
	  (setq y-size (longest-label vt))
	  (do ((r ar (region-after-old r index rarray)))
	      ((null r))
	    (setq rs (region-span r index))
	    (setq rm (region-min r index))
	    (if (and (stype-numeric vt) ; Never use regions for symbolic variables
		     (or regions
			 (not (stype-discrete vt)) ; Always use regions with continuous variables
			 (and (null (region-after-old r index rarray)) ; Use region for terminal region if large
			      (> rs max-final-discrete))
		   )
		     )
		(progn
		  (format stream "~%~S" vname)
		  (print-right-justified (range-label rm (region-max r index) vt) (+ (* 2 y-size) range-field-beyond-label) stream)
		  (format stream "~%") ; printing at end compression
		  (parray-print-all p rarray r index1 index2 v1 v2 restvars regions argmax argmax-type stream) ;; SHOULD ORDER BE REVERSED HERE??
		  (format stream "~&~%")
		  )
		
	  (dotimes (i rs)
	    (format stream "~S" vname)
	    (print-label (+ rm i) vt (+ y-size field-beyond-label) nil stream)
	    (format stream "~&")
	    (parray-print-all p rarray r index1 index2 v1 v2 restvars regions argmax argmax-type stream)
	    (format stream "~&"))))))))

; Print one 1,2 or 3D PLM as an array
(defun parray-one (p &optional regions argmax argmax-type stream)
   (unless stream (setq stream trace-stream))
  (setf (plm-slices p) (index-slice-list-array (plm-slices p))) ; Added for region arrays at present
  (case (active-variables (plm-active p))
    ((0) (if argmax
             (parray-print-0d p argmax argmax-type stream)
           (format stream "~S" (region-constant (plm-origin p))))
;           (error "Attempt to print as an array a function that isn't 1-3 dimensions: ~S" p))
     )
    ((1) (parray-1d p regions argmax argmax-type stream))
    ((2) (parray-2d p regions argmax argmax-type stream))
    ((3) (parray-3d p regions argmax argmax-type stream))
    (t (parray-all p))
    )
  )


; Print a 1,2 or 3D PLM as an array
(defun parray (p &optional regions summarize stream)
  (unless stream (setq stream trace-stream))
  ; Handle fact that if summarize is given as 'array should just ignore it
  (when (eq summarize 'array)
    (setq summarize nil)
    )
  (let (newp argmax argmax-type cls)
    (setq newp (find-plm p summarize))
    (unless newp
      (error "Could not identify PLM to print in PRINT-PLM.")
      )
    (if (listp newp)
        (dolist (np newp)
          ; Determine argmax dimension if there is one
          (when (and summarize (listp summarize))
            (setq cls (car (last summarize)))
            (when (and (= (length cls) 2)
                       (eq (car cls) 'argmax))
              (setq argmax (position (cadr cls) (plm-variables (cdr np)) :key #'svariable-name))
              (setq argmax-type (svariable-type (aref (plm-variables (cdr np)) argmax)))
              )
            )
          (case (car np)
            ((wm)
             (format stream "WM function for predicate ~S:~&" p)
             (parray-one (cdr np) (if (plm-uniform (cdr np)) t regions) argmax argmax-type stream)
             (format stream "~& ~%")
             )
            ((pfun)
             (format stream "Predicate function for predicate ~S:~&" p)
             (parray-one (cdr np) (if (plm-uniform (cdr np)) t regions) argmax argmax-type stream)
             (format stream "~& ~%")
             )
            ((cfun)
             (format stream "Conditional function for conditional ~S:~&" p)
             (parray-one (cdr np) (if (plm-uniform (cdr np)) t regions) argmax argmax-type stream)
             (format stream "~& ~%")
             )
            )
          )
      (progn
        ; Determine argmax dimension if there is one
        (when (and summarize (listp summarize))
          (setq cls (car (last summarize)))
          (when (and (= (length cls) 2)
                     (eq (car cls) 'argmax))
            (setq argmax (position (cadr cls) (plm-variables newp) :key #'svariable-name))
            (setq argmax-type (svariable-type (aref (plm-variables newp) argmax)))
            )
          )
        (parray-one newp regions argmax argmax-type stream)
        ))
      nil)
  )
(defun pa (p &optional regions summarize stream)
  (parray p regions summarize (if stream stream trace-stream))
  )

; Print a vector of variables
(defun print-svariables (vs &optional stream)
  (unless stream (setq stream trace-stream))
  (let ((rank (length vs)))
    (dotimes (i rank)
      (print-svariable (elt vs i) stream)
      (when (< i (- rank 1))
        (format stream "*"))
      )
    )
  )


; Print a single factor step
(defun print-factor-step (fs n &optional stream)
  (unless stream (setq stream trace-stream))
  (format stream "~S" (factor-step-type fs))
  (if (eq (factor-step-type fs) 'product)
      (format stream "(~A)" (node-name (link-var-node (factor-step-argument fs))))
    (format stream "(~S)" (elt (variable-names (node-variables n)) (factor-step-argument fs)))
    )
  )

; Print the factor steps for a node
(defun print-factor-steps (n &optional stream)
  (unless stream (setq stream trace-stream))
;  (format stream "~&~%")
  (format stream "~&  FACTOR STEPS: ")
  (do ((fs-l (node-factor-steps n) (cdr fs-l)))
      ((null fs-l))
    (print-factor-step (car fs-l) n stream)
    (when (cdr fs-l) (format stream ", "))
    )
  nil)

; Print the neighbors of a node
(defun print-neighbors (n &optional stream)
  (unless stream (setq stream trace-stream))
  (let ((varp (variable-nodep n)))
    (format stream "  NEIGHBORS: ")
    (do ((link-l (node-links n) (cdr link-l)))
        ((null link-l))
      (if varp
          (format stream "~S" (node-name (link-fact-node (car link-l))))
        (format stream "~S" (node-name (link-var-node (car link-l))))
        )
      (when (cdr link-l) (format stream ", "))
      )
    nil)
  )

; Print node type information
(defun print-node-type (n &optional stream)
  (unless stream (setq stream trace-stream))
  (format stream "~&~S = " (node-name n))
  (when (node-type n)
    (format stream "Type: ~S; " (node-type n)))
  (when (node-subtype n)
    (format stream "Subtype: ~S; " (node-subtype n)))
  (when (node-subsubtype n)
    (format stream "Subsubtype: ~S; " (node-subsubtype n)))
  (format stream "Action: ~S" (node-action n))
  t)
(defun pnt (node-number)
  (print-node-type (node-from-number node-number))
  )

(defun save-node-functions (fname)
  (with-open-file (str fname
                     :direction :output
                     :if-exists :supersede
                     :if-does-not-exist :create)
  (dolist (n (graph-nodes cg))
    (when (node-function n)
      (format str "~&~%~A::::" (node-name n))
      (format str " ~S ~% " (node-function n))))))

; Print node based on name or number
(defun pn (id &optional symbolic stream)
  (if (numberp id)
      (print-node (node-from-number id) symbolic stream)
    (print-node (node-from-name id) symbolic stream)))

; Print the messages coming into a node
(defun print-in-messages (n &optional symbolic stream)
  (let* ((ni (if (variable-nodep n) fact-index var-index)))
    (dolist (l (node-links n))
      (print-message "  " l ni symbolic t nil stream)
      )
    nil)
  )

; Short cut for printing incoming messages from node name symbolically to listener
(defun pim (n-id)
  (print-in-messages (if (numberp n-id) (node-from-number n-id) (node-from-name n-id)) t t))

; Print the messages going out of a node
(defun print-out-messages (n &optional symbolic stream)
  (let* ((ni (if (variable-nodep n) var-index fact-index)))
    (dolist (l (node-links n))
      (print-message "  " l ni symbolic nil nil stream)
      )
    nil)
  )

; Short cut for printing outgoing messages from node name symbolically to listener
(defun pom (n-id)
  (print-out-messages (if (numberp n-id) (node-from-number n-id) (node-from-name n-id)) t t))

; Print a link
(defun print-link (l &optional symbolic stream direction)
  (unless stream (setq stream trace-stream))
  (unless (graph-initialized cg)
    (init-graph)
    )
  (unless direction
    (format stream "~&~%<LINK>")
    )
  (when (and (or (not direction) ; If no direction, print in both directions
                 (equal direction 'from-variable))
             (link-var-content l)) ; Only print if link active in direction
    (print-message nil l var-index symbolic t stream)
    )
  (when (and (or (not direction) ; If no direction, print in both directions
                 (equal direction 'from-factor))
             (link-fact-content l)) ; Only print if link active in direction
    (print-message nil l fact-index symbolic t stream)
    )
  nil)

; Print preferences (messages out of and into selected FAN and FNAN nodes)
(defun print-preferences nil
  (unless (graph-initialized cg)
    (init-graph)
    )
  (unless (predicate-from-name 'selected t)
    (error "No selection predicate defined, so can't print preferences.")
    )
  (dolist (n (graph-positive-preferences cg)) ; Print positive preferences
    (format trace-stream "~%Preferences based on ~S:" (node-name n))
    (dolist (l (node-links n)) ; Outgoing messages
      (when (eq (node-subsubtype (aref (link-nodes l) var-index)) 'positive)
        (print-message "  " l fact-index t nil nil trace-stream)
        )
      )
    (dolist (l (node-links n)) ; Incoming messages
      (print-message "      " l var-index t t nil trace-stream)
      )
    )
  (when (graph-negative-preferences cg)
        (format trace-stream "~&~%Negative preferences:")
        )
  (dolist (n (graph-negative-preferences cg)) ; Print negative preferences
    (dolist (l (node-links n)) ; Outgoing messages
      (print-message "      " l fact-index t t nil trace-stream)
      )
    )
  )
(defun pprefs nil (print-preferences))

; Print a message based on node numbers
(defun pm (nn1 nn2 &optional symbolic stream)
  (unless stream (setq stream trace-stream))
  (let* ((n1 (node-from-number nn1))
         (n2 (node-from-number nn2))
         (l (link-from-nodes n1 n2))
        )
    (print-link l symbolic stream
                (if (variable-nodep n1)
                    'from-variable
                  'from-factor))
    )
  )

; Print factor function
(defun print-factor-function (n-name &optional symbolic stream)
  (let (n)
    (setq n (node-from-name n-name 'factor))
    (print-plm (node-function n) symbolic stream)
    )
  )

; Print queue contents
(defun print-queue-contents (q symbolic stream &optional head)
  (let ((count (queue-length q)))
    (when head
      (if (= (first head) (second head))
          (format stream "~&[~S] " (first head))
        (format stream "~&[~S,~S] " (first head) (second head))
        )
      )
    (dolist (m (cdr (queue-head q)))
      (format stream "~&")
      (print-message (if trace-wm-driven (format nil "{~S} " (message-wm-driven m)) "")
                     (message-link m) (message-index m) symbolic t t stream)
      )
    (if (eq count 1)
        (format stream "~&**** ~S message in queue." count)
      (format stream "~&**** ~S messages in queue." count)
      )
    )
  nil)

; Print a queue
(defun print-queue (q symbolic stream)
  (format stream "~&~%<QUEUE (~S: ~S)>~&~%" q
          (cond ((= q depth-queues-index) '"DEPTH MESSAGES")
                (t '"OTHER MESSAGES")
                )
          )
  (if (= q depth-queues-index)
      (let ((dqs (aref (graph-queues cg) depth-queues-index)))
        (dotimes (i (length dqs))
          (format stream "~&~%DEPTH: ~S" i)
          (print-queue-contents (aref dqs i) symbolic stream (car (queue-head (aref dqs i))))
          )
        )
    (print-queue-contents (aref (graph-queues cg) q) symbolic stream)
    )
  nil)

; Short hand for printing a queue
(defun pq (q) (print-queue q t trace-stream))

; Print all queues
(defun print-queues (&optional symbolic stream)
  (unless stream (setq stream trace-stream))
  (dotimes (i (length (graph-queues cg)))
    (print-queue i symbolic stream)
    )
  )

; Short hand for printing queues
(defun pqs nil (print-queues t trace-stream))

; Print variable nodes
(defun print-variable-nodes (&optional symbolic stream)
  (dolist (n (reverse (graph-nodes cg)))
    (when (variable-nodep n)
      (print-node n symbolic stream))))
(defun pvns nil
  (print-variable-nodes t trace-stream))

; Print factor nodes
(defun print-factor-nodes (&optional symbolic stream)
  (dolist (n (reverse (graph-nodes cg)))
    (when (factor-nodep n)
      (print-node n symbolic stream))))
(defun pfns nil
  (print-factor-nodes t trace-stream))

; Print all nodes
(defun print-nodes (&optional symbolic stream)
  (dolist (n (reverse (graph-nodes cg)))
    (print-node n symbolic stream)))
(defun pns nil
  (print-nodes t trace-stream))

; Print alpha memories
(defun print-alpha-memories (&optional conditional-name symbolic stream)
  (unless (graph-initialized cg)
    (init-graph)
    )
  (let ((c (conditional-from-name conditional-name)))
    (dolist (n (if conditional-name
                   (if c
                       (reverse (conditional-alpha-memories (conditional-from-name conditional-name)))
                     (error "No conditional named ~S." conditional-name))
                 (graph-nodes cg))
               )
      (when (and (variable-nodep n)
                 (eq (node-subtype n) 'alpha))
        (case (node-subsubtype n)
          ((condition)
           (format stream "~&<-~A: " (node-name n))
           (print-plm (variable-posterior n) symbolic stream) ; Only one message in, so posterior is this
           )
          ((action)
               (format stream "~&->~A: " (node-name n))
               (print-plm (variable-posterior n) symbolic stream) ; Only one message out, so posterior is this
               )
          ((condact)
           (dolist (l (node-links n))
             (format stream "~&~A->~S: " (node-name n) (node-name (aref (link-nodes l) fact-index)))
             (print-plm (aref (link-contents l) var-index) symbolic stream) ; Only one message out, so posterior is this
             )
           )
          )
        )
      )
    )
  )
(defun pam (&optional conditional-name)
  (print-alpha-memories conditional-name t trace-stream))

; Print a type
(defun print-type (type &optional stream)
  (unless stream (setq stream trace-stream))
  (let (variety)
    (setq variety (if (stype-numeric type)
                      (if (stype-discrete type) 'DISCRETE 'CONTINUOUS)
                    'SYMBOLIC))
    (format stream "~&~S: " (stype-name type))
    (if (eq variety 'SYMBOLIC)
        (format stream "~S" (stype-constants type))
      (if (eq variety 'DISCRETE)
          (if center-discrete-numeric-on-integer
              (format stream "[~S:~S>" (+ (stype-min type) 1/2) (+ (stype-max type) 1/2))
            (format stream "[~S:~S>" (stype-min type) (stype-max type))
            )
        (format stream "[~S,~S>" (stype-min type) (stype-max type))
        )
      )
    )
  t)
(defun pt (type) (print-type type))

; Print type from name
(defun print-type-from-name (tn)
  (print-type (type-from-name tn))
  t)
(defun ptn (tn) (print-type-from-name tn))

; Print types
(defun print-types (&optional stream)
  (unless stream (setq stream trace-stream))
  (dolist (type (reverse (graph-types cg)))
    (print-type type stream)
    )
  t)
(defun pts () (print-types))

; Print a predicate
(defun print-predicate (p &optional current-function stream)
  (unless stream (setq stream trace-stream))
  (format stream "~&(PREDICATE '~S :WORLD '~S" (predicate-name p) (predicate-world p))
  (when (predicate-persistent p)
    (format stream " :PERSISTENT ~S" (predicate-persistent p))
    )
  (when (predicate-unique p)
    (format stream " :UNIQUE '~S" (predicate-unique p))
    (when (predicate-select p)
      (format stream " :SELECT '~S" (predicate-select p))
      )
    )
  (when (predicate-perception p)
    (format stream " :PERCEPTION T")
    )
  (when (predicate-exponential p)
    (format stream " :EXPONENTIAL ~S" (predicate-exponential p))
    )
  (when (predicate-replace p)
    (format stream " :REPLACE ~S" (predicate-replace p))
    )
  (when (predicate-no-normalize p)
    (format stream " :NO-NORMALIZE ~S" (predicate-no-normalize p))
    )
  (when (predicate-arguments p)
    (format stream " :ARGUMENTS '~S" (predicate-arguments p))
    )
  (when (or (predicate-learning-rate p) (predicate-smoothing-parameter p))
    (format stream "~&   ")
    )
  (when (predicate-learning-rate p)
    (format stream " :LEARNING-RATE ~S" (predicate-learning-rate p))
    )
  (when (predicate-smoothing-parameter p)
    (format stream " :SMOOTHING PARAMETER ~S" (predicate-smoothing-parameter p))
    )
  (when (predicate-function p)
    (format stream "~&    :FUNCTION ")
    (let ((fun (if current-function (plm-cpt (node-function (predicate-function-node p))) (predicate-function p))))
      (unless (numberp fun)
        (format stream "'")
        )
      (format stream "~S" fun)
      )
    )
  (format stream ")")
  t)

; Print predicates
; If state is true print only the predicates that mention the state
(defun print-predicates (&optional current-function state stream)
  (unless stream (setq stream trace-stream))
  (dolist (pred (reverse (if state
                             (graph-state-predicates cg)
                           (graph-predicates cg)
                           )
                         ))
    (print-predicate pred current-function stream)
    )
  t)
(defun pps (&optional current-function state stream)
  (unless stream (setq stream trace-stream))
  (print-predicates current-function state stream))

; Print a predicate from its name
(defun print-predicate-from-name (p-name &optional stream)
  (print-predicate (predicate-from-name p-name) stream)
  t)
(defun pp (p-name) (print-predicate-from-name p-name))

; Print conditions, actions or condacts, one per line
(defun print-patterns (patterns type &optional stream)
  (unless stream (setq stream trace-stream))
  (let ((typel (length (symbol-name type))))
        (format stream "~&    :~S '(" type)
        (when patterns
          (format stream "~S" (car patterns))
          (setq patterns (cdr patterns))
          )
        (dolist (p patterns)
          (format stream "~&        ")
          (dotimes (i typel)
            (format stream " ")
            )
          (format stream "~S" p)
          )
        (format stream ")")
        )
  )

; Print a conditional
(defun print-conditional (c &optional current-function reordered-conditions stream)
  (unless stream (setq stream trace-stream))
  (let (fun)
    (format stream "~&(CONDITIONAL '~S" (conditional-name c))
    (if reordered-conditions
        (when (conditional-reordered-conditions c)
          (print-patterns (conditional-reordered-conditions c) 'conditions))
      (when (conditional-conditions c)
        (print-patterns (conditional-conditions c) 'conditions)))
    (when (conditional-condacts c)
      (print-patterns (conditional-condacts c) 'condacts))
    (when (conditional-actions c)
      (print-patterns (conditional-actions c) 'actions))
    (when (conditional-map c)
      (format stream "~&    :MAP T"))
    (when (conditional-function-variable-names c)
      (format stream "~&    :FUNCTION-VARIABLE-NAMES '~S" (conditional-function-variable-names c)))
    (when (conditional-normal c)
      (format stream "~&    :NORMAL '~S" (conditional-normal c)))
    (when (conditional-learning-rate c)
      (format stream "~&    :LEARNING-RATE ~S" (conditional-learning-rate c))
      )
    (when (conditional-smoothing-parameter c)
      (format stream "~&    :SMOOTHING PARAMETER ~S" (conditional-smoothing-parameter c))
      )
    (when (conditional-function c)
      (format stream "~&    :FUNCTION ")
      (setq fun (if current-function (reusable-conditional-function-c c) (conditional-function c)))
      (unless (numberp fun)
        (format stream "'")
        )
      (format stream "~S" fun)
      )
    (format stream "~&    )~%~%")
    )
  )
; Print a conditional based on its name
(defun pc (name &optional current-function reordered-conditions stream)
  (print-conditional (conditional-from-name name) current-function reordered-conditions stream))
; Print all conditionals to terminal without current function
(defun pcs (&optional current-function reordered-conditions stream)
  (dolist (c (reverse (graph-conditionals cg)))
    (print-conditional c current-function reordered-conditions stream)
    )
  )
; Print the function currently stored with a named conditional (not necessarily original function if learning)
(defun pcf (name &optional array)
  (let ((c (conditional-from-name name))
        cfn)
    (unless c
      (error "No conditional found for name ~S in call to PCF" name)
      )
    (setq cfn (conditional-function-node c))
    (when cfn ; When there is a function node for the conditional
      (if (and array (> (length (node-variables cfn)) 0) (< (length (node-variables cfn)) 4))
          (parray (node-function cfn))
        (pplm (node-function cfn))) ; Print its function
      )
    t)
  )
; Print the function currently stored with all conditionals
(defun pcfs (&optional array)
  (dolist (c (graph-conditionals cg))
    (when (conditional-function c)
      (format trace-stream "~S: " (conditional-name c))
      (pcf (conditional-name c) array)
      (format trace-stream "~&~%")
      )
    )
  )

; Print the function currently stored with a predicate (not necessarily original function if learning)
(defun ppf (name &optional array)
  (let ((p (predicate-from-name name))
        pfn)
    (unless p
      (error "No predicate found for name ~S in call to PPF" name)
      )
    (setq pfn (predicate-function-node p))
    (when pfn ; When there is a function node for the predicate
      (if (and array (> (length (node-variables pfn)) 0) (< (length (node-variables pfn)) 4))
          (parray (node-function pfn))
        (pplm (node-function pfn))) ; Print its function
      )
    t)
  )

; Print the function currently stored with all predicates
(defun ppfs (&optional array)
  (dolist (p (graph-predicates cg))
    (when (predicate-function-node p)
      (format trace-stream "~S: " (predicate-name p))
      (ppf (predicate-name p) array)
      (format trace-stream "~&~%")
      )
    )
  )

; Print the function currently stored with all predicates or conditionals
(defun pafs (&optional array)
  (format trace-stream "~&Conditional functions:~&~%")
  (pcfs array)
  (format trace-stream "~&~%Predicate functions:~&~%")
  (ppfs array)
  )

; Print one or all of the functions in episodic memory
(defun pem (&optional pred-name)
  (cond (pred-name
         (let ((pred (predicate-from-name pred-name))
               pem)
           (unless pred
             (error "No predicate named ~S in PEM" pred-name)
             )
           (setq pem (predicate-em pred))
           (unless pem
             (error "No episodic memory for predicate ~S in PEM" pred-name)
             )
           (pa (node-function pem))
           )
         )
        (t
         (mapc #'(lambda (c) (when (conditional-episodic c)
                               (format trace-stream "~&~%~S Memory: " (conditional-name c))
                               (pa (conditional-name c))
                               )
                   )
               (reverse (graph-conditionals cg))
               )
         (mapc #'(lambda (p) (when (predicate-episodic p)
                               (format trace-stream "~&~%~S Memory: " (predicate-name p))
                               (pa (predicate-name p))
                               )
                   )
               (reverse (graph-predicates cg))
               )
         )
        )
  t)

; Print results of episodic learning
(defun print-episodic-memory nil
  (ppfn temporal-predicate-name-episodic)
  (pem)
  )

; Print the predictions in episodic memory
(defun pep ()
  (format trace-stream "~&~%Episodic retrieval of time: ")
  (print-wm-vn (predicate-from-name temporal-predicate-name-episodic) t)
  (dolist (p (graph-predicates cg))
    (when (predicate-em p)
      (format trace-stream "~&~%Episodic prediction for predicate ~S: " (predicate-name p))
      (print-wm-vn (predicate-em-predicate p) t)
      )
    t)
  )

; Print graph statistics
(defun graph-statistics (&optional stream)
  (unless stream (setq stream trace-stream))
  (let* ((var-stats (count-node-variables))
         (nums (car var-stats))
         (vavgs (cadr var-stats))
         (vmaxs (caddr var-stats))
         (link-stats (count-node-links))
         (linavgs (nth 1 link-stats))
         (linmaxs (nth 2 link-stats))
         (loutavgs (nth 3 link-stats))
         (loutmaxs (nth 4 link-stats))
         )
    (format stream "~&Nodes: ~S (~S Variable, ~S Factor), Links: ~S (~S Active Directions), Depth: ~S"
            (length (graph-nodes cg))
            (aref nums 0) (aref nums 1)
            (length (graph-links cg)) (count-active-link-directions)
            (+ (graph-depth cg) 1) ; Add one because depth starts at 0
            )
    (format stream "~&Average variables per variable node: ~4,1F; factor node: ~4,1F"
            (aref vavgs 0) (aref vavgs 1))
    (format stream "~&Maximum variables per variable node: ~S; factor node: ~S"
            (aref vmaxs 0) (aref vmaxs 1))
    (format stream "~&Average incoming links per variable node: ~4,1F; factor node: ~4,1F"
            (aref linavgs 0) (aref linavgs 1))
    (format stream "~&Maximum incoming links per variable node: ~S; factor node: ~S"
            (aref linmaxs 0) (aref linmaxs 1))
    (format stream "~&Average outgoing links per variable node: ~4,1F; factor node: ~4,1F"
            (aref loutavgs 0) (aref loutavgs 1))
    (format stream "~&Maximum outgoing links per variable node: ~S; factor node: ~S"
            (aref loutmaxs 0) (aref loutmaxs 1))
    t)
  )
; Shortcut for graph-statistics
(defun gs (&optional stream)
  (unless stream (setq stream trace-stream))
  (graph-statistics stream)
  )

; Print names of nodes in graph
(defun print-node-names (&optional stream)
  (unless stream (setq stream trace-stream))
  (format stream "~&")
  (dolist (n (graph-nodes cg))
    (format stream "~S " (node-name n))
    )
  )
(defun pnn nil (print-node-names trace-stream))

; Print a graph
(defun print-graph (&optional symbolic stream)
  (unless stream (setq stream trace-stream))
  (unless (graph-initialized cg)
    (init-graph)
    )
  (format stream "~&<GRAPH:> ")
  (graph-statistics stream)
  (print-variable-nodes symbolic)
  (print-factor-nodes symbolic)
  (format stream "~&~%")
  (print-queues t trace-stream)
  t
  )

; Short hand for print-graph
(defun pg nil (print-graph symbolic-trace trace-stream))

; Print the shared WM VN for a predicate name
(defun print-wm-vn (pred &optional symbolic stream limits)
  (unless stream (setq stream trace-stream))
  (unless (graph-initialized cg)
    (init-graph)
    )
  (print-plm (vn-posterior pred) symbolic stream limits)
  )
(defun ppvn (pred-name &optional stream)
  (print-wm-vn (predicate-from-name pred-name) t stream)
  )

(defun ppwmfn (pname &optional limits)
  (print-pred-wm-function (predicate-from-name pname) t trace-stream limits)
  )  

(defun ppfn (pred-name &optional limits as-array stream)
  (unless stream (setq stream trace-stream))
  (format stream "~2&WM for ~S" pred-name)
  (print-pred-function (predicate-from-name pred-name) (if as-array as-array t) stream limits)
  )

(defun pppfn (pname &optional limits)
  (print-predicate-perception-function (predicate-from-name pname) t trace-stream limits)
  ) 
(defun pppfns nil
  (dolist (pred (graph-predicates cg))
    (when (predicate-perception pred)
      (format trace-stream "~%~&~S: " (predicate-name pred))
      (pppfn (predicate-name pred))
      (format trace-stream "~&")
      )
    )
  )

(defun ppwm (&optional pred-name as-array stream)
  (if pred-name
      (print-pred-wm (predicate-from-name pred-name) (if as-array as-array t) stream)
    (print-wm t stream))
  )

; Print the WMs associated with a graph
(defun print-wm (&optional symbolic stream)
  (dolist (pred (graph-predicates cg))
    (print-pred-wm pred symbolic stream nil)
    (format stream "~%")
    )
  nil)
(defun pwm (&optional as-array stream)
  (print-wm (if as-array as-array t) stream))

; Print functions in function factors
(defun print-functions (&optional symbolic stream)
  (dolist (n (graph-nodes cg))
    (when (function-nodep n)
      (print-node n symbolic stream)
      )
    )
  )
(defun pfs (&optional as-array)
  (print-functions (if as-array as-array t) trace-stream)
  )

; Print the expected value of the distribution/unique variable of a conditional function
; vn is a variable name
(defun print-expected-value-cond-function (cond-name &optional vn array)
  (let* ((c (conditional-from-name cond-name))
         p) ; PLM for conditional function
    (if c
        (setq p (node-function (conditional-function-node c)))
      (error "No conditional named ~S in PRINT-EXPECTED-VALUE-COND-FUNCTION." cond-name)
      )
    ; When variable not specified, use :normal variable if there is one
    (unless vn (setq vn (conditional-normal c)))
    ; Expected value of PLM
    (if (symbolp vn)
        (setq p (expected-value-plm p (when vn (position vn (plm-variables p) :key #'svariable-name))))
      (dolist (vnx vn)
        (setq p (expected-value-plm p (position vnx (plm-variables p) :key #'svariable-name)))
        ))
    (if (and array (> (length (plm-variables p)) 1) (< (length (plm-variables p)) 5))
          (parray p)
        (pplm p))
    t)
  )
(defun pevcf (cond-name &optional vn array)
  (print-expected-value-cond-function cond-name vn array)
  )

; Print the expected value of the distribution/unique variable of a predicate function
; vn is a variable name
(defun print-expected-value-pred-function (pred-name &optional vn array)
  (let* ((pred (predicate-from-name pred-name))
         p) ; PLM for predicate function
    (if pred
        (setq p (node-function (predicate-function-node pred)))
      (error "No predicate named ~S in PRINT-EXPECTED-VALUE-COND-FUNCTION." pred-name)
      )
    ; When variable not specified, use :unique variable if there is one
    (unless vn (setq vn (predicate-unique pred)))
    ; Expected value of PLM
    (if (symbolp vn)
        (setq p (expected-value-plm p (when vn (position vn (plm-variables p) :key #'svariable-name))))
      (dolist (vnx vn)
        (setq p (expected-value-plm p (position vnx (plm-variables p) :key #'svariable-name)))
        ))
    (if (and array (> (length (plm-variables p)) 1) (< (length (plm-variables p)) 5))
          (parray p)
        (pplm p))
    t)
  )
(defun pevpf (pred-name &optional vn array)
  (print-expected-value-pred-function pred-name vn array)
  )

;----------------SMART PRINTING---------------------------------------

; Code for a smart form of PLM printing

; Determine maximum number of regions PLM may have based on variable spans
(defun max-plm-size (p)
  (let ((size 1)
        (vs (plm-variables p))
        (as (plm-active p))
        )
    (dotimes (i (plm-rank p))
      (when (aref as i)
        (setq size (* size (stype-span (svariable-type (aref vs i)))))
        )
      )
    size)
  )

; Test if should use regions in parray of PLM
(defun parray-regions (p)
  (< (/ (plm-size p) (max-plm-size p)) max-fraction-pa-regions)
  )

; Check if a PLM has at least one large symbolic variable
(defun has-large-symbolic-variable (p)
  (find-if #'(lambda (v) (let ((st (svariable-type v))) (and (not (stype-numeric st)) (> (stype-span st) max-span-pa)))) (plm-variables p))
  )

; Use parray or pplm smartly in printing a PLM
(defun print-smart (p &optional symbolic stream summarize limits)
  (if (or (and (parrayp p) (not limits)) summarize)
      (parray p (parray-regions p) summarize stream)
    (print-plm p symbolic stream limits))
  )
; Abbreviation for print-smart with symbolic and no limits
(defun ps (p &optional stream summarize limits)
  (print-smart p t stream summarize limits)
  )

; Print perceptual function
(defun print-predicate-perception-function (pred &optional symbolic stream limits)
  (print-smart (node-function (predicate-perception pred)) symbolic stream nil limits)
  )

; Print a node
(defun print-node (n &optional symbolic stream)
  (unless stream (setq stream trace-stream))
  (unless (graph-initialized cg)
    (init-graph)
    )
  (let ((varp (variable-nodep n))
        post
        )
    (format stream "~&~%~A(" (node-name n))
    (when (node-evidence n)
      (format stream "EVIDENCE "))
    (if (factor-nodep n)
        (format stream "FACTOR): ")
      (format stream "VARIABLE): "))
    (if varp
        (progn
          (print-svariables (node-variables n) stream)
          (format stream " = ")
          (setq post (variable-posterior n))
          (if (and (node-links n) post)
              (print-smart post symbolic stream)
            (format stream "UNDEFINED")
            )
          )
      (cond ((plm-p (node-function n))
             (when (eq (node-subtype n) 'combine)
               (format stream "[*~S*] " (node-subsubtype n))
               )
             (print-smart (node-function n) symbolic stream)
             )
            (t
             (format stream "~S" (node-function n)) ; When function is not a PLM
             )
            )
      )
    (format stream "~&")
    (print-in-messages n symbolic stream)
    (print-out-messages n symbolic stream)
    (when (and (not varp) (node-factor-steps n))
      (print-factor-steps n stream))
    nil)
  )

; Print a message (given its link and index)
(defun print-message (trace-header ml mi &optional symbolic reverse print-first stream)
  (unless (graph-initialized cg)
    (init-graph)
    )
  (when (link-content ml mi)
    (let (n1 n2)
      (unless trace-header (setq trace-header '"  MESSAGE: "))
      (setq n1 (node-name (aref (link-nodes ml) mi)))
      (setq n2 (node-name (aref (link-nodes ml) (next-message-index mi))))
      (format stream "~&")
      (when trace-link-depths
        (format stream "<~S>" (aref (link-depths ml) mi))
        )
      (if reverse
          (if print-first
              (format stream "~A~A<-~A: " trace-header n2 n1)
            (format stream "~A<-~A: " trace-header n1))
        (if print-first
            (format stream "~A~A->~A: " trace-header n1 n2)
          (format stream "~A->~A: " trace-header n2)))
      (print-smart (link-content ml mi) symbolic stream)
      nil)
    )
  )

; Print just WM function (not intro text)
(defun print-pred-wm-function (pred &optional symbolic-or-summarize stream limits)
  (unless (predicate-wm pred)
    (error "No WMFN node for predicate ~S in PRINT-PRED-WM-FUNCTION" (predicate-name pred))
    )
  (print-smart (node-function (predicate-wm pred)) t stream (if (consp symbolic-or-summarize) symbolic-or-summarize nil) limits)
  )

; Print a WM function
(defun print-pred-function (pred &optional symbolic-or-summarize stream limits)
  (unless stream (setq stream trace-stream))
  (unless (predicate-wm pred)
    (error "No WMFN node for predicate ~S in PRINT-PRED-FUNCTION" (predicate-name pred))
    )
  (let ((wm (predicate-wm pred)))
    (format stream "~&  Factor ~A Function: " (node-name wm))
    (print-pred-wm-function pred symbolic-or-summarize stream limits)
    t)
  )

; Print a WM
(defun print-pred-wm (pred &optional symbolic stream limits)
  (unless stream (setq stream trace-stream))
  (unless (graph-initialized cg)
    (init-graph)
    )
  (format stream "~2&WM for ~S" (predicate-name pred))
  (let* ((wm (predicate-wm pred)) ; WM factor node
         posterior
         argmax
         link
         )
    (when wm
      (print-pred-function pred symbolic stream limits)
      )
    ; Check if there is an argmax to be done
    (when (and (consp symbolic)
               (setq argmax (find 'argmax symbolic :key #'car))
               )
      (setq symbolic (remove argmax symbolic))
      ; If removing the argmax yields an empty list, make it 'array that variables still use parray
      (when (null symbolic)
        (setq symbolic 'array)
        )
      )
    ; Print each of the WM variable nodes associated with the factor
    (dolist (wmvn (predicate-wm-vns pred))
      ; Print normalized variable posterior if there is one
      (cond ((node-exponential wmvn) ; Print exponentially transformed posterior
             (setq posterior (transform-plm #'exponentiate-constant-times10-function (variable-posterior wmvn) nil nil t))
             (when (node-normalize wmvn)
               (setq posterior (normalize-plm posterior nil t))
               )
             (when posterior
               (if (eq (node-subsubtype wmvn) 'negative)
                   (format stream "~& -") ; prefix with a - if negative condition or action
                 (format stream "~&  ")
                 )
               (format stream "Variable ~A Normalized Posterior (e^10v): " (node-name wmvn))
               (print-smart posterior symbolic stream nil limits)
               )
             )
            (t ; Print normal posterior
             (setq posterior (variable-posterior wmvn))
             (when posterior
               (if (eq (node-subsubtype wmvn) 'negative)
                   (format stream "~& -") ; prefix with a - if negative condition or action
                 (format stream "~&  ")
                 )
               (format stream "Variable ~A Normalized Posterior: " (node-name wmvn))
               (print-smart posterior symbolic stream nil limits)
               )
             )
            )
      (when wm
        (setq link (link-from-numbers (node-number wmvn) (node-number wm)))
        (when link
          (print-message '"    " link 0 symbolic t nil stream) ; Print message from variable to factor
          )
        ))
    nil)
  )
;-----------------------------------------------------
; Print messages corresponding to conditional patterns

; Find first input link to node
(defun first-input-link (n)
  (let ((direction (if (variable-nodep n) 1 0))
        )
    (dolist (l (node-links n))
      (when (aref (link-contents l) direction)
        (return l)
        )
      )
    )
  )

; Find first input message to node
(defun first-input-message (n)
  (let ((direction (if (variable-nodep n) 1 0))
        message)
    (dolist (l (node-links n))
      (setq message (aref (link-contents l) direction))
      (when message
        (return message)
        )
      )
    )
  )

; Find link into first WM variabble node (VN or VAN) towards WM from alpha variable node
; Link is the one into the node form the graph (i.e., away from WM)
(defun first-wm-variable-node-link (n link)
  (loop
   (when (and (variable-nodep n) (eq (node-subtype n) 'wm))
     (return link)
     )
   (setq link (other-link n link)) ; Get other link, assuming only two links per node in alpha network
   (setq n (aref (link-nodes link) (if (variable-nodep n) 1 0)))
   )
  )

(defun print-pattern-matches (conditional-name &optional stream)
  (unless (graph-initialized cg)
    (init-graph)
    )
  (let ((c (conditional-from-name conditional-name))
        l ams)
    (unless c
      (error "No conditional named ~S." conditional-name)
      )
    ; Find alpha memories for conditional
    (setq ams (reverse (conditional-alpha-memories (conditional-from-name conditional-name))))
    ; Handle conditions
    (when (conditional-reordered-conditions c)
      (format stream "~&~%CONDITIONS:~&~%")
      (dolist (p (conditional-reordered-conditions c))
        (format stream "~&~S:~&" p)
        (ps (first-input-message (car ams)) stream)
        (setq ams (cdr ams))
        (format stream "~&~%")
        )
      )
    ; Handle condacts
    (when (conditional-condacts c)
      (format stream "~&~%CONDACTS:~&~%")
      (dolist (p (conditional-condacts c))
        (format stream "~&~S:~&" p)
        (dolist (cl (node-links (car ams)))
          (cond ((eq (node-subtype (aref (link-nodes cl) fact-index)) 'beta)
                 (format stream "~&<-: ")
                 (print-plm (aref (link-contents cl) var-index) stream)
                 )
                (t
                 (setq cl (first-wm-variable-node-link (car ams) (other-link (car ams) cl)))
                 (format stream "~&->: ")
                 (ps (aref (link-contents cl) fact-index) stream)
                 )
                )
          )
        (setq ams (cdr ams))
        (format stream "~&~%")
        )
      )
    ; Handle actions
    (when (conditional-actions c)
      (format stream "~&~%ACTIONS:~&~%")
      (dolist (p (conditional-actions c))
        (format stream "~&~S:~&" p)
        (setq l (first-wm-variable-node-link (car ams) (first-input-link (car ams)))) ; Use message into WM variable node rather than alpha memory node
        (ps (aref (link-contents l) fact-index) stream) ; Only one message out, so posterior is this
        (setq ams (cdr ams))
        (format stream "~&~%")
        )
      )
    )
  )
(defun ppm (conditional-name)
  (print-pattern-matches conditional-name trace-stream))

;-----------------------------------------------------------
; Fix print-smart to be smarter about when not to use parray

; Determine fraction of regions that are non-empty
(defun plm-density (p)
  (let ((ne 0)
        (pa (plm-array p))
        (nregions (plm-size p)))
    (dotimes (i nregions)
      (unless (region-e-empty (row-major-aref pa i))
        (setq ne (1+ ne))
        )
      )
    (/ ne nregions)
    )
  )

; Is PLM appropriate for parray
(defun parrayp (p &optional summarize)
  summarize ; dummy (eventually get rid of argument)
  (and (plm-piecewise-constant p) (not (has-large-symbolic-variable p)) (> (plm-density p) .1))
  )
(defun ultimatum-soft ()
  (init nil '(a b))
;  (setq default-integral nil)

  (new-type 'quantity :numeric t :discrete t :min 0 :max 4)

  (predicate 'offer :world 'open :arguments '((agent agent) (quantity quantity %)))
  (predicate 'money :world 'open :arguments '((agent agent) (quantity quantity %)))
  (predicate 'operator-a :world 'open :arguments '((quantity quantity)))
  (predicate 'operator-b :world 'open :arguments '((offer quantity) (acceptance boolean)))
  (predicate 'operator-b-e :world 'open :arguments '((offer quantity) (acceptance boolean ^)))

  (conditional 'transition-a
               :conditions '((offer (agent a) (quantity (offer)))
                             )
               :condacts '((operator-a (quantity (offer)))))

  (conditional 'transition-b-b
               :conditions '((money (agent b) (quantity (moneyb))))
               :condacts '((operator-b (offer (offer)) (acceptance (choice)))
                           )
               :function-variable-names '(choice offer moneyb)
               :function '((1 true  0 0)
                           (1 true  1 1)
                           (1 true  2 2)
                           (1 true  3 3)
                           (1 false * 0))
               )

  (conditional 'exponentiate
               :conditions '((operator-b (offer (offer)) (acceptance (choice))))
               :actions '((operator-b-e (offer (offer)) (acceptance (choice))))
               )

  (conditional 'transition-a-b
               :conditions '((money (agent a) (quantity (moneya)))
                             (operator-b-e (offer (offer)) (acceptance (choice)))
                             )
               :condacts '((offer (agent a) (quantity (offer))))
               :function-variable-names '(choice offer moneya)
               :function '((1 true  0 3)
                           (1 true  1 2)
                           (1 true  2 1)
                           (1 true  3 0)
                           (1 false * 0))
               )

  (conditional 'reward
               :condacts '((money (agent (a)) (quantity (n))))
               :function-variable-names '(a n)
               :function '((.1 a 0) (.4 a 1) (.7 a 2) (1 a 3)
                           (.1 b 0) (.4 b 1) (.7 b 2) (1 b 3))
               )

  (when open-world-wmfns
    (evidence '((operator-b-e .01 (offer *) (acceptance *))))
    )

  (d 0)
  (pwm 'array)
;  (setq open-conditions-like-condacts nil)
  )

(defun test-ultimatum-soft ()
  (ultimatum-soft)
  (ppwm 'offer 'array info-stream)
  (print-global-decision-statistics info-stream)
  )
; Solve ultimatum game by backwards propagating information across decisions in subgoals.
; But do problem solving forward in this version
(defun ultimatum-forward nil
  (init nil '(a b))

  (setq post-d '((ppfn 'offer-choice nil '((argmax wm-offer)))
                 (ppfn 'accept-choice nil '((max wm-state) (argmax wm-acceptance)))
                 (ppfn 'impasse nil '((max wm-operator) (argmax wm-type)))
                 (ppfn 'selected nil '((argmax wm-operator)))
                 (print-operators 'a)
                 (print-operators 'b)
                 (ppwm 'money)
                 (ppwm 'evaluation)
                 )
        )

  (new-type 'quantity :numeric t :discrete t :min 0 :max 4)

  (predicate 'offer :world 'open :arguments '((agent agent) (doer agent) (offer quantity)))
  (predicate 'accept :world 'open :arguments '((agent agent) (doer agent) (acceptance boolean)))

  (init-operators 'predicates '(offer accept) t)

  (predicate 'money :world 'closed :no-normalize t
             :arguments '((agent agent) (owner agent) (state state) (operator operator) (quantity quantity %)))
  (predicate 'offer-choice :world 'closed :arguments '((agent agent) (doer agent) (state state) (offer quantity !)))
  (predicate 'accept-choice :world 'closed :arguments '((agent agent) (doer agent) (state state) (acceptance boolean !)))
  (predicate 'completed :world 'closed :arguments '((agent agent) (state state) (operator operator)))
  (predicate 'evaluation :world 'closed :no-normalize t :arguments '((agent agent) (state state) (operator operator %)))
  (predicate 'b-offer-probs :world 'open :exponential t :arguments '((acceptance boolean %)))

;;; "Default" conditionals for evalution operators
  ; Make evaluation operators best in subgoal for tied operators
  (conditional 'evaluate-best
               :conditions '((state (agent (a)) (state (s)))
                             (impasse (agent (a)) (state (s)) (type tie) (operator (o)))
                             (evaluate-operator (operator (eo)) (evaluate (o))))
               :actions '((selected (agent (a)) (state (s)) (operator (eo))))
               :function 1
               )

  ; Make operator to be evaluated best in no-change for evaluation operator
  (conditional 'evaluation-operator-best
               :conditions '((state (agent (a)) (state (s)))
                             (impasse (agent (a)) (state (s)) (type no-change) (operator (eo)))
                             (evaluate-operator (operator (eo)) (evaluate (o))))
               :actions '((selected (agent (a)) (state (s)) (operator (o))))
               :function 1
               )


  ; Reject evaluation operators when there is an evaluation for their operator
  (conditional 'evaluate-reject
               :conditions '((state (agent (a)) (state (s)))
                             (completed (agent (a)) (state (s)) (operator (eo))))
               :actions '((selected - (agent (a)) (state (s)) (operator (eo))))
               :function 1
               )

  ; Copy down a chosen offer from state above
  ; Should one of these conditionals be created automatically for each state predicate when detecting impasses?
  (conditional 'copy-offer-choice
               :conditions '((state (agent (a)) (state (s)))
                             (impasse (agent (a)) (state (s)))
                             (offer-choice (agent (a)) (doer (b)) (state (s -1)) (offer (offer))))
               :actions '((offer-choice (agent (a)) (doer (b)) (state (s)) (offer (offer))))
               )

;;; Conditionals for ultimatum game
  ; Make offer operators acceptable for agent a
  (conditional 'acceptable-offer
               :conditions '((state (agent a) (state (s)))
                             (offer (agent a) (doer a) (operator (o)))
                             (impasse - (agent a) (state (s)) (type tie)))
               :actions '((selected (agent a) (state (s)) (operator (o))))
               :function .1)

  ; Make accept operators acceptable for agent b if there is an offer-choice available for a
  (conditional 'acceptable-accept
               :conditions '((state (agent (a)) (state (s)))
                             (offer-choice (agent (b)) (doer a) (state (s)))
                             (accept (agent (a)) (doer b) (operator (o)))
                             (impasse - (agent (a)) (state (s)) (type tie)))
               :actions '((selected (agent (a)) (state (s)) (operator (o))))
               :function .1)

  ; Reject offer operators for agent a when there is an offer-choice
  (conditional 'reject-offer
               :conditions '((state (agent a) (state (s)))
                             (offer (agent a) (doer a) (operator (o)))
                             (offer-choice (agent a) (doer a) (state (s))))
               :actions '((selected - (agent a) (state (s)) (operator (o))))
               )

  ; Reject accept operators for agent b if there is an accept-choice
  (conditional 'reject-accept
               :conditions '((state (agent (a)) (state (s)))
                             (accept (agent (a)) (doer b) (operator (o)))
                             (accept-choice (agent (a)) (doer b) (state (s))))
               :actions '((selected - (agent (a)) (state (s)) (operator (o))))
               )


  ; Reject any accept operator for agent A at base level
  (conditional 'base-reject-accept-A
               :conditions '((state (agent a) (state 0))
                             (accept (agent a) (doer (b)) (operator (o))))
               :actions '((selected - (agent a) (state 0) (operator (o))))
               )

  ; Apply operator offer
  (conditional 'apply-offer
               :conditions '((state (agent a) (state (s)))
                             (selected (agent a) (state (s)) (operator (o)))
                             (offer (agent a) (doer a) (offer (offer)) (operator (o))))
               :actions '((offer-choice (agent a) (doer a) (state (s)) (offer (offer))))
               )

  ; Simulate communicate offer from A to B
  (conditional 'communicate-offer
               :conditions '((offer-choice (agent a) (doer a) (state 0) (offer (offer))))
               :actions '((offer-choice (agent b) (doer a) (state 0) (offer (offer))))
               )

  ; Apply operator offer
  (conditional 'apply-accept
               :conditions '((state (agent (a)) (state (s)))
                             (selected (agent (a)) (state (s)) (operator (o)))
                             (accept (agent (a)) (doer (b)) (acceptance (acc)) (operator (o))))
               :actions '((accept-choice (agent (a)) (doer (b)) (state (s)) (acceptance (acc))))
               )

  ; Simulate communicate accept from B to A
  (conditional 'communicate-accept
               :conditions '((accept-choice (agent b) (doer b) (state 0) (acceptance (acc))))
               :actions '((accept-choice (agent a) (doer b) (state 0) (acceptance (acc))))
               )

  ; Return signal that accept operator has been evaluated once there is an accept-choice
  (conditional 'evaluate-accept-done
               :conditions '((state (agent (a)) (state (s)))
                             (money (agent (a)) (owner b) (state (s)) (operator (o)))
                             (impasse (agent (a)) (state (s)) (type no-change) (operator (eo)))
                             (evaluate-operator (operator (eo)) (evaluate (o)))
                             (accept (agent (a)) (doer b) (acceptance (acc)) (operator (o))))
               :actions '((completed (agent (a)) (state (s -1)) (operator (eo))))
               )

  ; Money for b in (a)'s model
  (conditional 'money-*-b
               :conditions '((state (agent (a)) (state (s)))
                             (accept-choice (agent (a)) (doer b) (state (s)) (acceptance (acc)))
                             (accept (agent (a)) (doer b) (acceptance (acc)) (operator (o)))
                             (offer-choice (agent (a)) (doer a) (state (s)) (offer (offer))))
               :actions '((money (agent (a)) (owner b) (state (s)) (operator (o)) (quantity (money))))
               :function-variable-names '(offer acc money)
               :function '((1 0 true 0) (1 1 true 1) (1 2 true 2) (1 3 true 3)
                           (1 * false 0))
               )

  ; Money for a in a's model
  (conditional 'money-a-a
               :conditions '((state (agent a) (state (s)))
                             (accept-choice (agent a) (doer b) (state (s)) (acceptance (acc)))
                             (accept (agent a) (doer b) (acceptance (acc)) (operator (o)))
                             (offer-choice (agent a) (doer a) (state (s)) (offer (offer))))
               :actions '((money (agent a) (owner a) (state (s)) (operator (o)) (quantity (money))))
               :function-variable-names '(offer acc money)
               :function '((1 0 true 3) (1 1 true 2) (1 2 true 1) (1 3 true 0)
                           (1 * false 0))
               )

  ; Return money to evaluation space
  (conditional 'return-money
               :conditions '((state (agent (a)) (state (s)))
                             (impasse (agent (a)) (state (s)) (type no-change) (operator (eo)))
                             (evaluate-operator (operator (eo)) (evaluate (o)))
                             (money (agent (a)) (owner (own)) (state (s)) (operator (o)) (quantity (money)))
                             )
               :actions '((money (agent (a)) (owner (own)) (state (s -1)) (operator (o)) (quantity (money))))
               :function-variable-names '(money)
               :function '((.1 0) (.4 1) (.7 2) (1 3))
               )

  ; Determine normalized probability for b's action
  (conditional 'bs-probs
               :conditions '((state (agent a) (state (s)))
                             (impasse (agent a) (state (s)) (type tie) (operator (o)))
                             (money (agent a) (owner b) (state (s)) (operator (o)) (quantity (money)))
                             (accept (agent a) (doer b) (acceptance (acc)) (operator (o))))
               :condacts '((b-offer-probs (acceptance (acc))))
               )

  ; Return value of b's choice for b
  (conditional 'evaluation-accept-b
               :conditions '((state (agent b) (state (s)))
                             (impasse (agent b) (state (s)) (type tie) (operator (o)))
                             (accept (agent b) (doer b) (acceptance (acc)) (operator (o)))
                             (impasse (agent b) (state (s 1)) (type none))
                             (money (agent b) (owner b) (state (s)) (operator (o))))
               :actions '((selected (agent b) (state (s -1)) (operator (o))))
               )

  ; Return expected value of b's choice for a (probability of b choosing times value for a)
  (conditional 'evaluation-accept-a
               :conditions '((state (agent a) (state (s)))
                             (impasse (agent a) (state (s)) (type tie) (operator (o)))
                             (accept (agent a) (doer b) (acceptance (acc)) (operator (o)))
                             (impasse (agent a) (state (s 1)) (type none))
                             (money (agent a) (owner a) (state (s)) (operator (o)))
                             (b-offer-probs (acceptance (acc))))
               :actions '((evaluation (agent a) (state (s)) (operator (o))))
               )

  ; Combine a's evaluations on b's choices into an evaluation of a's choice
  (conditional 'combine-accept-evaluation
               :conditions '((state (agent a) (state (s)))
                             (impasse (agent a) (state (s)) (type tie) (operator (ao)))
                             (impasse (agent a) (state (s 1)) (type none))
                             (evaluation (agent a) (state (s)) (operator (ao)))
                             (impasse (agent a) (state (s -1)) (type no-change) (operator (eo)))
                             (evaluate-operator (operator (eo)) (evaluate (o)))
                             (offer (agent a) (doer a) (operator (o))))
               :actions '((evaluation (agent a) (state (s -2)) (operator (o))))
               )

  ; Return signal that offer operator has been evaluated once there are no more accept operators to evaluate
  (conditional 'evaluate-offer-done
               :conditions '((state (agent a) (state (s)))
                             (impasse (agent a) (state (s)) (type tie) (operator (ao)))
                             (impasse (agent a) (state (s 1)) (type none))
                             (impasse (agent a) (state (s -1)) (type no-change) (operator (eo)))
                             (evaluate-operator (operator (eo)) (evaluate (o)))
                             (offer (agent a) (doer a) (operator (o))))
               :actions '((completed (agent a) (state (s -2)) (operator (eo))))
               )

  ; Return evaluations on offer operators once they have all been evaluated
  (conditional 'return-offer-evaluations
               :conditions '((state (agent a) (state (s)))
                             (impasse (agent a) (state (s)) (type tie) (operator (o)))
                             (impasse (agent a) (state (s 1)) (type none))
                             (offer (agent a) (doer a) (operator (o)))
                             (evaluation (agent a) (state (s)) (operator (o))))
               :actions '((selected (agent a) (state (s -1)) (operator (o))))
               )

  t)

(defun test-ultimatum-forward ()
  (ultimatum-forward)
  (d 93)
  (ppfn 'offer-choice nil '((constant wm-state 0) (argmax wm-offer)) info-stream)
  (ppfn 'accept-choice nil '((max wm-state) (argmax wm-acceptance)) info-stream)
  (print-global-decision-statistics info-stream)
  )

; Print out states in hierarchy for agent a
(defun print-operators (agent)
  (let ((agent-index (position agent (stype-constants (type-from-name 'agent))))
        op)
    (format trace-stream "~&~%")
    (dotimes (s (+ (- (aref bottom-state agent-index) base-level-state) 1))
      (setq op (operator-in-state (+ s base-level-state) agent))
      (when op
        (format trace-stream "~&")
        (pid op)
        )
      )
    )
  )
(defun sr (&optional number-of-decisions)
(let (nod)
(setf nod (if number-of-decisions number-of-decisions 100))
(init '(shift right left none done))

(new-type 'index :numeric t :discrete t :min -1 :max 6)
(new-type 'wid :numeric t :discrete t :min 0 :max 10)
(new-type 'tags :constants '(LW RW FW -LRB- -RRB- BACKQUOTEBACKQUOTE CC CD COMMACHAR DOLLARSIGN DT EX HASHSIGN IN JJ JJR JJS LS LW MD NN NNP NNPS NNS PDT PERIODCHAR POS PRP PRPDOLLARSIGN RB RBR RBS RP SINGLEQUOTESINGLEQUOTE TO UH VB VBD VBG VBN VBP VBZ WDT WP WPDOLLARSIGN WRB COL))
(new-type 'lex :constants '(LW RW the dog chased cat))

(predicate 'Stack :world 'closed :arguments '((idx index) (id wid !)))
(predicate 'StackTop :world 'closed :arguments '((idx index !)))
(predicate 'InputPtr :world 'closed :arguments '((ptr wid !)))
(predicate 'dependency :world 'closed :arguments '((head wid !) (dependent wid)))
(predicate 'sentence :world 'closed :arguments '((id wid) (word lex) (tag tags !)))

(setf post-d '((print "*******************************")
               (print "Stack") (ppvn 'Stack)
               (print "Dependencies") (ppwm 'dependency)
               (print "StackTop") (ppvn 'StackTop) 
               (format t "~&Selected action: ~S" (operator-in-state base-level-state))))

(conditional 'Shift
             :conditions '((Selected (state 0) (operator shift))
                           (sentence (id (ind)) (word (evw)) (tag (evt)))
                           (stacktop (idx (stind)))
                           (InputPtr (ptr (ind))))
             :actions '((Stack (idx (stind 1)) (id (ind)))
                        (InputPtr (ptr (ind 1)))
                        (stacktop (idx (stind 1)))
                        (Selected (state 0) (operator none))))

(conditional 'Left
             :conditions '((Selected (state 0) (operator left))
                           (stacktop (idx (stind)))
                           (stack (idx (stind)) (id (s1)))
                           (stack (idx (stind -1)) (id (s2)))
                           (sentence (id (s1)) (word (w1)) (tag (t1)))
                           (sentence (id (s2)) (word (w2)) (tag (t2))))
             :actions '((Stack (idx (stind -1)) (id (s1)))
                        (Stack -(idx (stind)))
                        (stacktop (idx (stind -1)))
                        (dependency (head (s1)) (dependent (s2)))
                        (Selected (state 0) (operator none))))

(conditional 'Right
             :conditions '((Selected (state 0) (operator right))
                           (stacktop (idx (stind)))
                           (stack (idx (stind)) (id (s1)))
                           (stack (idx (stind -1)) (id (s2)))
                           (sentence (id (s1)) (word (w1)) (tag (t1)))
                           (sentence (id (s2)) (word (w2)) (tag (t2))))
             :actions '((Stack (idx (stind -1)) (id (s2)))
                        (Stack -(idx (stind)))
                        (stacktop (idx (stind -1)))
                        (dependency (head (s2)) (dependent (s1)))
                        (Selected (state 0) (operator none))))

(conditional 'Done
             :conditions '((Selected (state 0) (operator done)))
             :actions '((halt)))

(conditional 'leftrightpos
:conditions '((Selected (state 0) (operator none))
(stacktop (idx (i)))
(stack (idx (i)) (id (s1id)))
(stack (idx (i -1)) (id (s2id)))
(sentence (id (s1id)) (word (w1)) (tag (t1)))
(sentence (id (s2id)) (word (w2)) (tag (t2))))
:actions '((Selected (state 0) (operator (a))))
:FUNCTION-VARIABLE-NAMES '(a t2 t1)
:function '(
(0.01 shift DOLLARSIGN COMMACHAR)
(0.01 left DOLLARSIGN COMMACHAR)
(0.01 right DOLLARSIGN COMMACHAR)
(0.01 shift DOLLARSIGN COL)
(0.01 left DOLLARSIGN COL)
(0.01 right DOLLARSIGN COL)
(0.01001 shift COMMACHAR BACKQUOTEBACKQUOTE)
(0.01 left COMMACHAR BACKQUOTEBACKQUOTE)
(0.01 right COMMACHAR BACKQUOTEBACKQUOTE)
(0.00996 shift BACKQUOTEBACKQUOTE DOLLARSIGN)
(0.01 left BACKQUOTEBACKQUOTE DOLLARSIGN)
(0.00998 right BACKQUOTEBACKQUOTE DOLLARSIGN)
(0.00995 shift DOLLARSIGN DOLLARSIGN)
(0.01 left DOLLARSIGN DOLLARSIGN)
(0.00998 right DOLLARSIGN DOLLARSIGN)
(0.01006 shift COMMACHAR SINGLEQUOTESINGLEQUOTE)
(0.01 left COMMACHAR SINGLEQUOTESINGLEQUOTE)
(0.00999 right COMMACHAR SINGLEQUOTESINGLEQUOTE)
(0.00993 shift COMMACHAR DOLLARSIGN)
(0.01 left COMMACHAR DOLLARSIGN)
(0.00997 right COMMACHAR DOLLARSIGN)
(0.01 shift CC DOLLARSIGN)
(0.01 left CC DOLLARSIGN)
(0.01 right CC DOLLARSIGN)
(0.01001 shift COL CC)
(0.01 left COL CC)
(0.00999 right COL CC)
(0.01001 shift DOLLARSIGN CC)
(0.01 left DOLLARSIGN CC)
(0.00999 right DOLLARSIGN CC)
(0.01001 shift SINGLEQUOTESINGLEQUOTE CC)
(0.01 left SINGLEQUOTESINGLEQUOTE CC)
(0.01 right SINGLEQUOTESINGLEQUOTE CC)
(0.00998 shift CC COMMACHAR)
(0.01 left CC COMMACHAR)
(0.01002 right CC COMMACHAR)
(0.01004 shift COMMACHAR CC)
(0.01 left COMMACHAR CC)
(0.01001 right COMMACHAR CC)
(0.00998 shift CC CC)
(0.01 left CC CC)
(0.01002 right CC CC)
(0.01003 shift CC CD)
(0.01 left CC CD)
(0.01 right CC CD)
(0.00998 shift CC DT)
(0.01 left CC DT)
(0.00999 right CC DT)
(0.01001 shift CC EX)
(0.01 left CC EX)
(0.01 right CC EX)
(0.01 shift CC IN)
(0.01 left CC IN)
(0.01 right CC IN)
(0.00996 shift CC JJ)
(0.01 left CC JJ)
(0.00995 right CC JJ)
(0.00997 shift CC JJR)
(0.01 left CC JJR)
(0.00997 right CC JJR)
(0.01006 shift CC JJS)
(0.01 left CC JJS)
(0.01001 right CC JJS)
(0.01001 shift CC LS)
(0.01 left CC LS)
(0.01 right CC LS)
(0.00999 shift CC MD)
(0.01 left CC MD)
(0.01 right CC MD)
(0.01007 shift CC NN)
(0.01 left CC NN)
(0.01006 right CC NN)
(0.01001 shift CC NNP)
(0.01 left CC NNP)
(0.01 right CC NNP)
(0.01005 shift CC NNS)
(0.01 left CC NNS)
(0.01 right CC NNS)
(0.01005 shift CC POS)
(0.01 left CC POS)
(0.01002 right CC POS)
(0.01001 shift CC PRP)
(0.01 left CC PRP)
(0.01 right CC PRP)
(0.01004 shift CC RB)
(0.01 left CC RB)
(0.00999 right CC RB)
(0.01001 shift CC TO)
(0.01 left CC TO)
(0.01 right CC TO)
(0.00997 shift CC VB)
(0.01 left CC VB)
(0.00999 right CC VB)
(0.00995 shift CC VBD)
(0.01 left CC VBD)
(0.00998 right CC VBD)
(0.01002 shift CC VBG)
(0.01 left CC VBG)
(0.01 right CC VBG)
(0.01 shift CC VBN)
(0.01 left CC VBN)
(0.00999 right CC VBN)
(0.00993 shift CC VBP)
(0.01 left CC VBP)
(0.00997 right CC VBP)
(0.00997 shift CC VBZ)
(0.01 left CC VBZ)
(0.00998 right CC VBZ)
(0.00994 shift CC WDT)
(0.01 left CC WDT)
(0.00997 right CC WDT)
(0.01001 shift CC WP)
(0.01 left CC WP)
(0.01 right CC WP)
(0.01 shift CC WRB)
(0.01 left CC WRB)
(0.00999 right CC WRB)
(0.01 shift CD COMMACHAR)
(0.01 left CD COMMACHAR)
(0.01003 right CD COMMACHAR)
(0.01 shift CD COL)
(0.01 left CD COL)
(0.01003 right CD COL)
(0.01 shift CD BACKQUOTEBACKQUOTE)
(0.01 left CD BACKQUOTEBACKQUOTE)
(0.01 right CD BACKQUOTEBACKQUOTE)
(0.01 shift CD DOLLARSIGN)
(0.01 left CD DOLLARSIGN)
(0.01003 right CD DOLLARSIGN)
(0.01 shift COMMACHAR CD)
(0.01 left COMMACHAR CD)
(0.00998 right COMMACHAR CD)
(0.01001 shift CD SINGLEQUOTESINGLEQUOTE)
(0.01 left CD SINGLEQUOTESINGLEQUOTE)
(0.00999 right CD SINGLEQUOTESINGLEQUOTE)
(0.01001 shift COL CD)
(0.01 left COL CD)
(0.00997 right COL CD)
(0.00997 shift HASHSIGN CD)
(0.01 left HASHSIGN CD)
(0.00994 right HASHSIGN CD)
(0.00993 shift DOLLARSIGN CD)
(0.01 left DOLLARSIGN CD)
(0.01005 right DOLLARSIGN CD)
(0.01001 shift CD CC)
(0.01 left CD CC)
(0.00999 right CD CC)
(0.00984 shift CD CD)
(0.01 left CD CD)
(0.00984 right CD CD)
(0.01 shift CD DT)
(0.01 left CD DT)
(0.00996 right CD DT)
(0.01 shift CD IN)
(0.01 left CD IN)
(0.01004 right CD IN)
(0.01 shift CD JJ)
(0.01 left CD JJ)
(0.01001 right CD JJ)
(0.00999 shift CD JJR)
(0.01 left CD JJR)
(0.01 right CD JJR)
(0.01 shift CD -LRB-)
(0.01 left CD -LRB-)
(0.01 right CD -LRB-)
(0.00993 shift CD NN)
(0.01 left CD NN)
(0.00997 right CD NN)
(0.01004 shift CD NNP)
(0.01 left CD NNP)
(0.01001 right CD NNP)
(0.00991 shift CD NNS)
(0.01 left CD NNS)
(0.0099 right CD NNS)
(0.00997 shift CD POS)
(0.01 left CD POS)
(0.00999 right CD POS)
(0.01001 shift CD PRP)
(0.01 left CD PRP)
(0.00999 right CD PRP)
(0.01002 shift CD RB)
(0.01 left CD RB)
(0.01005 right CD RB)
(0.00997 shift CD RBR)
(0.01 left CD RBR)
(0.00998 right CD RBR)
(0.01 shift CD -RRB-)
(0.01 left CD -RRB-)
(0.01 right CD -RRB-)
(0.01001 shift CD TO)
(0.01 left CD TO)
(0.01 right CD TO)
(0.01004 shift CD VB)
(0.01 left CD VB)
(0.01003 right CD VB)
(0.01005 shift CD VBD)
(0.01 left CD VBD)
(0.01003 right CD VBD)
(0.01004 shift CD VBG)
(0.01 left CD VBG)
(0.01002 right CD VBG)
(0.01002 shift CD VBN)
(0.01 left CD VBN)
(0.01002 right CD VBN)
(0.01005 shift CD VBZ)
(0.01 left CD VBZ)
(0.01004 right CD VBZ)
(0.01 shift CD WDT)
(0.01 left CD WDT)
(0.01 right CD WDT)
(0.01 shift CD WP)
(0.01 left CD WP)
(0.01 right CD WP)
(0.01001 shift CD WRB)
(0.01 left CD WRB)
(0.01 right CD WRB)
(0.01001 shift COL DT)
(0.01 left COL DT)
(0.01 right COL DT)
(0.01001 shift DT BACKQUOTEBACKQUOTE)
(0.01 left DT BACKQUOTEBACKQUOTE)
(0.01 right DT BACKQUOTEBACKQUOTE)
(0.00999 shift BACKQUOTEBACKQUOTE DT)
(0.01 left BACKQUOTEBACKQUOTE DT)
(0.01 right BACKQUOTEBACKQUOTE DT)
(0.01001 shift SINGLEQUOTESINGLEQUOTE DT)
(0.01 left SINGLEQUOTESINGLEQUOTE DT)
(0.01 right SINGLEQUOTESINGLEQUOTE DT)
(0.01003 shift COMMACHAR DT)
(0.01 left COMMACHAR DT)
(0.01001 right COMMACHAR DT)
(0.01008 shift DT DOLLARSIGN)
(0.01 left DT DOLLARSIGN)
(0.01001 right DT DOLLARSIGN)
(0.00999 shift DT CC)
(0.01 left DT CC)
(0.01004 right DT CC)
(0.00998 shift DT CD)
(0.01 left DT CD)
(0.01001 right DT CD)
(0.01 shift DT DT)
(0.01 left DT DT)
(0.01 right DT DT)
(0.01 shift DT IN)
(0.01 left DT IN)
(0.01007 right DT IN)
(0.01004 shift DT JJ)
(0.01 left DT JJ)
(0.00995 right DT JJ)
(0.01007 shift DT JJR)
(0.01 left DT JJR)
(0.01003 right DT JJR)
(0.01001 shift DT JJS)
(0.01 left DT JJS)
(0.00997 right DT JJS)
(0.01004 shift DT MD)
(0.01 left DT MD)
(0.01008 right DT MD)
(0.00993 shift DT NN)
(0.01 left DT NN)
(0.00991 right DT NN)
(0.00995 shift DT NNP)
(0.01 left DT NNP)
(0.00991 right DT NNP)
(0.00995 shift DT NNS)
(0.01 left DT NNS)
(0.00993 right DT NNS)
(0.00987 shift DT POS)
(0.01 left DT POS)
(0.00994 right DT POS)
(0.00998 shift DT RB)
(0.01 left DT RB)
(0.00996 right DT RB)
(0.00997 shift DT RBR)
(0.01 left DT RBR)
(0.00996 right DT RBR)
(0.01004 shift DT RBS)
(0.01 left DT RBS)
(0.01002 right DT RBS)
(0.00996 shift DT RP)
(0.01 left DT RP)
(0.00994 right DT RP)
(0.00991 shift DT TO)
(0.01 left DT TO)
(0.00995 right DT TO)
(0.01007 shift DT VBD)
(0.01 left DT VBD)
(0.0101 right DT VBD)
(0.00998 shift DT VBG)
(0.01 left DT VBG)
(0.00999 right DT VBG)
(0.01008 shift DT VBN)
(0.01 left DT VBN)
(0.01004 right DT VBN)
(0.01001 shift DT VBP)
(0.01 left DT VBP)
(0.01003 right DT VBP)
(0.01005 shift DT VBZ)
(0.01 left DT VBZ)
(0.01007 right DT VBZ)
(0.01 shift DT WP)
(0.01 left DT WP)
(0.01002 right DT WP)
(0.00999 shift EX MD)
(0.01 left EX MD)
(0.01 right EX MD)
(0.01003 shift EX POS)
(0.01 left EX POS)
(0.01001 right EX POS)
(0.00997 shift EX VBD)
(0.01 left EX VBD)
(0.00999 right EX VBD)
(0.00996 shift EX VBZ)
(0.01 left EX VBZ)
(0.00998 right EX VBZ)
(0.01 shift IN DOLLARSIGN)
(0.01 left IN DOLLARSIGN)
(0.01 right IN DOLLARSIGN)
(0.00999 shift IN COL)
(0.01 left IN COL)
(0.01001 right IN COL)
(0.00999 shift IN HASHSIGN)
(0.01 left IN HASHSIGN)
(0.01001 right IN HASHSIGN)
(0.00999 shift IN SINGLEQUOTESINGLEQUOTE)
(0.01 left IN SINGLEQUOTESINGLEQUOTE)
(0.01001 right IN SINGLEQUOTESINGLEQUOTE)
(0.00998 shift COMMACHAR IN)
(0.01 left COMMACHAR IN)
(0.00996 right COMMACHAR IN)
(0.00997 shift COL IN)
(0.01 left COL IN)
(0.00996 right COL IN)
(0.00996 shift IN BACKQUOTEBACKQUOTE)
(0.01 left IN BACKQUOTEBACKQUOTE)
(0.01004 right IN BACKQUOTEBACKQUOTE)
(0.01004 shift DOLLARSIGN IN)
(0.01 left DOLLARSIGN IN)
(0.01004 right DOLLARSIGN IN)
(0.01004 shift IN COMMACHAR)
(0.01 left IN COMMACHAR)
(0.00996 right IN COMMACHAR)
(0.00992 shift BACKQUOTEBACKQUOTE IN)
(0.01 left BACKQUOTEBACKQUOTE IN)
(0.00993 right BACKQUOTEBACKQUOTE IN)
(0.00997 shift IN CC)
(0.01 left IN CC)
(0.01003 right IN CC)
(0.00999 shift IN CD)
(0.01 left IN CD)
(0.01002 right IN CD)
(0.00999 shift IN DT)
(0.01 left IN DT)
(0.00998 right IN DT)
(0.01002 shift IN EX)
(0.01 left IN EX)
(0.00998 right IN EX)
(0.00993 shift IN IN)
(0.01 left IN IN)
(0.00995 right IN IN)
(0.01 shift IN JJ)
(0.01 left IN JJ)
(0.01 right IN JJ)
(0.01003 shift IN JJR)
(0.01 left IN JJR)
(0.00999 right IN JJR)
(0.00996 shift IN JJS)
(0.01 left IN JJS)
(0.01003 right IN JJS)
(0.01001 shift IN -LRB-)
(0.01 left IN -LRB-)
(0.00999 right IN -LRB-)
(0.01 shift IN MD)
(0.01 left IN MD)
(0.00998 right IN MD)
(0.01003 shift IN NN)
(0.01 left IN NN)
(0.01009 right IN NN)
(0.01001 shift IN NNP)
(0.01 left IN NNP)
(0.0101 right IN NNP)
(0.01004 shift IN NNS)
(0.01 left IN NNS)
(0.01006 right IN NNS)
(0.01001 shift IN PDT)
(0.01 left IN PDT)
(0.00999 right IN PDT)
(0.01006 shift IN POS)
(0.01 left IN POS)
(0.01004 right IN POS)
(0.01 shift IN PRP)
(0.01 left IN PRP)
(0.01 right IN PRP)
(0.01001 shift IN PRPDOLLARSIGN)
(0.01 left IN PRPDOLLARSIGN)
(0.00999 right IN PRPDOLLARSIGN)
(0.00999 shift IN RB)
(0.01 left IN RB)
(0.00995 right IN RB)
(0.01001 shift IN RBS)
(0.01 left IN RBS)
(0.00999 right IN RBS)
(0.01 shift IN TO)
(0.01 left IN TO)
(0.01 right IN TO)
(0.01 shift IN VB)
(0.01 left IN VB)
(0.00996 right IN VB)
(0.01007 shift IN VBD)
(0.01 left IN VBD)
(0.01001 right IN VBD)
(0.01001 shift IN VBG)
(0.01 left IN VBG)
(0.01 right IN VBG)
(0.00995 shift IN VBN)
(0.01 left IN VBN)
(0.00996 right IN VBN)
(0.01004 shift IN VBP)
(0.01 left IN VBP)
(0.01 right IN VBP)
(0.01004 shift IN VBZ)
(0.01 left IN VBZ)
(0.01001 right IN VBZ)
(0.00995 shift IN WDT)
(0.01 left IN WDT)
(0.01005 right IN WDT)
(0.01 shift IN WP)
(0.01 left IN WP)
(0.01 right IN WP)
(0.01 shift IN WPDOLLARSIGN)
(0.01 left IN WPDOLLARSIGN)
(0.01 right IN WPDOLLARSIGN)
(0.00998 shift IN WRB)
(0.01 left IN WRB)
(0.00995 right IN WRB)
(0.01 shift JJ PERIODCHAR)
(0.01 left JJ PERIODCHAR)
(0.01002 right JJ PERIODCHAR)
(0.01 shift JJ COMMACHAR)
(0.01 left JJ COMMACHAR)
(0.01 right JJ COMMACHAR)
(0.01 shift JJ COL)
(0.01 left JJ COL)
(0.01 right JJ COL)
(0.01 shift SINGLEQUOTESINGLEQUOTE JJ)
(0.01 left SINGLEQUOTESINGLEQUOTE JJ)
(0.00999 right SINGLEQUOTESINGLEQUOTE JJ)
(0.01 shift BACKQUOTEBACKQUOTE JJ)
(0.01 left BACKQUOTEBACKQUOTE JJ)
(0.00998 right BACKQUOTEBACKQUOTE JJ)
(0.00999 shift JJ DOLLARSIGN)
(0.01 left JJ DOLLARSIGN)
(0.01 right JJ DOLLARSIGN)
(0.01001 shift COL JJ)
(0.01 left COL JJ)
(0.01 right COL JJ)
(0.01002 shift DOLLARSIGN JJ)
(0.01 left DOLLARSIGN JJ)
(0.01008 right DOLLARSIGN JJ)
(0.01002 shift COMMACHAR JJ)
(0.01 left COMMACHAR JJ)
(0.01001 right COMMACHAR JJ)
(0.01005 shift JJ BACKQUOTEBACKQUOTE)
(0.01 left JJ BACKQUOTEBACKQUOTE)
(0.01 right JJ BACKQUOTEBACKQUOTE)
(0.01005 shift JJ SINGLEQUOTESINGLEQUOTE)
(0.01 left JJ SINGLEQUOTESINGLEQUOTE)
(0.01 right JJ SINGLEQUOTESINGLEQUOTE)
(0.01001 shift JJ CC)
(0.01 left JJ CC)
(0.01001 right JJ CC)
(0.01 shift JJ CD)
(0.01 left JJ CD)
(0.01 right JJ CD)
(0.01 shift JJ DT)
(0.01 left JJ DT)
(0.01 right JJ DT)
(0.01 shift JJ IN)
(0.01 left JJ IN)
(0.01 right JJ IN)
(0.00996 shift JJ JJ)
(0.01 left JJ JJ)
(0.00991 right JJ JJ)
(0.00999 shift JJ JJR)
(0.01 left JJ JJR)
(0.01003 right JJ JJR)
(0.01 shift JJ JJS)
(0.01 left JJ JJS)
(0.01002 right JJ JJS)
(0.00994 shift JJ NN)
(0.01 left JJ NN)
(0.00992 right JJ NN)
(0.01 shift JJ NNP)
(0.01 left JJ NNP)
(0.00998 right JJ NNP)
(0.00989 shift JJ NNS)
(0.01 left JJ NNS)
(0.0099 right JJ NNS)
(0.00989 shift JJ POS)
(0.01 left JJ POS)
(0.00995 right JJ POS)
(0.01003 shift JJ PRP)
(0.01 left JJ PRP)
(0.01 right JJ PRP)
(0.01 shift JJR COMMACHAR)
(0.01 left JJR COMMACHAR)
(0.01 right JJR COMMACHAR)
(0.01002 shift COMMACHAR JJR)
(0.01 left COMMACHAR JJR)
(0.01001 right COMMACHAR JJR)
(0.00996 shift DOLLARSIGN JJR)
(0.01 left DOLLARSIGN JJR)
(0.00996 right DOLLARSIGN JJR)
(0.00994 shift JJR DOLLARSIGN)
(0.01 left JJR DOLLARSIGN)
(0.00997 right JJR DOLLARSIGN)
(0.00998 shift JJ RB)
(0.01 left JJ RB)
(0.00998 right JJ RB)
(0.01003 shift JJ RBR)
(0.01 left JJ RBR)
(0.01 right JJ RBR)
(0.01001 shift JJ RBS)
(0.01 left JJ RBS)
(0.01 right JJ RBS)
(0.01 shift JJR IN)
(0.01 left JJR IN)
(0.01 right JJR IN)
(0.01006 shift JJR JJ)
(0.01 left JJR JJ)
(0.01003 right JJR JJ)
(0.00995 shift JJR JJR)
(0.01 left JJR JJR)
(0.00998 right JJR JJR)
(0.00999 shift JJR NN)
(0.01 left JJR NN)
(0.00996 right JJR NN)
(0.01002 shift JJR NNP)
(0.01 left JJR NNP)
(0.01001 right JJR NNP)
(0.00996 shift JJR NNS)
(0.01 left JJR NNS)
(0.00995 right JJR NNS)
(0.01 shift JJ RP)
(0.01 left JJ RP)
(0.01001 right JJ RP)
(0.01 shift JJ -RRB-)
(0.01 left JJ -RRB-)
(0.01 right JJ -RRB-)
(0.01004 shift JJR VB)
(0.01 left JJR VB)
(0.01007 right JJR VB)
(0.00998 shift JJS COMMACHAR)
(0.01 left JJS COMMACHAR)
(0.01002 right JJS COMMACHAR)
(0.00998 shift COMMACHAR JJS)
(0.01 left COMMACHAR JJS)
(0.00999 right COMMACHAR JJS)
(0.01003 shift BACKQUOTEBACKQUOTE JJS)
(0.01 left BACKQUOTEBACKQUOTE JJS)
(0.01001 right BACKQUOTEBACKQUOTE JJS)
(0.00997 shift COL JJS)
(0.01 left COL JJS)
(0.00999 right COL JJS)
(0.01001 shift JJS CC)
(0.01 left JJS CC)
(0.00999 right JJS CC)
(0.01005 shift JJS IN)
(0.01 left JJS IN)
(0.01004 right JJS IN)
(0.00999 shift JJS JJ)
(0.01 left JJS JJ)
(0.01 right JJS JJ)
(0.01 shift JJS NN)
(0.01 left JJS NN)
(0.00999 right JJS NN)
(0.01 shift JJS NNP)
(0.01 left JJS NNP)
(0.00997 right JJS NNP)
(0.00997 shift JJS NNS)
(0.01 left JJS NNS)
(0.00996 right JJS NNS)
(0.00999 shift JJS POS)
(0.01 left JJS POS)
(0.01 right JJS POS)
(0.00999 shift JJS RB)
(0.01 left JJS RB)
(0.01002 right JJS RB)
(0.01002 shift JJS VBG)
(0.01 left JJS VBG)
(0.01002 right JJS VBG)
(0.00998 shift JJS VBZ)
(0.01 left JJS VBZ)
(0.00999 right JJS VBZ)
(0.01003 shift JJ TO)
(0.01 left JJ TO)
(0.01001 right JJ TO)
(0.01009 shift JJ VB)
(0.01 left JJ VB)
(0.01007 right JJ VB)
(0.01004 shift JJ VBD)
(0.01 left JJ VBD)
(0.01003 right JJ VBD)
(0.01001 shift JJ VBG)
(0.01 left JJ VBG)
(0.01006 right JJ VBG)
(0.00996 shift JJ VBN)
(0.01 left JJ VBN)
(0.01005 right JJ VBN)
(0.00997 shift JJ VBP)
(0.01 left JJ VBP)
(0.00999 right JJ VBP)
(0.01001 shift JJ VBZ)
(0.01 left JJ VBZ)
(0.01001 right JJ VBZ)
(0.00999 shift -LRB- DOLLARSIGN)
(0.01 left -LRB- DOLLARSIGN)
(0.01 right -LRB- DOLLARSIGN)
(0.01 shift -LRB- CC)
(0.01 left -LRB- CC)
(0.01 right -LRB- CC)
(0.01 shift -LRB- CD)
(0.01 left -LRB- CD)
(0.01 right -LRB- CD)
(0.01003 shift -LRB- DT)
(0.01 left -LRB- DT)
(0.01001 right -LRB- DT)
(0.00995 shift -LRB- IN)
(0.01 left -LRB- IN)
(0.00996 right -LRB- IN)
(0.01 shift -LRB- JJ)
(0.01 left -LRB- JJ)
(0.01 right -LRB- JJ)
(0.01 shift -LRB- NN)
(0.01 left -LRB- NN)
(0.01 right -LRB- NN)
(0.01002 shift -LRB- NNP)
(0.01 left -LRB- NNP)
(0.00999 right -LRB- NNP)
(0.01002 shift -LRB- NNS)
(0.01 left -LRB- NNS)
(0.01001 right -LRB- NNS)
(0.01001 shift -LRB- RB)
(0.01 left -LRB- RB)
(0.01 right -LRB- RB)
(0.01004 shift -LRB- UH)
(0.01 left -LRB- UH)
(0.01001 right -LRB- UH)
(0.00995 shift -LRB- VB)
(0.01 left -LRB- VB)
(0.00998 right -LRB- VB)
(0.00999 shift -LRB- VBD)
(0.01 left -LRB- VBD)
(0.01 right -LRB- VBD)
(0.00998 shift -LRB- VBG)
(0.01 left -LRB- VBG)
(0.00999 right -LRB- VBG)
(0.00998 shift -LRB- VBN)
(0.01 left -LRB- VBN)
(0.00998 right -LRB- VBN)
(0.00998 shift -LRB- WDT)
(0.01 left -LRB- WDT)
(0.00998 right -LRB- WDT)
(0.01001 shift LS NN)
(0.01 left LS NN)
(0.01 right LS NN)
(0.00998 shift LS NNS)
(0.01 left LS NNS)
(0.00998 right LS NNS)
(0.01001 shift LW CD)
(0.01 left LW CD)
(0.00999 right LW CD)
(0.01001 shift LW IN)
(0.01 left LW IN)
(0.00999 right LW IN)
(0.01003 shift LW MD)
(0.01 left LW MD)
(0.01001 right LW MD)
(0.01001 shift LW NN)
(0.01 left LW NN)
(0.01 right LW NN)
(0.01 shift LW NNP)
(0.01 left LW NNP)
(0.01 right LW NNP)
(0.01001 shift LW NNS)
(0.01 left LW NNS)
(0.01001 right LW NNS)
(0.01001 shift LW POS)
(0.01 left LW POS)
(0.01 right LW POS)
(0.01 shift LW RB)
(0.01 left LW RB)
(0.01 right LW RB)
(0.01 shift LW VB)
(0.01 left LW VB)
(0.01 right LW VB)
(0.01006 shift LW VBD)
(0.01 left LW VBD)
(0.01002 right LW VBD)
(0.01 shift LW VBN)
(0.01 left LW VBN)
(0.01 right LW VBN)
(0.01004 shift LW VBP)
(0.01 left LW VBP)
(0.01 right LW VBP)
(0.01005 shift LW VBZ)
(0.01 left LW VBZ)
(0.01001 right LW VBZ)
(0.01 shift LW WRB)
(0.01 left LW WRB)
(0.01 right LW WRB)
(0.01 shift BACKQUOTEBACKQUOTE MD)
(0.01 left BACKQUOTEBACKQUOTE MD)
(0.00999 right BACKQUOTEBACKQUOTE MD)
(0.01 shift MD PERIODCHAR)
(0.01 left MD PERIODCHAR)
(0.01 right MD PERIODCHAR)
(0.00999 shift MD BACKQUOTEBACKQUOTE)
(0.01 left MD BACKQUOTEBACKQUOTE)
(0.01001 right MD BACKQUOTEBACKQUOTE)
(0.00999 shift COL MD)
(0.01 left COL MD)
(0.01 right COL MD)
(0.00999 shift SINGLEQUOTESINGLEQUOTE MD)
(0.01 left SINGLEQUOTESINGLEQUOTE MD)
(0.01 right SINGLEQUOTESINGLEQUOTE MD)
(0.00999 shift DOLLARSIGN MD)
(0.01 left DOLLARSIGN MD)
(0.01 right DOLLARSIGN MD)
(0.00999 shift MD SINGLEQUOTESINGLEQUOTE)
(0.01 left MD SINGLEQUOTESINGLEQUOTE)
(0.01001 right MD SINGLEQUOTESINGLEQUOTE)
(0.01002 shift MD COL)
(0.01 left MD COL)
(0.00998 right MD COL)
(0.01002 shift MD COMMACHAR)
(0.01 left MD COMMACHAR)
(0.00998 right MD COMMACHAR)
(0.00995 shift COMMACHAR MD)
(0.01 left COMMACHAR MD)
(0.00998 right COMMACHAR MD)
(0.01 shift MD CC)
(0.01 left MD CC)
(0.01 right MD CC)
(0.00998 shift MD DT)
(0.01 left MD DT)
(0.01002 right MD DT)
(0.01001 shift MD IN)
(0.01 left MD IN)
(0.00999 right MD IN)
(0.01001 shift MD MD)
(0.01 left MD MD)
(0.00998 right MD MD)
(0.01003 shift MD NN)
(0.01 left MD NN)
(0.00999 right MD NN)
(0.01 shift MD NNP)
(0.01 left MD NNP)
(0.01003 right MD NNP)
(0.01001 shift MD NNS)
(0.01 left MD NNS)
(0.01004 right MD NNS)
(0.01001 shift MD PRP)
(0.01 left MD PRP)
(0.00999 right MD PRP)
(0.00997 shift MD RB)
(0.01 left MD RB)
(0.01007 right MD RB)
(0.01 shift MD RBR)
(0.01 left MD RBR)
(0.01 right MD RBR)
(0.01012 shift MD VB)
(0.01 left MD VB)
(0.01007 right MD VB)
(0.00994 shift MD VBD)
(0.01 left MD VBD)
(0.00993 right MD VBD)
(0.00998 shift MD VBP)
(0.01 left MD VBP)
(0.00999 right MD VBP)
(0.00997 shift MD VBZ)
(0.01 left MD VBZ)
(0.00997 right MD VBZ)
(0.01 shift NN SINGLEQUOTESINGLEQUOTE)
(0.01 left NN SINGLEQUOTESINGLEQUOTE)
(0.01 right NN SINGLEQUOTESINGLEQUOTE)
(0.01 shift NN COMMACHAR)
(0.01 left NN COMMACHAR)
(0.01002 right NN COMMACHAR)
(0.01001 shift SINGLEQUOTESINGLEQUOTE NN)
(0.01 left SINGLEQUOTESINGLEQUOTE NN)
(0.01 right SINGLEQUOTESINGLEQUOTE NN)
(0.00999 shift NN PERIODCHAR)
(0.01 left NN PERIODCHAR)
(0.01004 right NN PERIODCHAR)
(0.01001 shift NN BACKQUOTEBACKQUOTE)
(0.01 left NN BACKQUOTEBACKQUOTE)
(0.01001 right NN BACKQUOTEBACKQUOTE)
(0.01002 shift NN COL)
(0.01 left NN COL)
(0.01 right NN COL)
(0.00997 shift BACKQUOTEBACKQUOTE NN)
(0.01 left BACKQUOTEBACKQUOTE NN)
(0.00998 right BACKQUOTEBACKQUOTE NN)
(0.00996 shift DOLLARSIGN NN)
(0.01 left DOLLARSIGN NN)
(0.00991 right DOLLARSIGN NN)
(0.00995 shift NN DOLLARSIGN)
(0.01 left NN DOLLARSIGN)
(0.00998 right NN DOLLARSIGN)
(0.01007 shift COMMACHAR NN)
(0.01 left COMMACHAR NN)
(0.01002 right COMMACHAR NN)
(0.01007 shift COL NN)
(0.01 left COL NN)
(0.01 right COL NN)
(0.01002 shift NN CC)
(0.01 left NN CC)
(0.00998 right NN CC)
(0.01 shift NN CD)
(0.01 left NN CD)
(0.00999 right NN CD)
(0.00999 shift NN DT)
(0.01 left NN DT)
(0.00999 right NN DT)
(0.01005 shift NN IN)
(0.01 left NN IN)
(0.01005 right NN IN)
(0.01002 shift NN JJ)
(0.01 left NN JJ)
(0.01006 right NN JJ)
(0.01 shift NN JJR)
(0.01 left NN JJR)
(0.01003 right NN JJR)
(0.00992 shift NN JJS)
(0.01 left NN JJS)
(0.00994 right NN JJS)
(0.01003 shift NN -LRB-)
(0.01 left NN -LRB-)
(0.01 right NN -LRB-)
(0.01001 shift NN MD)
(0.01 left NN MD)
(0.01003 right NN MD)
(0.00995 shift NN NN)
(0.01 left NN NN)
(0.0099 right NN NN)
(0.00997 shift NN NNP)
(0.01 left NN NNP)
(0.00993 right NN NNP)
(0.00994 shift NN NNS)
(0.01 left NN NNS)
(0.00993 right NN NNS)
(0.01 shift NNP COMMACHAR)
(0.01 left NNP COMMACHAR)
(0.01005 right NNP COMMACHAR)
(0.01 shift SINGLEQUOTESINGLEQUOTE NNP)
(0.01 left SINGLEQUOTESINGLEQUOTE NNP)
(0.00999 right SINGLEQUOTESINGLEQUOTE NNP)
(0.01001 shift COL NNP)
(0.01 left COL NNP)
(0.01 right COL NNP)
(0.01001 shift NNP COL)
(0.01 left NNP COL)
(0.01003 right NNP COL)
(0.00998 shift NNP BACKQUOTEBACKQUOTE)
(0.01 left NNP BACKQUOTEBACKQUOTE)
(0.01002 right NNP BACKQUOTEBACKQUOTE)
(0.01002 shift BACKQUOTEBACKQUOTE NNP)
(0.01 left BACKQUOTEBACKQUOTE NNP)
(0.01001 right BACKQUOTEBACKQUOTE NNP)
(0.00997 shift PERIODCHAR NNP)
(0.01 left PERIODCHAR NNP)
(0.00996 right PERIODCHAR NNP)
(0.01004 shift COMMACHAR NNP)
(0.01 left COMMACHAR NNP)
(0.01001 right COMMACHAR NNP)
(0.01005 shift NNP SINGLEQUOTESINGLEQUOTE)
(0.01 left NNP SINGLEQUOTESINGLEQUOTE)
(0.01 right NNP SINGLEQUOTESINGLEQUOTE)
(0.01006 shift NNP PERIODCHAR)
(0.01 left NNP PERIODCHAR)
(0.01001 right NNP PERIODCHAR)
(0.01003 shift NNP CC)
(0.01 left NNP CC)
(0.01001 right NNP CC)
(0.01007 shift NNP CD)
(0.01 left NNP CD)
(0.0101 right NNP CD)
(0.01003 shift NNP IN)
(0.01 left NNP IN)
(0.0101 right NNP IN)
(0.00999 shift NNP JJ)
(0.01 left NNP JJ)
(0.01002 right NNP JJ)
(0.01001 shift NNP JJS)
(0.01 left NNP JJS)
(0.01 right NNP JJS)
(0.01004 shift NNP -LRB-)
(0.01 left NNP -LRB-)
(0.01001 right NNP -LRB-)
(0.00995 shift NNP MD)
(0.01 left NNP MD)
(0.00998 right NNP MD)
(0.00996 shift NNP NN)
(0.01 left NNP NN)
(0.00992 right NNP NN)
(0.00995 shift NNP NNP)
(0.01 left NNP NNP)
(0.00995 right NNP NNP)
(0.00994 shift NNP NNS)
(0.01 left NNP NNS)
(0.0099 right NNP NNS)
(0.00987 shift NN POS)
(0.01 left NN POS)
(0.00993 right NN POS)
(0.00986 shift NNP POS)
(0.01 left NNP POS)
(0.00993 right NNP POS)
(0.01006 shift NNP RB)
(0.01 left NNP RB)
(0.00999 right NNP RB)
(0.01003 shift NN PRP)
(0.01 left NN PRP)
(0.01 right NN PRP)
(0.01002 shift NNP -RRB-)
(0.01 left NNP -RRB-)
(0.01006 right NNP -RRB-)
(0.01001 shift COMMACHAR NNPS)
(0.01 left COMMACHAR NNPS)
(0.01 right COMMACHAR NNPS)
(0.01 shift NNPS VBD)
(0.01 left NNPS VBD)
(0.01 right NNPS VBD)
(0.01002 shift NNP TO)
(0.01 left NNP TO)
(0.01 right NNP TO)
(0.0099 shift NNP VB)
(0.01 left NNP VB)
(0.00994 right NNP VB)
(0.00993 shift NNP VBD)
(0.01 left NNP VBD)
(0.00994 right NNP VBD)
(0.00999 shift NNP VBG)
(0.01 left NNP VBG)
(0.00998 right NNP VBG)
(0.00999 shift NNP VBN)
(0.01 left NNP VBN)
(0.01 right NNP VBN)
(0.00995 shift NNP VBP)
(0.01 left NNP VBP)
(0.00998 right NNP VBP)
(0.00998 shift NNP VBZ)
(0.01 left NNP VBZ)
(0.00996 right NNP VBZ)
(0.01007 shift NNP WDT)
(0.01 left NNP WDT)
(0.01003 right NNP WDT)
(0.01003 shift NNP WPDOLLARSIGN)
(0.01 left NNP WPDOLLARSIGN)
(0.01 right NNP WPDOLLARSIGN)
(0.01004 shift NNP WP)
(0.01 left NNP WP)
(0.01 right NNP WP)
(0.01003 shift NNP WRB)
(0.01 left NNP WRB)
(0.01004 right NNP WRB)
(0.00995 shift NN RB)
(0.01 left NN RB)
(0.00992 right NN RB)
(0.00997 shift NN RBR)
(0.01 left NN RBR)
(0.00994 right NN RBR)
(0.01 shift NN RBS)
(0.01 left NN RBS)
(0.01 right NN RBS)
(0.01 shift NN RP)
(0.01 left NN RP)
(0.01004 right NN RP)
(0.01 shift NN -RRB-)
(0.01 left NN -RRB-)
(0.01001 right NN -RRB-)
(0.01 shift NNS COMMACHAR)
(0.01 left NNS COMMACHAR)
(0.01 right NNS COMMACHAR)
(0.01001 shift NNS COL)
(0.01 left NNS COL)
(0.01004 right NNS COL)
(0.00999 shift DOLLARSIGN NNS)
(0.01 left DOLLARSIGN NNS)
(0.00999 right DOLLARSIGN NNS)
(0.01002 shift NNS SINGLEQUOTESINGLEQUOTE)
(0.01 left NNS SINGLEQUOTESINGLEQUOTE)
(0.01 right NNS SINGLEQUOTESINGLEQUOTE)
(0.00998 shift SINGLEQUOTESINGLEQUOTE NNS)
(0.01 left SINGLEQUOTESINGLEQUOTE NNS)
(0.00999 right SINGLEQUOTESINGLEQUOTE NNS)
(0.01003 shift BACKQUOTEBACKQUOTE NNS)
(0.01 left BACKQUOTEBACKQUOTE NNS)
(0.01 right BACKQUOTEBACKQUOTE NNS)
(0.01003 shift NNS DOLLARSIGN)
(0.01 left NNS DOLLARSIGN)
(0.01003 right NNS DOLLARSIGN)
(0.01003 shift NNS BACKQUOTEBACKQUOTE)
(0.01 left NNS BACKQUOTEBACKQUOTE)
(0.00997 right NNS BACKQUOTEBACKQUOTE)
(0.01009 shift COL NNS)
(0.01 left COL NNS)
(0.01003 right COL NNS)
(0.01009 shift COMMACHAR NNS)
(0.01 left COMMACHAR NNS)
(0.01004 right COMMACHAR NNS)
(0.01003 shift NNS CC)
(0.01 left NNS CC)
(0.00997 right NNS CC)
(0.00998 shift NNS CD)
(0.01 left NNS CD)
(0.01 right NNS CD)
(0.00998 shift NNS DT)
(0.01 left NNS DT)
(0.00995 right NNS DT)
(0.01004 shift NNS IN)
(0.01 left NNS IN)
(0.01007 right NNS IN)
(0.01002 shift NNS JJ)
(0.01 left NNS JJ)
(0.01003 right NNS JJ)
(0.01001 shift NNS JJR)
(0.01 left NNS JJR)
(0.01005 right NNS JJR)
(0.01002 shift NNS -LRB-)
(0.01 left NNS -LRB-)
(0.01 right NNS -LRB-)
(0.01001 shift NNS MD)
(0.01 left NNS MD)
(0.01001 right NNS MD)
(0.01 shift NNS NN)
(0.01 left NNS NN)
(0.00998 right NNS NN)
(0.00997 shift NNS NNP)
(0.01 left NNS NNP)
(0.00998 right NNS NNP)
(0.00991 shift NNS NNS)
(0.01 left NNS NNS)
(0.00991 right NNS NNS)
(0.00989 shift NNS POS)
(0.01 left NNS POS)
(0.00995 right NNS POS)
(0.00999 shift NNS PRP)
(0.01 left NNS PRP)
(0.00994 right NNS PRP)
(0.00998 shift NNS RB)
(0.01 left NNS RB)
(0.00997 right NNS RB)
(0.00991 shift NNS RBR)
(0.01 left NNS RBR)
(0.00994 right NNS RBR)
(0.01001 shift NNS RP)
(0.01 left NNS RP)
(0.01002 right NNS RP)
(0.01004 shift NNS -RRB-)
(0.01 left NNS -RRB-)
(0.00999 right NNS -RRB-)
(0.01 shift NNS TO)
(0.01 left NNS TO)
(0.01003 right NNS TO)
(0.00997 shift NNS VB)
(0.01 left NNS VB)
(0.01 right NNS VB)
(0.00992 shift NNS VBD)
(0.01 left NNS VBD)
(0.00995 right NNS VBD)
(0.01001 shift NNS VBG)
(0.01 left NNS VBG)
(0.01001 right NNS VBG)
(0.01002 shift NNS VBN)
(0.01 left NNS VBN)
(0.01007 right NNS VBN)
(0.00994 shift NNS VBP)
(0.01 left NNS VBP)
(0.00995 right NNS VBP)
(0.01009 shift NNS VBZ)
(0.01 left NNS VBZ)
(0.01008 right NNS VBZ)
(0.01007 shift NNS WDT)
(0.01 left NNS WDT)
(0.01003 right NNS WDT)
(0.01 shift NNS WP)
(0.01 left NNS WP)
(0.01005 right NNS WP)
(0.01006 shift NNS WPDOLLARSIGN)
(0.01 left NNS WPDOLLARSIGN)
(0.01001 right NNS WPDOLLARSIGN)
(0.01001 shift NNS WRB)
(0.01 left NNS WRB)
(0.01003 right NNS WRB)
(0.01002 shift NN TO)
(0.01 left NN TO)
(0.01005 right NN TO)
(0.01006 shift NN VB)
(0.01 left NN VB)
(0.01006 right NN VB)
(0.00996 shift NN VBD)
(0.01 left NN VBD)
(0.00999 right NN VBD)
(0.00999 shift NN VBG)
(0.01 left NN VBG)
(0.01001 right NN VBG)
(0.00999 shift NN VBN)
(0.01 left NN VBN)
(0.01 right NN VBN)
(0.01008 shift NN VBP)
(0.01 left NN VBP)
(0.01007 right NN VBP)
(0.00998 shift NN VBZ)
(0.01 left NN VBZ)
(0.01 right NN VBZ)
(0.01006 shift NN WDT)
(0.01 left NN WDT)
(0.01004 right NN WDT)
(0.01001 shift NN WPDOLLARSIGN)
(0.01 left NN WPDOLLARSIGN)
(0.01001 right NN WPDOLLARSIGN)
(0.01002 shift NN WP)
(0.01 left NN WP)
(0.01002 right NN WP)
(0.01004 shift NN WRB)
(0.01 left NN WRB)
(0.01001 right NN WRB)
(0.00998 shift PDT DOLLARSIGN)
(0.01 left PDT DOLLARSIGN)
(0.00999 right PDT DOLLARSIGN)
(0.01003 shift PDT DT)
(0.01 left PDT DT)
(0.01001 right PDT DT)
(0.00996 shift PDT NN)
(0.01 left PDT NN)
(0.00998 right PDT NN)
(0.00998 shift PDT NNS)
(0.01 left PDT NNS)
(0.00998 right PDT NNS)
(0.0101 shift COMMACHAR POS)
(0.01 left COMMACHAR POS)
(0.01005 right COMMACHAR POS)
(0.00999 shift POS DOLLARSIGN)
(0.01 left POS DOLLARSIGN)
(0.01 right POS DOLLARSIGN)
(0.01006 shift COL POS)
(0.01 left COL POS)
(0.01003 right COL POS)
(0.01006 shift POS CD)
(0.01 left POS CD)
(0.01003 right POS CD)
(0.01001 shift POS DT)
(0.01 left POS DT)
(0.01 right POS DT)
(0.01011 shift POS JJ)
(0.01 left POS JJ)
(0.01002 right POS JJ)
(0.01002 shift POS JJS)
(0.01 left POS JJS)
(0.01001 right POS JJS)
(0.00994 shift POS NN)
(0.01 left POS NN)
(0.00993 right POS NN)
(0.00993 shift POS NNP)
(0.01 left POS NNP)
(0.00995 right POS NNP)
(0.00997 shift POS NNS)
(0.01 left POS NNS)
(0.00996 right POS NNS)
(0.00995 shift POS POS)
(0.01 left POS POS)
(0.00998 right POS POS)
(0.01 shift POS RB)
(0.01 left POS RB)
(0.01 right POS RB)
(0.00999 shift POS VB)
(0.01 left POS VB)
(0.01 right POS VB)
(0.00997 shift POS VBD)
(0.01 left POS VBD)
(0.00999 right POS VBD)
(0.01003 shift POS VBG)
(0.01 left POS VBG)
(0.01003 right POS VBG)
(0.01001 shift POS VBN)
(0.01 left POS VBN)
(0.01 right POS VBN)
(0.01 shift DOLLARSIGN PRP)
(0.01 left DOLLARSIGN PRP)
(0.01 right DOLLARSIGN PRP)
(0.01001 shift PRP COMMACHAR)
(0.01 left PRP COMMACHAR)
(0.01 right PRP COMMACHAR)
(0.01001 shift PRPDOLLARSIGN BACKQUOTEBACKQUOTE)
(0.01 left PRPDOLLARSIGN BACKQUOTEBACKQUOTE)
(0.01 right PRPDOLLARSIGN BACKQUOTEBACKQUOTE)
(0.01001 shift BACKQUOTEBACKQUOTE PRP)
(0.01 left BACKQUOTEBACKQUOTE PRP)
(0.01 right BACKQUOTEBACKQUOTE PRP)
(0.01001 shift COMMACHAR PRP)
(0.01 left COMMACHAR PRP)
(0.01 right COMMACHAR PRP)
(0.01002 shift SINGLEQUOTESINGLEQUOTE PRP)
(0.01 left SINGLEQUOTESINGLEQUOTE PRP)
(0.01 right SINGLEQUOTESINGLEQUOTE PRP)
(0.01002 shift PRP BACKQUOTEBACKQUOTE)
(0.01 left PRP BACKQUOTEBACKQUOTE)
(0.01 right PRP BACKQUOTEBACKQUOTE)
(0.01004 shift PRPDOLLARSIGN DOLLARSIGN)
(0.01 left PRPDOLLARSIGN DOLLARSIGN)
(0.01002 right PRPDOLLARSIGN DOLLARSIGN)
(0.01001 shift PRPDOLLARSIGN CD)
(0.01 left PRPDOLLARSIGN CD)
(0.01 right PRPDOLLARSIGN CD)
(0.00997 shift PRP DT)
(0.01 left PRP DT)
(0.00997 right PRP DT)
(0.00995 shift PRP IN)
(0.01 left PRP IN)
(0.01001 right PRP IN)
(0.01 shift PRPDOLLARSIGN JJ)
(0.01 left PRPDOLLARSIGN JJ)
(0.00998 right PRPDOLLARSIGN JJ)
(0.01005 shift PRP JJ)
(0.01 left PRP JJ)
(0.01002 right PRP JJ)
(0.01 shift PRPDOLLARSIGN JJS)
(0.01 left PRPDOLLARSIGN JJS)
(0.01 right PRPDOLLARSIGN JJS)
(0.00997 shift PRP MD)
(0.01 left PRP MD)
(0.00999 right PRP MD)
(0.01 shift PRP NN)
(0.01 left PRP NN)
(0.00999 right PRP NN)
(0.00993 shift PRPDOLLARSIGN NN)
(0.01 left PRPDOLLARSIGN NN)
(0.00995 right PRPDOLLARSIGN NN)
(0.00999 shift PRP NNP)
(0.01 left PRP NNP)
(0.01 right PRP NNP)
(0.01002 shift PRPDOLLARSIGN NNP)
(0.01 left PRPDOLLARSIGN NNP)
(0.01 right PRPDOLLARSIGN NNP)
(0.00999 shift PRP NNS)
(0.01 left PRP NNS)
(0.01 right PRP NNS)
(0.00992 shift PRPDOLLARSIGN NNS)
(0.01 left PRPDOLLARSIGN NNS)
(0.00994 right PRPDOLLARSIGN NNS)
(0.01006 shift PRP POS)
(0.01 left PRP POS)
(0.01003 right PRP POS)
(0.00994 shift PRPDOLLARSIGN POS)
(0.01 left PRPDOLLARSIGN POS)
(0.00997 right PRPDOLLARSIGN POS)
(0.01003 shift PRPDOLLARSIGN RB)
(0.01 left PRPDOLLARSIGN RB)
(0.01001 right PRPDOLLARSIGN RB)
(0.01009 shift PRP RB)
(0.01 left PRP RB)
(0.01 right PRP RB)
(0.01007 shift PRP RBR)
(0.01 left PRP RBR)
(0.01003 right PRP RBR)
(0.01001 shift PRP TO)
(0.01 left PRP TO)
(0.01 right PRP TO)
(0.00995 shift PRP VB)
(0.01 left PRP VB)
(0.00998 right PRP VB)
(0.00993 shift PRP VBD)
(0.01 left PRP VBD)
(0.00997 right PRP VBD)
(0.00997 shift PRP VBN)
(0.01 left PRP VBN)
(0.00997 right PRP VBN)
(0.01005 shift PRPDOLLARSIGN VBN)
(0.01 left PRPDOLLARSIGN VBN)
(0.01002 right PRPDOLLARSIGN VBN)
(0.00997 shift PRP VBP)
(0.01 left PRP VBP)
(0.00999 right PRP VBP)
(0.00994 shift PRP VBZ)
(0.01 left PRP VBZ)
(0.00996 right PRP VBZ)
(0.01 shift BACKQUOTEBACKQUOTE RB)
(0.01 left BACKQUOTEBACKQUOTE RB)
(0.01 right BACKQUOTEBACKQUOTE RB)
(0.01 shift RB BACKQUOTEBACKQUOTE)
(0.01 left RB BACKQUOTEBACKQUOTE)
(0.01 right RB BACKQUOTEBACKQUOTE)
(0.01002 shift COL RB)
(0.01 left COL RB)
(0.01001 right COL RB)
(0.01002 shift DOLLARSIGN RB)
(0.01 left DOLLARSIGN RB)
(0.01 right DOLLARSIGN RB)
(0.01004 shift RB COMMACHAR)
(0.01 left RB COMMACHAR)
(0.00999 right RB COMMACHAR)
(0.01004 shift RB DOLLARSIGN)
(0.01 left RB DOLLARSIGN)
(0.01001 right RB DOLLARSIGN)
(0.01004 shift COMMACHAR RB)
(0.01 left COMMACHAR RB)
(0.01001 right COMMACHAR RB)
(0.00998 shift RB CC)
(0.01 left RB CC)
(0.01002 right RB CC)
(0.01002 shift RB CD)
(0.01 left RB CD)
(0.01012 right RB CD)
(0.01007 shift RB DT)
(0.01 left RB DT)
(0.01009 right RB DT)
(0.01 shift RB IN)
(0.01 left RB IN)
(0.01 right RB IN)
(0.00991 shift RB JJ)
(0.01 left RB JJ)
(0.00992 right RB JJ)
(0.00989 shift RB JJR)
(0.01 left RB JJR)
(0.00991 right RB JJR)
(0.01002 shift RB MD)
(0.01 left RB MD)
(0.00999 right RB MD)
(0.01006 shift RB NN)
(0.01 left RB NN)
(0.01003 right RB NN)
(0.01005 shift RB NNP)
(0.01 left RB NNP)
(0.00998 right RB NNP)
(0.01003 shift RB NNS)
(0.01 left RB NNS)
(0.01001 right RB NNS)
(0.01 shift RB PDT)
(0.01 left RB PDT)
(0.01006 right RB PDT)
(0.01007 shift RB POS)
(0.01 left RB POS)
(0.01003 right RB POS)
(0.01001 shift RB PRPDOLLARSIGN)
(0.01 left RB PRPDOLLARSIGN)
(0.01 right RB PRPDOLLARSIGN)
(0.01005 shift RB PRP)
(0.01 left RB PRP)
(0.00999 right RB PRP)
(0.01002 shift RBR COMMACHAR)
(0.01 left RBR COMMACHAR)
(0.01 right RBR COMMACHAR)
(0.01004 shift COMMACHAR RBR)
(0.01 left COMMACHAR RBR)
(0.01002 right COMMACHAR RBR)
(0.01003 shift RB RB)
(0.01 left RB RB)
(0.01009 right RB RB)
(0.01004 shift RB RBR)
(0.01 left RB RBR)
(0.01008 right RB RBR)
(0.01 shift RBR CC)
(0.01 left RBR CC)
(0.01003 right RBR CC)
(0.01 shift RBR IN)
(0.01 left RBR IN)
(0.01 right RBR IN)
(0.00992 shift RBR JJ)
(0.01 left RBR JJ)
(0.00996 right RBR JJ)
(0.01 shift RBR NN)
(0.01 left RBR NN)
(0.00999 right RBR NN)
(0.01001 shift RBR RB)
(0.01 left RBR RB)
(0.00996 right RBR RB)
(0.01 shift RBR RBR)
(0.01 left RBR RBR)
(0.01004 right RBR RBR)
(0.00999 shift RBR VBD)
(0.01 left RBR VBD)
(0.01 right RBR VBD)
(0.00999 shift RBR VBG)
(0.01 left RBR VBG)
(0.00998 right RBR VBG)
(0.00999 shift RBR VBN)
(0.01 left RBR VBN)
(0.01 right RBR VBN)
(0.00999 shift RBR VBZ)
(0.01 left RBR VBZ)
(0.01 right RBR VBZ)
(0.01003 shift RBS IN)
(0.01 left RBS IN)
(0.01004 right RBS IN)
(0.00992 shift RBS JJ)
(0.01 left RBS JJ)
(0.00994 right RBS JJ)
(0.01 shift RBS NN)
(0.01 left RBS NN)
(0.00999 right RBS NN)
(0.00996 shift RBS RB)
(0.01 left RBS RB)
(0.00997 right RBS RB)
(0.01 shift RB TO)
(0.01 left RB TO)
(0.00999 right RB TO)
(0.01 shift RB UH)
(0.01 left RB UH)
(0.01 right RB UH)
(0.00998 shift RB VB)
(0.01 left RB VB)
(0.00998 right RB VB)
(0.00996 shift RB VBD)
(0.01 left RB VBD)
(0.00994 right RB VBD)
(0.00984 shift RB VBG)
(0.01 left RB VBG)
(0.00988 right RB VBG)
(0.00985 shift RB VBN)
(0.01 left RB VBN)
(0.00991 right RB VBN)
(0.00997 shift RB VBP)
(0.01 left RB VBP)
(0.00999 right RB VBP)
(0.01 shift RB VBZ)
(0.01 left RB VBZ)
(0.00998 right RB VBZ)
(0.00996 shift RB WP)
(0.01 left RB WP)
(0.00998 right RB WP)
(0.01003 shift RB WRB)
(0.01 left RB WRB)
(0.00999 right RB WRB)
(0.01001 shift RP IN)
(0.01 left RP IN)
(0.01 right RP IN)
(0.01 shift RP NN)
(0.01 left RP NN)
(0.01001 right RP NN)
(0.01 shift RP NNS)
(0.01 left RP NNS)
(0.01004 right RP NNS)
(0.01 shift RP RB)
(0.01 left RP RB)
(0.01 right RP RB)
(0.01 shift RP TO)
(0.01 left RP TO)
(0.01 right RP TO)
(0.01 shift RP VBG)
(0.01 left RP VBG)
(0.01 right RP VBG)
(0.01 shift DOLLARSIGN -RRB-)
(0.01 left DOLLARSIGN -RRB-)
(0.01 right DOLLARSIGN -RRB-)
(0.01002 shift PERIODCHAR -RRB-)
(0.01 left PERIODCHAR -RRB-)
(0.01 right PERIODCHAR -RRB-)
(0.00997 shift -RRB- NNP)
(0.01 left -RRB- NNP)
(0.00996 right -RRB- NNP)
(0.01 shift TO COMMACHAR)
(0.01 left TO COMMACHAR)
(0.01 right TO COMMACHAR)
(0.01 shift SINGLEQUOTESINGLEQUOTE TO)
(0.01 left SINGLEQUOTESINGLEQUOTE TO)
(0.01 right SINGLEQUOTESINGLEQUOTE TO)
(0.01001 shift TO BACKQUOTEBACKQUOTE)
(0.01 left TO BACKQUOTEBACKQUOTE)
(0.00999 right TO BACKQUOTEBACKQUOTE)
(0.01002 shift TO HASHSIGN)
(0.01 left TO HASHSIGN)
(0.01 right TO HASHSIGN)
(0.01003 shift TO DOLLARSIGN)
(0.01 left TO DOLLARSIGN)
(0.00997 right TO DOLLARSIGN)
(0.00999 shift TO CC)
(0.01 left TO CC)
(0.01001 right TO CC)
(0.00999 shift TO CD)
(0.01 left TO CD)
(0.00999 right TO CD)
(0.01004 shift TO DT)
(0.01 left TO DT)
(0.01 right TO DT)
(0.01 shift TO IN)
(0.01 left TO IN)
(0.01 right TO IN)
(0.01 shift TO JJ)
(0.01 left TO JJ)
(0.01 right TO JJ)
(0.00997 shift TO MD)
(0.01 left TO MD)
(0.00997 right TO MD)
(0.01002 shift TO NN)
(0.01 left TO NN)
(0.01008 right TO NN)
(0.01 shift TO NNP)
(0.01 left TO NNP)
(0.0101 right TO NNP)
(0.01011 shift TO NNS)
(0.01 left TO NNS)
(0.01012 right TO NNS)
(0.01005 shift TO POS)
(0.01 left TO POS)
(0.01001 right TO POS)
(0.00997 shift TO PRP)
(0.01 left TO PRP)
(0.01003 right TO PRP)
(0.01001 shift TO RB)
(0.01 left TO RB)
(0.00999 right TO RB)
(0.01 shift TO TO)
(0.01 left TO TO)
(0.01 right TO TO)
(0.00978 shift TO VB)
(0.01 left TO VB)
(0.00981 right TO VB)
(0.00999 shift TO VBD)
(0.01 left TO VBD)
(0.01 right TO VBD)
(0.01 shift TO VBG)
(0.01 left TO VBG)
(0.01002 right TO VBG)
(0.01001 shift TO VBN)
(0.01 left TO VBN)
(0.01 right TO VBN)
(0.00999 shift TO VBZ)
(0.01 left TO VBZ)
(0.01 right TO VBZ)
(0.01 shift TO WP)
(0.01 left TO WP)
(0.01 right TO WP)
(0.01 shift TO WRB)
(0.01 left TO WRB)
(0.01 right TO WRB)
(0.01002 shift UH COMMACHAR)
(0.01 left UH COMMACHAR)
(0.01 right UH COMMACHAR)
(0.00999 shift UH VBD)
(0.01 left UH VBD)
(0.01 right UH VBD)
(0.00999 shift UH VBZ)
(0.01 left UH VBZ)
(0.01 right UH VBZ)
(0.01 shift VB DOLLARSIGN)
(0.01 left VB DOLLARSIGN)
(0.01 right VB DOLLARSIGN)
(0.01 shift VB BACKQUOTEBACKQUOTE)
(0.01 left VB BACKQUOTEBACKQUOTE)
(0.01 right VB BACKQUOTEBACKQUOTE)
(0.01 shift VB PERIODCHAR)
(0.01 left VB PERIODCHAR)
(0.01 right VB PERIODCHAR)
(0.0099 shift COMMACHAR VB)
(0.01 left COMMACHAR VB)
(0.00995 right COMMACHAR VB)
(0.00999 shift VB COL)
(0.01 left VB COL)
(0.01001 right VB COL)
(0.00999 shift SINGLEQUOTESINGLEQUOTE VB)
(0.01 left SINGLEQUOTESINGLEQUOTE VB)
(0.01 right SINGLEQUOTESINGLEQUOTE VB)
(0.00997 shift VB SINGLEQUOTESINGLEQUOTE)
(0.01 left VB SINGLEQUOTESINGLEQUOTE)
(0.01003 right VB SINGLEQUOTESINGLEQUOTE)
(0.00997 shift VB COMMACHAR)
(0.01 left VB COMMACHAR)
(0.01003 right VB COMMACHAR)
(0.00995 shift BACKQUOTEBACKQUOTE VB)
(0.01 left BACKQUOTEBACKQUOTE VB)
(0.00998 right BACKQUOTEBACKQUOTE VB)
(0.00998 shift VB CC)
(0.01 left VB CC)
(0.01002 right VB CC)
(0.00998 shift VB CD)
(0.01 left VB CD)
(0.00992 right VB CD)
(0.0099 shift COMMACHAR VBD)
(0.01 left COMMACHAR VBD)
(0.00995 right COMMACHAR VBD)
(0.01001 shift VBD COL)
(0.01 left VBD COL)
(0.01001 right VBD COL)
(0.01001 shift VBD COMMACHAR)
(0.01 left VBD COMMACHAR)
(0.01001 right VBD COMMACHAR)
(0.00999 shift VBD PERIODCHAR)
(0.01 left VBD PERIODCHAR)
(0.01001 right VBD PERIODCHAR)
(0.00998 shift DOLLARSIGN VBD)
(0.01 left DOLLARSIGN VBD)
(0.00998 right DOLLARSIGN VBD)
(0.00998 shift VBD BACKQUOTEBACKQUOTE)
(0.01 left VBD BACKQUOTEBACKQUOTE)
(0.01002 right VBD BACKQUOTEBACKQUOTE)
(0.01002 shift VBD DOLLARSIGN)
(0.01 left VBD DOLLARSIGN)
(0.01 right VBD DOLLARSIGN)
(0.00997 shift COL VBD)
(0.01 left COL VBD)
(0.00999 right COL VBD)
(0.00997 shift VBD SINGLEQUOTESINGLEQUOTE)
(0.01 left VBD SINGLEQUOTESINGLEQUOTE)
(0.01003 right VBD SINGLEQUOTESINGLEQUOTE)
(0.00997 shift SINGLEQUOTESINGLEQUOTE VBD)
(0.01 left SINGLEQUOTESINGLEQUOTE VBD)
(0.00999 right SINGLEQUOTESINGLEQUOTE VBD)
(0.01005 shift BACKQUOTEBACKQUOTE VBD)
(0.01 left BACKQUOTEBACKQUOTE VBD)
(0.01001 right BACKQUOTEBACKQUOTE VBD)
(0.01001 shift VBD CC)
(0.01 left VBD CC)
(0.00999 right VBD CC)
(0.01004 shift VBD CD)
(0.01 left VBD CD)
(0.01001 right VBD CD)
(0.00995 shift VBD DT)
(0.01 left VBD DT)
(0.00996 right VBD DT)
(0.01001 shift VBD EX)
(0.01 left VBD EX)
(0.00999 right VBD EX)
(0.01001 shift VBD FW)
(0.01 left VBD FW)
(0.00999 right VBD FW)
(0.00999 shift VBD IN)
(0.01 left VBD IN)
(0.00995 right VBD IN)
(0.01003 shift VBD JJ)
(0.01 left VBD JJ)
(0.01002 right VBD JJ)
(0.00999 shift VBD JJR)
(0.01 left VBD JJR)
(0.01001 right VBD JJR)
(0.01 shift VBD JJS)
(0.01 left VBD JJS)
(0.01 right VBD JJS)
(0.00997 shift VBD -LRB-)
(0.01 left VBD -LRB-)
(0.01003 right VBD -LRB-)
(0.01003 shift VBD MD)
(0.01 left VBD MD)
(0.00996 right VBD MD)
(0.01003 shift VBD NN)
(0.01 left VBD NN)
(0.01007 right VBD NN)
(0.00999 shift VBD NNP)
(0.01 left VBD NNP)
(0.01003 right VBD NNP)
(0.01004 shift VBD NNS)
(0.01 left VBD NNS)
(0.01008 right VBD NNS)
(0.01003 shift VBD POS)
(0.01 left VBD POS)
(0.01 right VBD POS)
(0.01 shift VBD PRPDOLLARSIGN)
(0.01 left VBD PRPDOLLARSIGN)
(0.01 right VBD PRPDOLLARSIGN)
(0.00996 shift VBD PRP)
(0.01 left VBD PRP)
(0.01004 right VBD PRP)
(0.00997 shift VBD RB)
(0.01 left VBD RB)
(0.01003 right VBD RB)
(0.00999 shift VBD RBR)
(0.01 left VBD RBR)
(0.01001 right VBD RBR)
(0.00997 shift VBD RBS)
(0.01 left VBD RBS)
(0.01003 right VBD RBS)
(0.01 shift VBD RP)
(0.01 left VBD RP)
(0.01 right VBD RP)
(0.00999 shift VBD -RRB-)
(0.01 left VBD -RRB-)
(0.01001 right VBD -RRB-)
(0.01 shift VB DT)
(0.01 left VB DT)
(0.01 right VB DT)
(0.00999 shift VBD TO)
(0.01 left VBD TO)
(0.01001 right VBD TO)
(0.01005 shift VBD VB)
(0.01 left VBD VB)
(0.00999 right VBD VB)
(0.00999 shift VBD VBD)
(0.01 left VBD VBD)
(0.00995 right VBD VBD)
(0.01001 shift VBD VBG)
(0.01 left VBD VBG)
(0.00999 right VBD VBG)
(0.01003 shift VBD VBN)
(0.01 left VBD VBN)
(0.01 right VBD VBN)
(0.01001 shift VBD VBP)
(0.01 left VBD VBP)
(0.00998 right VBD VBP)
(0.00999 shift VBD VBZ)
(0.01 left VBD VBZ)
(0.00994 right VBD VBZ)
(0.01001 shift VBD WDT)
(0.01 left VBD WDT)
(0.00999 right VBD WDT)
(0.01001 shift VBD WP)
(0.01 left VBD WP)
(0.00999 right VBD WP)
(0.01001 shift VBD WRB)
(0.01 left VBD WRB)
(0.01001 right VBD WRB)
(0.01 shift VBG COMMACHAR)
(0.01 left VBG COMMACHAR)
(0.01 right VBG COMMACHAR)
(0.01 shift VBG COL)
(0.01 left VBG COL)
(0.01 right VBG COL)
(0.00999 shift VBG SINGLEQUOTESINGLEQUOTE)
(0.01 left VBG SINGLEQUOTESINGLEQUOTE)
(0.01001 right VBG SINGLEQUOTESINGLEQUOTE)
(0.00998 shift VBG BACKQUOTEBACKQUOTE)
(0.01 left VBG BACKQUOTEBACKQUOTE)
(0.01002 right VBG BACKQUOTEBACKQUOTE)
(0.01002 shift DOLLARSIGN VBG)
(0.01 left DOLLARSIGN VBG)
(0.01 right DOLLARSIGN VBG)
(0.01003 shift VBG DOLLARSIGN)
(0.01 left VBG DOLLARSIGN)
(0.01001 right VBG DOLLARSIGN)
(0.01005 shift COMMACHAR VBG)
(0.01 left COMMACHAR VBG)
(0.01002 right COMMACHAR VBG)
(0.00994 shift COL VBG)
(0.01 left COL VBG)
(0.00997 right COL VBG)
(0.01 shift VBG CC)
(0.01 left VBG CC)
(0.01 right VBG CC)
(0.01002 shift VBG CD)
(0.01 left VBG CD)
(0.01 right VBG CD)
(0.01 shift VBG DT)
(0.01 left VBG DT)
(0.01 right VBG DT)
(0.01002 shift VBG IN)
(0.01 left VBG IN)
(0.01 right VBG IN)
(0.01 shift VBG JJ)
(0.01 left VBG JJ)
(0.00998 right VBG JJ)
(0.01004 shift VBG JJR)
(0.01 left VBG JJR)
(0.00999 right VBG JJR)
(0.01 shift VBG JJS)
(0.01 left VBG JJS)
(0.01 right VBG JJS)
(0.00998 shift VBG MD)
(0.01 left VBG MD)
(0.00998 right VBG MD)
(0.01 shift VBG NN)
(0.01 left VBG NN)
(0.01002 right VBG NN)
(0.01002 shift VBG NNP)
(0.01 left VBG NNP)
(0.01002 right VBG NNP)
(0.00999 shift VBG NNS)
(0.01 left VBG NNS)
(0.01004 right VBG NNS)
(0.01 shift VBG POS)
(0.01 left VBG POS)
(0.01 right VBG POS)
(0.00997 shift VBG PRP)
(0.01 left VBG PRP)
(0.01003 right VBG PRP)
(0.00999 shift VBG RB)
(0.01 left VBG RB)
(0.00999 right VBG RB)
(0.01 shift VBG RBR)
(0.01 left VBG RBR)
(0.01 right VBG RBR)
(0.00995 shift VBG RP)
(0.01 left VBG RP)
(0.00999 right VBG RP)
(0.01 shift VBG TO)
(0.01 left VBG TO)
(0.01 right VBG TO)
(0.01007 shift VBG VB)
(0.01 left VBG VB)
(0.01004 right VBG VB)
(0.00998 shift VBG VBD)
(0.01 left VBG VBD)
(0.00998 right VBG VBD)
(0.01002 shift VBG VBG)
(0.01 left VBG VBG)
(0.01 right VBG VBG)
(0.01004 shift VBG VBN)
(0.01 left VBG VBN)
(0.01 right VBG VBN)
(0.00996 shift VBG VBP)
(0.01 left VBG VBP)
(0.00998 right VBG VBP)
(0.01 shift VBG VBZ)
(0.01 left VBG VBZ)
(0.00999 right VBG VBZ)
(0.01 shift VB IN)
(0.01 left VB IN)
(0.01 right VB IN)
(0.01 shift VB JJ)
(0.01 left VB JJ)
(0.01 right VB JJ)
(0.01 shift VB JJR)
(0.01 left VB JJR)
(0.01 right VB JJR)
(0.00999 shift VB JJS)
(0.01 left VB JJS)
(0.01001 right VB JJS)
(0.00999 shift VB -LRB-)
(0.01 left VB -LRB-)
(0.01001 right VB -LRB-)
(0.00995 shift VB MD)
(0.01 left VB MD)
(0.00996 right VB MD)
(0.01 shift VBN BACKQUOTEBACKQUOTE)
(0.01 left VBN BACKQUOTEBACKQUOTE)
(0.01 right VBN BACKQUOTEBACKQUOTE)
(0.01 shift VBN HASHSIGN)
(0.01 left VBN HASHSIGN)
(0.01 right VBN HASHSIGN)
(0.01 shift VBN DOLLARSIGN)
(0.01 left VBN DOLLARSIGN)
(0.01001 right VBN DOLLARSIGN)
(0.01 shift VBN COL)
(0.01 left VBN COL)
(0.01 right VBN COL)
(0.01 shift VBN SINGLEQUOTESINGLEQUOTE)
(0.01 left VBN SINGLEQUOTESINGLEQUOTE)
(0.01 right VBN SINGLEQUOTESINGLEQUOTE)
(0.00999 shift COL VBN)
(0.01 left COL VBN)
(0.00998 right COL VBN)
(0.00998 shift BACKQUOTEBACKQUOTE VBN)
(0.01 left BACKQUOTEBACKQUOTE VBN)
(0.00999 right BACKQUOTEBACKQUOTE VBN)
(0.00998 shift VBN COMMACHAR)
(0.01 left VBN COMMACHAR)
(0.01002 right VBN COMMACHAR)
(0.01003 shift DOLLARSIGN VBN)
(0.01 left DOLLARSIGN VBN)
(0.01002 right DOLLARSIGN VBN)
(0.00996 shift COMMACHAR VBN)
(0.01 left COMMACHAR VBN)
(0.00998 right COMMACHAR VBN)
(0.00999 shift VBN CC)
(0.01 left VBN CC)
(0.01001 right VBN CC)
(0.01003 shift VBN CD)
(0.01 left VBN CD)
(0.01002 right VBN CD)
(0.01002 shift VBN IN)
(0.01 left VBN IN)
(0.01 right VBN IN)
(0.01002 shift VBN JJ)
(0.01 left VBN JJ)
(0.01003 right VBN JJ)
(0.01 shift VBN JJR)
(0.01 left VBN JJR)
(0.01 right VBN JJR)
(0.01001 shift VBN JJS)
(0.01 left VBN JJS)
(0.00999 right VBN JJS)
(0.00996 shift VBN MD)
(0.01 left VBN MD)
(0.00998 right VBN MD)
(0.01004 shift VB NN)
(0.01 left VB NN)
(0.01008 right VB NN)
(0.01 shift VBN NN)
(0.01 left VBN NN)
(0.00997 right VBN NN)
(0.00997 shift VBN NNP)
(0.01 left VBN NNP)
(0.01002 right VBN NNP)
(0.00992 shift VBN NNS)
(0.01 left VBN NNS)
(0.00996 right VBN NNS)
(0.01 shift VB NNP)
(0.01 left VB NNP)
(0.01007 right VB NNP)
(0.01006 shift VB NNS)
(0.01 left VB NNS)
(0.01011 right VB NNS)
(0.01004 shift VBN POS)
(0.01 left VBN POS)
(0.01 right VBN POS)
(0.01 shift VBN RB)
(0.01 left VBN RB)
(0.01002 right VBN RB)
(0.01002 shift VBN RBR)
(0.01 left VBN RBR)
(0.01 right VBN RBR)
(0.01 shift VBN RBS)
(0.01 left VBN RBS)
(0.01 right VBN RBS)
(0.00999 shift VBN RP)
(0.01 left VBN RP)
(0.01003 right VBN RP)
(0.00999 shift VBN -RRB-)
(0.01 left VBN -RRB-)
(0.01001 right VBN -RRB-)
(0.01 shift VBN TO)
(0.01 left VBN TO)
(0.01 right VBN TO)
(0.01009 shift VBN VB)
(0.01 left VBN VB)
(0.01003 right VBN VB)
(0.01003 shift VBN VBD)
(0.01 left VBN VBD)
(0.01001 right VBN VBD)
(0.01003 shift VBN VBG)
(0.01 left VBN VBG)
(0.01 right VBN VBG)
(0.01005 shift VBN VBN)
(0.01 left VBN VBN)
(0.01002 right VBN VBN)
(0.00992 shift VBN VBP)
(0.01 left VBN VBP)
(0.00995 right VBN VBP)
(0.00994 shift VBN VBZ)
(0.01 left VBN VBZ)
(0.00994 right VBN VBZ)
(0.01 shift VBN WP)
(0.01 left VBN WP)
(0.01 right VBN WP)
(0.01 shift VBN WRB)
(0.01 left VBN WRB)
(0.01 right VBN WRB)
(0.01 shift VBP BACKQUOTEBACKQUOTE)
(0.01 left VBP BACKQUOTEBACKQUOTE)
(0.01 right VBP BACKQUOTEBACKQUOTE)
(0.01 shift VBP DOLLARSIGN)
(0.01 left VBP DOLLARSIGN)
(0.01 right VBP DOLLARSIGN)
(0.01 shift VBP COL)
(0.01 left VBP COL)
(0.01 right VBP COL)
(0.01001 shift BACKQUOTEBACKQUOTE VBP)
(0.01 left BACKQUOTEBACKQUOTE VBP)
(0.01 right BACKQUOTEBACKQUOTE VBP)
(0.00999 shift VBP COMMACHAR)
(0.01 left VBP COMMACHAR)
(0.01001 right VBP COMMACHAR)
(0.00999 shift SINGLEQUOTESINGLEQUOTE VBP)
(0.01 left SINGLEQUOTESINGLEQUOTE VBP)
(0.01 right SINGLEQUOTESINGLEQUOTE VBP)
(0.00997 shift VBP SINGLEQUOTESINGLEQUOTE)
(0.01 left VBP SINGLEQUOTESINGLEQUOTE)
(0.01003 right VBP SINGLEQUOTESINGLEQUOTE)
(0.00996 shift COMMACHAR VBP)
(0.01 left COMMACHAR VBP)
(0.00998 right COMMACHAR VBP)
(0.00995 shift COL VBP)
(0.01 left COL VBP)
(0.00998 right COL VBP)
(0.01006 shift DOLLARSIGN VBP)
(0.01 left DOLLARSIGN VBP)
(0.01003 right DOLLARSIGN VBP)
(0.01 shift VBP CC)
(0.01 left VBP CC)
(0.01002 right VBP CC)
(0.01 shift VBP CD)
(0.01 left VBP CD)
(0.01 right VBP CD)
(0.00999 shift VBP DT)
(0.01 left VBP DT)
(0.01001 right VBP DT)
(0.01001 shift VBP IN)
(0.01 left VBP IN)
(0.00999 right VBP IN)
(0.01002 shift VBP JJ)
(0.01 left VBP JJ)
(0.01 right VBP JJ)
(0.01003 shift VBP JJR)
(0.01 left VBP JJR)
(0.01 right VBP JJR)
(0.01001 shift VBP MD)
(0.01 left VBP MD)
(0.00999 right VBP MD)
(0.01 shift VBP NN)
(0.01 left VBP NN)
(0.01002 right VBP NN)
(0.01 shift VBP NNP)
(0.01 left VBP NNP)
(0.01 right VBP NNP)
(0.01008 shift VBP NNS)
(0.01 left VBP NNS)
(0.01006 right VBP NNS)
(0.01005 shift VB POS)
(0.01 left VB POS)
(0.01 right VB POS)
(0.01 shift VBP PDT)
(0.01 left VBP PDT)
(0.01 right VBP PDT)
(0.00998 shift VBP PRP)
(0.01 left VBP PRP)
(0.01002 right VBP PRP)
(0.00997 shift VBP RB)
(0.01 left VBP RB)
(0.01005 right VBP RB)
(0.01 shift VBP RBR)
(0.01 left VBP RBR)
(0.01 right VBP RBR)
(0.01 shift VBP RP)
(0.01 left VBP RP)
(0.01 right VBP RP)
(0.01001 shift VB PRPDOLLARSIGN)
(0.01 left VB PRPDOLLARSIGN)
(0.00999 right VB PRPDOLLARSIGN)
(0.00997 shift VB PRP)
(0.01 left VB PRP)
(0.01003 right VB PRP)
(0.01001 shift VBP TO)
(0.01 left VBP TO)
(0.00999 right VBP TO)
(0.01004 shift VBP VB)
(0.01 left VBP VB)
(0.01003 right VBP VB)
(0.01 shift VBP VBD)
(0.01 left VBP VBD)
(0.00998 right VBP VBD)
(0.01001 shift VBP VBG)
(0.01 left VBP VBG)
(0.01001 right VBP VBG)
(0.01002 shift VBP VBN)
(0.01 left VBP VBN)
(0.01002 right VBP VBN)
(0.00995 shift VBP VBP)
(0.01 left VBP VBP)
(0.00996 right VBP VBP)
(0.00995 shift VBP VBZ)
(0.01 left VBP VBZ)
(0.00995 right VBP VBZ)
(0.01002 shift VBP WDT)
(0.01 left VBP WDT)
(0.00998 right VBP WDT)
(0.01 shift VBP WP)
(0.01 left VBP WP)
(0.01 right VBP WP)
(0.01 shift VBP WRB)
(0.01 left VBP WRB)
(0.01002 right VBP WRB)
(0.00999 shift VB RB)
(0.01 left VB RB)
(0.01001 right VB RB)
(0.01002 shift VB RBR)
(0.01 left VB RBR)
(0.00998 right VB RBR)
(0.01 shift VB RP)
(0.01 left VB RP)
(0.01 right VB RP)
(0.00999 shift VB -RRB-)
(0.01 left VB -RRB-)
(0.01001 right VB -RRB-)
(0.01 shift VB TO)
(0.01 left VB TO)
(0.01 right VB TO)
(0.01003 shift VB VB)
(0.01 left VB VB)
(0.01001 right VB VB)
(0.01006 shift VB VBD)
(0.01 left VB VBD)
(0.00998 right VB VBD)
(0.01001 shift VB VBG)
(0.01 left VB VBG)
(0.00999 right VB VBG)
(0.01 shift VB VBN)
(0.01 left VB VBN)
(0.00994 right VB VBN)
(0.01003 shift VB VBP)
(0.01 left VB VBP)
(0.01 right VB VBP)
(0.00997 shift VB VBZ)
(0.01 left VB VBZ)
(0.00997 right VB VBZ)
(0.01002 shift VB WDT)
(0.01 left VB WDT)
(0.00998 right VB WDT)
(0.01 shift VB WP)
(0.01 left VB WP)
(0.01 right VB WP)
(0.01001 shift VB WRB)
(0.01 left VB WRB)
(0.00999 right VB WRB)
(0.01 shift VBZ COMMACHAR)
(0.01 left VBZ COMMACHAR)
(0.01 right VBZ COMMACHAR)
(0.01 shift VBZ PERIODCHAR)
(0.01 left VBZ PERIODCHAR)
(0.01 right VBZ PERIODCHAR)
(0.00999 shift VBZ BACKQUOTEBACKQUOTE)
(0.01 left VBZ BACKQUOTEBACKQUOTE)
(0.01001 right VBZ BACKQUOTEBACKQUOTE)
(0.01001 shift SINGLEQUOTESINGLEQUOTE VBZ)
(0.01 left SINGLEQUOTESINGLEQUOTE VBZ)
(0.01 right SINGLEQUOTESINGLEQUOTE VBZ)
(0.01001 shift VBZ COL)
(0.01 left VBZ COL)
(0.00999 right VBZ COL)
(0.01002 shift BACKQUOTEBACKQUOTE VBZ)
(0.01 left BACKQUOTEBACKQUOTE VBZ)
(0.01 right BACKQUOTEBACKQUOTE VBZ)
(0.00998 shift VBZ SINGLEQUOTESINGLEQUOTE)
(0.01 left VBZ SINGLEQUOTESINGLEQUOTE)
(0.01002 right VBZ SINGLEQUOTESINGLEQUOTE)
(0.01003 shift VBZ DOLLARSIGN)
(0.01 left VBZ DOLLARSIGN)
(0.01 right VBZ DOLLARSIGN)
(0.00996 shift COL VBZ)
(0.01 left COL VBZ)
(0.00998 right COL VBZ)
(0.00992 shift COMMACHAR VBZ)
(0.01 left COMMACHAR VBZ)
(0.00996 right COMMACHAR VBZ)
(0.00999 shift VBZ CC)
(0.01 left VBZ CC)
(0.01001 right VBZ CC)
(0.01003 shift VBZ CD)
(0.01 left VBZ CD)
(0.00997 right VBZ CD)
(0.00999 shift VBZ DT)
(0.01 left VBZ DT)
(0.01001 right VBZ DT)
(0.00998 shift VBZ IN)
(0.01 left VBZ IN)
(0.00996 right VBZ IN)
(0.01001 shift VBZ JJ)
(0.01 left VBZ JJ)
(0.01004 right VBZ JJ)
(0.01001 shift VBZ JJR)
(0.01 left VBZ JJR)
(0.00999 right VBZ JJR)
(0.01001 shift VBZ JJS)
(0.01 left VBZ JJS)
(0.00999 right VBZ JJS)
(0.01 shift VBZ MD)
(0.01 left VBZ MD)
(0.01 right VBZ MD)
(0.01004 shift VBZ NN)
(0.01 left VBZ NN)
(0.01005 right VBZ NN)
(0.01 shift VBZ NNP)
(0.01 left VBZ NNP)
(0.01002 right VBZ NNP)
(0.01005 shift VBZ NNS)
(0.01 left VBZ NNS)
(0.01005 right VBZ NNS)
(0.01002 shift VBZ POS)
(0.01 left VBZ POS)
(0.01 right VBZ POS)
(0.01 shift VBZ PRPDOLLARSIGN)
(0.01 left VBZ PRPDOLLARSIGN)
(0.01 right VBZ PRPDOLLARSIGN)
(0.00999 shift VBZ PRP)
(0.01 left VBZ PRP)
(0.01001 right VBZ PRP)
(0.00997 shift VBZ RB)
(0.01 left VBZ RB)
(0.01005 right VBZ RB)
(0.00999 shift VBZ RBR)
(0.01 left VBZ RBR)
(0.01001 right VBZ RBR)
(0.00999 shift VBZ RP)
(0.01 left VBZ RP)
(0.01001 right VBZ RP)
(0.01 shift VBZ TO)
(0.01 left VBZ TO)
(0.01002 right VBZ TO)
(0.01001 shift VBZ VB)
(0.01 left VBZ VB)
(0.01 right VBZ VB)
(0.01 shift VBZ VBD)
(0.01 left VBZ VBD)
(0.00998 right VBZ VBD)
(0.01 shift VBZ VBG)
(0.01 left VBZ VBG)
(0.01 right VBZ VBG)
(0.01003 shift VBZ VBN)
(0.01 left VBZ VBN)
(0.01 right VBZ VBN)
(0.01 shift VBZ VBP)
(0.01 left VBZ VBP)
(0.00999 right VBZ VBP)
(0.00996 shift VBZ VBZ)
(0.01 left VBZ VBZ)
(0.00995 right VBZ VBZ)
(0.01001 shift VBZ WP)
(0.01 left VBZ WP)
(0.00999 right VBZ WP)
(0.00999 shift VBZ WRB)
(0.01 left VBZ WRB)
(0.01001 right VBZ WRB)
(0.00999 shift WDT COMMACHAR)
(0.01 left WDT COMMACHAR)
(0.01001 right WDT COMMACHAR)
(0.01002 shift WDT CC)
(0.01 left WDT CC)
(0.00998 right WDT CC)
(0.01 shift WDT DT)
(0.01 left WDT DT)
(0.01 right WDT DT)
(0.01002 shift WDT IN)
(0.01 left WDT IN)
(0.00998 right WDT IN)
(0.01004 shift WDT MD)
(0.01 left WDT MD)
(0.01003 right WDT MD)
(0.00998 shift WDT NN)
(0.01 left WDT NN)
(0.01005 right WDT NN)
(0.01 shift WDT NNP)
(0.01 left WDT NNP)
(0.01 right WDT NNP)
(0.01002 shift WDT NNS)
(0.01 left WDT NNS)
(0.01002 right WDT NNS)
(0.01002 shift WDT PRP)
(0.01 left WDT PRP)
(0.00998 right WDT PRP)
(0.01003 shift WDT RB)
(0.01 left WDT RB)
(0.00997 right WDT RB)
(0.01 shift WDT -RRB-)
(0.01 left WDT -RRB-)
(0.01 right WDT -RRB-)
(0.01009 shift WDT VBD)
(0.01 left WDT VBD)
(0.01009 right WDT VBD)
(0.01002 shift WDT VBP)
(0.01 left WDT VBP)
(0.01002 right WDT VBP)
(0.01006 shift WDT VBZ)
(0.01 left WDT VBZ)
(0.01007 right WDT VBZ)
(0.0099 shift WDT WDT)
(0.01 left WDT WDT)
(0.00995 right WDT WDT)
(0.00991 shift WDT WRB)
(0.01 left WDT WRB)
(0.00996 right WDT WRB)
(0.01 shift WP COMMACHAR)
(0.01 left WP COMMACHAR)
(0.01 right WP COMMACHAR)
(0.00992 shift COMMACHAR WPDOLLARSIGN)
(0.01 left COMMACHAR WPDOLLARSIGN)
(0.00996 right COMMACHAR WPDOLLARSIGN)
(0.00999 shift WPDOLLARSIGN CD)
(0.01 left WPDOLLARSIGN CD)
(0.01001 right WPDOLLARSIGN CD)
(0.01 shift WPDOLLARSIGN IN)
(0.01 left WPDOLLARSIGN IN)
(0.01 right WPDOLLARSIGN IN)
(0.00998 shift WPDOLLARSIGN JJS)
(0.01 left WPDOLLARSIGN JJS)
(0.01002 right WPDOLLARSIGN JJS)
(0.01 shift WP LS)
(0.01 left WP LS)
(0.01 right WP LS)
(0.01001 shift WP MD)
(0.01 left WP MD)
(0.01002 right WP MD)
(0.01003 shift WPDOLLARSIGN MD)
(0.01 left WPDOLLARSIGN MD)
(0.01 right WPDOLLARSIGN MD)
(0.00998 shift WPDOLLARSIGN NN)
(0.01 left WPDOLLARSIGN NN)
(0.01005 right WPDOLLARSIGN NN)
(0.01003 shift WP NN)
(0.01 left WP NN)
(0.01002 right WP NN)
(0.01 shift WP NNP)
(0.01 left WP NNP)
(0.01 right WP NNP)
(0.00999 shift WPDOLLARSIGN NNS)
(0.01 left WPDOLLARSIGN NNS)
(0.01004 right WPDOLLARSIGN NNS)
(0.01002 shift WP NNS)
(0.01 left WP NNS)
(0.00998 right WP NNS)
(0.01 shift WP PRP)
(0.01 left WP PRP)
(0.01 right WP PRP)
(0.01 shift WP RB)
(0.01 left WP RB)
(0.01 right WP RB)
(0.01 shift WP TO)
(0.01 left WP TO)
(0.01 right WP TO)
(0.01 shift WPDOLLARSIGN TO)
(0.01 left WPDOLLARSIGN TO)
(0.01 right WPDOLLARSIGN TO)
(0.01 shift WPDOLLARSIGN VB)
(0.01 left WPDOLLARSIGN VB)
(0.01 right WPDOLLARSIGN VB)
(0.01002 shift WPDOLLARSIGN VBD)
(0.01 left WPDOLLARSIGN VBD)
(0.01001 right WPDOLLARSIGN VBD)
(0.01002 shift WP VBD)
(0.01 left WP VBD)
(0.01006 right WP VBD)
(0.01 shift WP VBP)
(0.01 left WP VBP)
(0.01004 right WP VBP)
(0.01007 shift WPDOLLARSIGN VBP)
(0.01 left WPDOLLARSIGN VBP)
(0.01 right WPDOLLARSIGN VBP)
(0.00999 shift WP VBZ)
(0.01 left WP VBZ)
(0.01002 right WP VBZ)
(0.01004 shift WPDOLLARSIGN VBZ)
(0.01 left WPDOLLARSIGN VBZ)
(0.01001 right WPDOLLARSIGN VBZ)
(0.01 shift WRB SINGLEQUOTESINGLEQUOTE)
(0.01 left WRB SINGLEQUOTESINGLEQUOTE)
(0.01 right WRB SINGLEQUOTESINGLEQUOTE)
(0.01002 shift WRB COMMACHAR)
(0.01 left WRB COMMACHAR)
(0.00998 right WRB COMMACHAR)
(0.01004 shift BACKQUOTEBACKQUOTE WRB)
(0.01 left BACKQUOTEBACKQUOTE WRB)
(0.01 right BACKQUOTEBACKQUOTE WRB)
(0.00994 shift COMMACHAR WRB)
(0.01 left COMMACHAR WRB)
(0.00997 right COMMACHAR WRB)
(0.00986 shift WRB JJ)
(0.01 left WRB JJ)
(0.01 right WRB JJ)
(0.01 shift WRB MD)
(0.01 left WRB MD)
(0.01002 right WRB MD)
(0.01003 shift WRB NN)
(0.01 left WRB NN)
(0.00999 right WRB NN)
(0.01002 shift WRB NNP)
(0.01 left WRB NNP)
(0.00998 right WRB NNP)
(0.01003 shift WRB NNS)
(0.01 left WRB NNS)
(0.00996 right WRB NNS)
(0.01001 shift WRB POS)
(0.01 left WRB POS)
(0.01 right WRB POS)
(0.01001 shift WRB PRP)
(0.01 left WRB PRP)
(0.00999 right WRB PRP)
(0.00988 shift WRB RB)
(0.01 left WRB RB)
(0.00998 right WRB RB)
(0.01 shift WRB VB)
(0.01 left WRB VB)
(0.00998 right WRB VB)
(0.01008 shift WRB VBD)
(0.01 left WRB VBD)
(0.01008 right WRB VBD)
(0.00999 shift WRB VBN)
(0.01 left WRB VBN)
(0.01001 right WRB VBN)
(0.01006 shift WRB VBP)
(0.01 left WRB VBP)
(0.01004 right WRB VBP)
(0.01006 shift WRB VBZ)
(0.01 left WRB VBZ)
(0.01008 right WRB VBZ)
))

(conditional 'leftpos
:conditions '((Selected (state 0) (operator none))
(stacktop (idx (i)))
(stack (idx (i)) (id (s1id)))
(stack (idx (i -1)) (id (s2id)))
(sentence (id (s1id)) (word (w1)) (tag (t1)))
(sentence (id (s2id)) (word (w2)) (tag (t2))))
:actions '((Selected (state 0) (operator (a))))
:FUNCTION-VARIABLE-NAMES '(a t2)
:function '(
(0.01 shift BACKQUOTEBACKQUOTE)
(0.01 left BACKQUOTEBACKQUOTE)
(0.00986 right BACKQUOTEBACKQUOTE)
(0.01001 shift COMMACHAR)
(0.01 left COMMACHAR)
(0.00985 right COMMACHAR)
(0.00999 shift PERIODCHAR)
(0.01 left PERIODCHAR)
(0.00995 right PERIODCHAR)
(0.01001 shift COL)
(0.01 left COL)
(0.00986 right COL)
(0.00998 shift SINGLEQUOTESINGLEQUOTE)
(0.01 left SINGLEQUOTESINGLEQUOTE)
(0.00991 right SINGLEQUOTESINGLEQUOTE)
(0.00997 shift HASHSIGN)
(0.01 left HASHSIGN)
(0.00994 right HASHSIGN)
(0.00996 shift DOLLARSIGN)
(0.01 left DOLLARSIGN)
(0.01 right DOLLARSIGN)
(0.01 shift CC)
(0.01 left CC)
(0.0099 right CC)
(0.00996 shift CD)
(0.01 left CD)
(0.00996 right CD)
(0.00996 shift DT)
(0.01 left DT)
(0.00993 right DT)
(0.00994 shift EX)
(0.01 left EX)
(0.00997 right EX)
(0.01009 shift IN)
(0.01 left IN)
(0.01011 right IN)
(0.00998 shift JJ)
(0.01 left JJ)
(0.01 right JJ)
(0.00997 shift JJR)
(0.01 left JJR)
(0.00995 right JJR)
(0.00995 shift JJS)
(0.01 left JJS)
(0.00998 right JJS)
(0.00995 shift -LRB-)
(0.01 left -LRB-)
(0.00987 right -LRB-)
(0.00999 shift LS)
(0.01 left LS)
(0.00998 right LS)
(0.0103 shift LW)
(0.01 left LW)
(0.01004 right LW)
(0.01004 shift MD)
(0.01 left MD)
(0.01007 right MD)
(0.00999 shift NN)
(0.01 left NN)
(0.01 right NN)
(0.00996 shift NNP)
(0.01 left NNP)
(0.00999 right NNP)
(0.01 shift NNPS)
(0.01 left NNPS)
(0.01 right NNPS)
(0.00998 shift NNS)
(0.01 left NNS)
(0.00999 right NNS)
(0.00993 shift PDT)
(0.01 left PDT)
(0.00995 right PDT)
(0.00999 shift POS)
(0.01 left POS)
(0.00991 right POS)
(0.00998 shift PRPDOLLARSIGN)
(0.01 left PRPDOLLARSIGN)
(0.00991 right PRPDOLLARSIGN)
(0.00993 shift PRP)
(0.01 left PRP)
(0.00989 right PRP)
(0.00993 shift RB)
(0.01 left RB)
(0.00996 right RB)
(0.00988 shift RBR)
(0.01 left RBR)
(0.00992 right RBR)
(0.0099 shift RBS)
(0.01 left RBS)
(0.00992 right RBS)
(0.01004 shift RP)
(0.01 left RP)
(0.01005 right RP)
(0.00997 shift -RRB-)
(0.01 left -RRB-)
(0.00996 right -RRB-)
(0.01003 shift TO)
(0.01 left TO)
(0.01007 right TO)
(0.01 shift UH)
(0.01 left UH)
(0.00999 right UH)
(0.01009 shift VB)
(0.01 left VB)
(0.01012 right VB)
(0.0101 shift VBD)
(0.01 left VBD)
(0.01014 right VBD)
(0.01005 shift VBG)
(0.01 left VBG)
(0.01007 right VBG)
(0.01003 shift VBN)
(0.01 left VBN)
(0.01006 right VBN)
(0.0101 shift VBP)
(0.01 left VBP)
(0.01012 right VBP)
(0.01011 shift VBZ)
(0.01 left VBZ)
(0.01012 right VBZ)
(0.01012 shift WDT)
(0.01 left WDT)
(0.01009 right WDT)
(0.0101 shift WPDOLLARSIGN)
(0.01 left WPDOLLARSIGN)
(0.01016 right WPDOLLARSIGN)
(0.01014 shift WP)
(0.01 left WP)
(0.01011 right WP)
(0.0101 shift WRB)
(0.01 left WRB)
(0.01007 right WRB)
))

(conditional 'rightpos
:conditions '((Selected (state 0) (operator none))
(stacktop (idx (i)))
(stack (idx (i)) (id (s1id)))
(stack (idx (i -1)) (id (s2id)))
(sentence (id (s1id)) (word (w1)) (tag (t1)))
(sentence (id (s2id)) (word (w2)) (tag (t2))))
:actions '((Selected (state 0) (operator (a))))
:FUNCTION-VARIABLE-NAMES '(a t1)
:function '(
(0.01 shift PERIODCHAR)
(0.01 left PERIODCHAR)
(0.01013 right PERIODCHAR)
(0.0101 shift COMMACHAR)
(0.01 left COMMACHAR)
(0.01014 right COMMACHAR)
(0.01001 shift HASHSIGN)
(0.01 left HASHSIGN)
(0.01001 right HASHSIGN)
(0.00997 shift DOLLARSIGN)
(0.01 left DOLLARSIGN)
(0.00996 right DOLLARSIGN)
(0.01003 shift SINGLEQUOTESINGLEQUOTE)
(0.01 left SINGLEQUOTESINGLEQUOTE)
(0.01014 right SINGLEQUOTESINGLEQUOTE)
(0.01009 shift BACKQUOTEBACKQUOTE)
(0.01 left BACKQUOTEBACKQUOTE)
(0.01009 right BACKQUOTEBACKQUOTE)
(0.01009 shift COL)
(0.01 left COL)
(0.0101 right COL)
(0.01009 shift CC)
(0.01 left CC)
(0.01014 right CC)
(0.01 shift CD)
(0.01 left CD)
(0.00998 right CD)
(0.01006 shift DT)
(0.01 left DT)
(0.00998 right DT)
(0.01006 shift EX)
(0.01 left EX)
(0.00997 right EX)
(0.01001 shift FW)
(0.01 left FW)
(0.00999 right FW)
(0.01003 shift IN)
(0.01 left IN)
(0.01004 right IN)
(0.01 shift JJ)
(0.01 left JJ)
(0.00994 right JJ)
(0.00997 shift JJR)
(0.01 left JJR)
(0.00995 right JJR)
(0.00998 shift JJS)
(0.01 left JJS)
(0.00998 right JJS)
(0.01008 shift -LRB-)
(0.01 left -LRB-)
(0.01003 right -LRB-)
(0.01002 shift LS)
(0.01 left LS)
(0.01 right LS)
(0.00991 shift MD)
(0.01 left MD)
(0.00988 right MD)
(0.00995 shift NN)
(0.01 left NN)
(0.00989 right NN)
(0.01 shift NNP)
(0.01 left NNP)
(0.0099 right NNP)
(0.01001 shift NNPS)
(0.01 left NNPS)
(0.01 right NNPS)
(0.00992 shift NNS)
(0.01 left NNS)
(0.00987 right NNS)
(0.01003 shift PDT)
(0.01 left PDT)
(0.01004 right PDT)
(0.00992 shift POS)
(0.01 left POS)
(0.00985 right POS)
(0.0101 shift PRP)
(0.01 left PRP)
(0.01003 right PRP)
(0.01006 shift PRPDOLLARSIGN)
(0.01 left PRPDOLLARSIGN)
(0.00997 right PRPDOLLARSIGN)
(0.01005 shift RB)
(0.01 left RB)
(0.01001 right RB)
(0.01001 shift RBR)
(0.01 left RBR)
(0.00999 right RBR)
(0.01005 shift RBS)
(0.01 left RBS)
(0.01003 right RBS)
(0.0099 shift RP)
(0.01 left RP)
(0.01006 right RP)
(0.01001 shift -RRB-)
(0.01 left -RRB-)
(0.01014 right -RRB-)
(0.01008 shift TO)
(0.01 left TO)
(0.01005 right TO)
(0.01003 shift UH)
(0.01 left UH)
(0.01001 right UH)
(0.00996 shift VB)
(0.01 left VB)
(0.00992 right VB)
(0.00987 shift VBD)
(0.01 left VBD)
(0.00985 right VBD)
(0.01004 shift VBG)
(0.01 left VBG)
(0.00999 right VBG)
(0.01 shift VBN)
(0.01 left VBN)
(0.00996 right VBN)
(0.00987 shift VBP)
(0.01 left VBP)
(0.00987 right VBP)
(0.00987 shift VBZ)
(0.01 left VBZ)
(0.00986 right VBZ)
(0.01003 shift WDT)
(0.01 left WDT)
(0.01 right WDT)
(0.01003 shift WPDOLLARSIGN)
(0.01 left WPDOLLARSIGN)
(0.00998 right WPDOLLARSIGN)
(0.01009 shift WP)
(0.01 left WP)
(0.01004 right WP)
(0.01002 shift WRB)
(0.01 left WRB)
(0.00996 right WRB)
))

(conditional 'prevpos
:conditions '((Selected (state 0) (operator none))
(stacktop (idx (i)))
(stack (idx (i)) (id (s1id)))
(stack (idx (i -1)) (id (s2id)))
(stack (idx (i -2)) (id (s3id)))
(sentence (id (s1id)) (word (w1)) (tag (t1)))
(sentence (id (s2id)) (word (w2)) (tag (t2)))
(sentence (id (s3id)) (word (w3)) (tag (t3))))
:actions '((Selected (state 0) (operator (a))))
:FUNCTION-VARIABLE-NAMES '(a t3)
:function '(
(0.01 shift COMMACHAR)
(0.01 left COMMACHAR)
(0.00996 right COMMACHAR)
(0.01 shift SINGLEQUOTESINGLEQUOTE)
(0.01 left SINGLEQUOTESINGLEQUOTE)
(0.00991 right SINGLEQUOTESINGLEQUOTE)
(0.01 shift PERIODCHAR)
(0.01 left PERIODCHAR)
(0.00999 right PERIODCHAR)
(0.00999 shift BACKQUOTEBACKQUOTE)
(0.01 left BACKQUOTEBACKQUOTE)
(0.00993 right BACKQUOTEBACKQUOTE)
(0.01001 shift COL)
(0.01 left COL)
(0.00996 right COL)
(0.01002 shift DOLLARSIGN)
(0.01 left DOLLARSIGN)
(0.01003 right DOLLARSIGN)
(0.00998 shift HASHSIGN)
(0.01 left HASHSIGN)
(0.00998 right HASHSIGN)
(0.01 shift CC)
(0.01 left CC)
(0.00997 right CC)
(0.01 shift CD)
(0.01 left CD)
(0.00998 right CD)
(0.01 shift DT)
(0.01 left DT)
(0.00997 right DT)
(0.01003 shift IN)
(0.01 left IN)
(0.01001 right IN)
(0.01 shift JJ)
(0.01 left JJ)
(0.00999 right JJ)
(0.00998 shift JJR)
(0.01 left JJR)
(0.00999 right JJR)
(0.00998 shift JJS)
(0.01 left JJS)
(0.00997 right JJS)
(0.00995 shift -LRB-)
(0.01 left -LRB-)
(0.00986 right -LRB-)
(0.01005 shift LW)
(0.01 left LW)
(0.01 right LW)
(0.01004 shift MD)
(0.01 left MD)
(0.01004 right MD)
(0.01002 shift NN)
(0.01 left NN)
(0.01 right NN)
(0.01 shift NNP)
(0.01 left NNP)
(0.00998 right NNP)
(0.01002 shift NNS)
(0.01 left NNS)
(0.01 right NNS)
(0.00992 shift PDT)
(0.01 left PDT)
(0.00996 right PDT)
(0.00998 shift POS)
(0.01 left POS)
(0.00997 right POS)
(0.00999 shift PRPDOLLARSIGN)
(0.01 left PRPDOLLARSIGN)
(0.00999 right PRPDOLLARSIGN)
(0.00996 shift PRP)
(0.01 left PRP)
(0.00999 right PRP)
(0.01002 shift RB)
(0.01 left RB)
(0.00998 right RB)
(0.01006 shift RBR)
(0.01 left RBR)
(0.01005 right RBR)
(0.00998 shift RBS)
(0.01 left RBS)
(0.01002 right RBS)
(0.01005 shift RP)
(0.01 left RP)
(0.01001 right RP)
(0.01003 shift TO)
(0.01 left TO)
(0.01003 right TO)
(0.01001 shift UH)
(0.01 left UH)
(0.01 right UH)
(0.01003 shift VB)
(0.01 left VB)
(0.01001 right VB)
(0.01005 shift VBD)
(0.01 left VBD)
(0.01002 right VBD)
(0.01004 shift VBG)
(0.01 left VBG)
(0.01002 right VBG)
(0.01004 shift VBN)
(0.01 left VBN)
(0.01002 right VBN)
(0.01004 shift VBP)
(0.01 left VBP)
(0.01002 right VBP)
(0.01006 shift VBZ)
(0.01 left VBZ)
(0.01003 right VBZ)
(0.01004 shift WDT)
(0.01 left WDT)
(0.01002 right WDT)
(0.01 shift WPDOLLARSIGN)
(0.01 left WPDOLLARSIGN)
(0.01001 right WPDOLLARSIGN)
(0.01003 shift WP)
(0.01 left WP)
(0.01002 right WP)
(0.01001 shift WRB)
(0.01 left WRB)
(0.01 right WRB)
))

(conditional 'nextpos
:conditions '((Selected (state 0) (operator none))
(sentence (id (ind)) (word (evw)) (tag (evt)))
(InputPtr (ptr (ind)))
(stacktop (idx (i)))
(stack (idx (i)) (id (s1id)))
(stack (idx (i -1)) (id (s2id)))
(stack (idx (i -2)) (id (s3id)))
(sentence (id (s1id)) (word (w1)) (tag (t1)))
(sentence (id (s2id)) (word (w2)) (tag (t2)))
(sentence (id (s3id)) (word (w3)) (tag (t3))))
:actions '((Selected (state 0) (operator (a))))
:FUNCTION-VARIABLE-NAMES '(a evt)
:function '(
(0.01 shift SINGLEQUOTESINGLEQUOTE)
(0.01 left SINGLEQUOTESINGLEQUOTE)
(0.01001 right SINGLEQUOTESINGLEQUOTE)
(0.01 shift HASHSIGN)
(0.01 left HASHSIGN)
(0.0099 right HASHSIGN)
(0.01 shift COMMACHAR)
(0.01 left COMMACHAR)
(0.01011 right COMMACHAR)
(0.01001 shift BACKQUOTEBACKQUOTE)
(0.01 left BACKQUOTEBACKQUOTE)
(0.00998 right BACKQUOTEBACKQUOTE)
(0.00983 shift PERIODCHAR)
(0.01 left PERIODCHAR)
(0.01009 right PERIODCHAR)
(0.00997 shift COL)
(0.01 left COL)
(0.0101 right COL)
(0.01004 shift DOLLARSIGN)
(0.01 left DOLLARSIGN)
(0.00992 right DOLLARSIGN)
(0.01006 shift CC)
(0.01 left CC)
(0.01007 right CC)
(0.01002 shift CD)
(0.01 left CD)
(0.00992 right CD)
(0.01001 shift DT)
(0.01 left DT)
(0.00995 right DT)
(0.01005 shift EX)
(0.01 left EX)
(0.00995 right EX)
(0.00998 shift FW)
(0.01 left FW)
(0.01002 right FW)
(0.01 shift IN)
(0.01 left IN)
(0.01001 right IN)
(0.01005 shift JJ)
(0.01 left JJ)
(0.00996 right JJ)
(0.01002 shift JJR)
(0.01 left JJR)
(0.00993 right JJR)
(0.01 shift JJS)
(0.01 left JJS)
(0.00989 right JJS)
(0.01002 shift -LRB-)
(0.01 left -LRB-)
(0.00998 right -LRB-)
(0.01003 shift LS)
(0.01 left LS)
(0.00997 right LS)
(0.01 shift MD)
(0.01 left MD)
(0.01005 right MD)
(0.0101 shift NN)
(0.01 left NN)
(0.01001 right NN)
(0.01006 shift NNP)
(0.01 left NNP)
(0.00996 right NNP)
(0.01001 shift NNPS)
(0.01 left NNPS)
(0.00999 right NNPS)
(0.01012 shift NNS)
(0.01 left NNS)
(0.01001 right NNS)
(0.00999 shift PDT)
(0.01 left PDT)
(0.00995 right PDT)
(0.01026 shift POS)
(0.01 left POS)
(0.01007 right POS)
(0.01 shift PRP)
(0.01 left PRP)
(0.00992 right PRP)
(0.01001 shift PRPDOLLARSIGN)
(0.01 left PRPDOLLARSIGN)
(0.00992 right PRPDOLLARSIGN)
(0.01 shift RB)
(0.01 left RB)
(0.00999 right RB)
(0.00998 shift RBR)
(0.01 left RBR)
(0.00995 right RBR)
(0.01007 shift RBS)
(0.01 left RBS)
(0.01004 right RBS)
(0.01 shift RP)
(0.01 left RP)
(0.00995 right RP)
(0.01004 shift -RRB-)
(0.01 left -RRB-)
(0.01006 right -RRB-)
(0.00971 shift RW)
(0.01 left RW)
(0.01017 right RW)
(0.00999 shift TO)
(0.01 left TO)
(0.01 right TO)
(0.00997 shift UH)
(0.01 left UH)
(0.01003 right UH)
(0.01 shift VB)
(0.01 left VB)
(0.00996 right VB)
(0.01001 shift VBD)
(0.01 left VBD)
(0.01005 right VBD)
(0.01001 shift VBG)
(0.01 left VBG)
(0.00998 right VBG)
(0.01001 shift VBN)
(0.01 left VBN)
(0.00997 right VBN)
(0.01 shift VBP)
(0.01 left VBP)
(0.01003 right VBP)
(0.01002 shift VBZ)
(0.01 left VBZ)
(0.01006 right VBZ)
(0.00998 shift WDT)
(0.01 left WDT)
(0.00998 right WDT)
(0.00999 shift WPDOLLARSIGN)
(0.01 left WPDOLLARSIGN)
(0.00993 right WPDOLLARSIGN)
(0.00998 shift WP)
(0.01 left WP)
(0.00993 right WP)
(0.01 shift WRB)
(0.01 left WRB)
(0.01 right WRB)
))

(conditional 'rejectshift
             :conditions '((Selected (state 0) (operator none))
                           (InputPtr (ptr (ind)))
                           (sentence (id (ind)) (word RW) (tag RW)))
             :actions '((Selected - (state 0) (operator shift))))

(conditional 'rejectleft
             :conditions '((Selected (state 0) (operator none))
                           (InputPtr (ptr (ind)))
                           (stacktop (idx 1))
                           (sentence - (id (ind)) (tag RW)))
             :actions '((Selected - (state 0) (operator left))))

(conditional 'rejectright
             :conditions '((Selected (state 0) (operator none))
                           (InputPtr (ptr (ind)))
                           (stacktop (idx 1))
                           (sentence - (id (ind)) (tag RW)))
             :actions '((Selected - (state 0) (operator right))))


(conditional 'terminate
             :conditions '((Selected (state 0) (operator none))
                           (InputPtr (ptr (ind)))
                           (sentence (id (ind)) (word RW) (tag RW))
                           (stacktop (idx 0)))
             :actions '((Selected (state 0) (operator done))))

(evidence '((StackTop 1 (idx 0))
            (Stack 1 (idx -1) (id 0))
            (Stack 1 (idx 0) (id 0))
            (InputPtr 1 (ptr 1))
            (Selected 1 (state 0) (operator none))            
            (sentence 1 (id 0) (word LW) (tag LW))

          ;  (sentence 1 (id 1) (word the) (tag DT))
          ;  (sentence 1 (id 2) (word dog) (tag NN))
          ;  (sentence 1 (id 3) (word chased) (tag VBD))
          ;  (sentence 1 (id 4) (word the) (tag DT))
          ;  (sentence 1 (id 5) (word cat) (tag NN))

          ;  (sentence 1 (id 6) (word RW) (tag RW))))

            (sentence 1 (id 1) (tag PRP))        ; I
            (sentence 1 (id 2) (tag VBP))        ; saw
            (sentence 1 (id 3) (tag DT))         ; the
            (sentence 1 (id 4) (tag NNS))        ; statue
            (sentence 1 (id 5) (tag IN))         ; in
            (sentence 1 (id 6) (tag DT))         ; the
            (sentence 1 (id 7) (tag NN))         ; park
            (sentence 1 (id 8) (tag PERIODCHAR)) ; . 

            (sentence 1 (id 9) (word RW) (tag RW))))
(d nod)))

(defun test-shift-reduce nil (sr))
; TESTING
; Semantic memory (naive Bayes categorization)

(defun cat-init nil
  (init)
  (new-type 'id :constants '(i1 i2 i3))
  (new-type 'type :constants '(walker table dog human))
  (new-type 'color :constants '(silver brown white))
  (new-type 'i04 :numeric t :discrete t :min 0 :max 5)
  (new-type 'weight :numeric t :min 0 :max 500)

  (predicate 'object :world 'closed :perception t :arguments '((state state) (id id)))
  (predicate 'concept :perception t :arguments '((id id) (value type %)))
  (predicate 'concept2 :world 'closed :arguments '((id id) (value type !)))
  (predicate 'color :perception t :arguments '((id id) (value color %)))
  (predicate 'color2 :world 'closed :arguments '((id id) (value color !)))
  (predicate 'alive :perception t :arguments '((id id) (value boolean %)))
  (predicate 'mobile :perception t :arguments '((id id) (value boolean %)))
  (predicate 'legs :perception t :arguments '((id id) (value i04 %)))
  (predicate 'weight :perception t :arguments '((id id) (value weight %)))
  (predicate 'weight2 :world 'closed :arguments '((id id) (value weight $)))

  ; Function predicates
  (predicate 'concept-f
             :arguments '((concept type %)) 
             :function 1)
  (predicate 'concept-color
             :arguments '((concept type) (color color %))
             :function '((.95 walker silver) (.05 walker brown)
                         (.05 table silver) (.95 table brown)
                         (.05 dog silver) (.7 dog brown) (.25 dog white)
                         (.5 human brown) (.5 human white)))
  (predicate 'concept-legs
             :arguments '((concept type) (legs i04 %))
             :function '((1 walker 4)
                         (.9 table 4) (.1 table 3)
                         (.01 dog 1) (.02 dog 2) (.1 dog 3) (.87 dog 4)
                         (.01 human 0) (.02 human 1) (.97 human 2)))
  (predicate 'concept-alive
             :arguments '((concept type) (alive boolean %))
             :function '((1 walker false)
                         (1 table false)
                         (.05 dog false) (.95 dog true)
                         (.05 human false) (.95 human true)))
  (predicate 'concept-mobile
             :arguments '((concept type) (mobile boolean %))
             :function '((1 walker true)
                         (.95 table false) (.05 table true)
                         (.05 dog false) (.95 dog true)
                         (.05 human false) (.95 human true)))
  (predicate 'concept-weight
             :arguments '((concept type) (weight weight %))
             :function '(((-2/15 0 2/75) walker (5 10)) ((4/15 0 -1/75) walker (10 20))
                         ((-2/1881 0 2/1881) table (1 20)) ((5/198 0 -1/3960) table (20 100))
                         ((-2/7301 0 2/7301) dog (1 50)) ((3/149 0 -1/7450) dog (50 150))
                         ((-2/59451 0 2/59451) human (1 150)) ((16/1995 0 -1/49875) human (150 400))))

  (setq pre-d '((ppwm 'concept 'array) (ppwm 'color 'array) (ppwm 'alive 'array) (ppwm 'mobile 'array) (ppwm 'legs 'array) (ppwm 'weight)))
  (setq post-d '((ppfn 'concept2 nil '((constant wm-id i1) (argmax wm-value)))
                 (ppfn 'color2 nil '((constant wm-id i1) (argmax wm-value)))
                 (ppfn 'weight2 nil '((constant wm-id i1) (argmax wm-value)))))
  )

(defun cat-conds nil

  ; Prior on concept  
  (conditional 'concept
               :conditions '((object (state (state)) (id (id))))
               :condacts '((concept (id (id)) (value (concept)))
                           (concept-f (concept (concept))))
               )

  ; Conditional distribution on attributes given concept

  (conditional 'concept-color*join
               :conditions '((object (state (state)) (id (id))))
               :condacts '((concept (id (id)) (value (concept)))
                           (color (id (id)) (value (color)))
                           (concept-color (concept (concept)) (color (color))))
               )
  
  (conditional 'concept-legs*join
               :conditions '((object (state (state)) (id (id))))
               :condacts '((concept (id (id)) (value (concept)))
                           (legs (id (id)) (value (legs)))
                           (concept-legs (concept (concept)) (legs (legs))))
               )

  (conditional 'concept-alive*join
               :conditions '((object (state (state)) (id (id))))
               :condacts '((concept (id (id)) (value (concept)))
                           (alive (id (id)) (value (alive)))
                           (concept-alive (concept (concept)) (alive (alive))))
               )
  
  (conditional 'concept-mobile*join
               :conditions '((object (state (state)) (id (id))))
               :condacts '((concept (id (id)) (value (concept)))
                           (mobile (id (id)) (value (mobile)))
                           (concept-mobile (concept (concept)) (mobile (mobile))))
               )

  (conditional 'concept-weight*join
               :conditions '((object (state (state)) (id (id))))
               :condacts '((concept (id (id)) (value (concept)))
                           (weight (id (id)) (value (weight)))
                           (concept-weight (concept (concept)) (weight (weight))))
               )

  (conditional 'color-action
               :conditions '((object (state (state)) (id (id)))
                             (color (id (id)) (value (color))))
               :actions '((color2 (id (id)) (value (color)))))

  (conditional 'weight-action
               :conditions '((object (state (state)) (id (id)))
                             (weight (id (id)) (value (weight))))
               :actions '((weight2 (id (id)) (value (weight)))))

  (conditional 'concept-action
               :conditions '((object (state (state)) (id (id)))
                             (concept (id (id)) (value (concept))))
               :actions '((concept2 (id (id)) (value (concept)))))

  t)
  
; Color silver
(defun color-silver nil
  (cat-init)
  (cat-conds)
  (setq perceive-list '((perceive '((object (state 0) (id i1))
                                    (color (id i1) (value silver))
                                    ))))
  t)

(defun test-color-silver ()
  (color-silver)
  (d 1)
  (when from-regression
    (ppwm 'concept 'array info-stream) (ppwm 'color 'array info-stream) (ppwm 'alive 'array info-stream) (ppwm 'mobile 'array info-stream)
    (ppwm 'legs 'array info-stream) (ppwm 'weight nil info-stream)
    (ppfn 'concept2 nil '((constant wm-id i1) (argmax wm-value)) info-stream)
    (ppfn 'color2 nil '((constant wm-id i1) (argmax wm-value)) info-stream)
    (ppfn 'weight2 nil '((constant wm-id i1) (argmax wm-value)) info-stream)
    (print-global-decision-statistics info-stream)
    )
  )

; Color white
(defun color-white nil
  (cat-init)
  (cat-conds)
  (setq perceive-list '((perceive '((object (state 0) (id i1))
                                    (color (id i1) (value white))
                                    ))))
  t)

; Four legs and alive
(defun alive-true-legs-4 nil
  (cat-init)
  (cat-conds)
  (setq perceive-list '((perceive '((object (state 0) (id i1))
                                    (alive (id i1) (value true))
                                    (legs (id i1) (value 4))
                                    ))))
  t)

; Concept is human
(defun concept-human nil
  (cat-init)
  (cat-conds)
  (setq perceive-list '((perceive '((object (state 0) (id i1))
                                    (concept (id i1) (value human))
                                    ))))
  t)

; Weight is 200 pounds
(defun weight-200 nil
  (cat-init)
  (cat-conds)
  (setq perceive-list '((perceive '((object (state 0) (id i1))
                                    (weight (id i1) (value (200 201)))
                                    ))))
  t)

; Something specified for concept and all attributes
(defun cat-all nil
  (cat-init)
  (cat-conds)
  (setq perceive-list '((perceive '((object (state 0) (id i1))
                                    (alive (id i1) (value true))
                                    (legs (id i1) (value 4))
                                    (color (id i1) (value brown))
                                    (mobile (id i1) (value false))
                                    (weight (id i1) (value 100))
                                    (concept (id i1) (value dog)) 
                                    ))))
  t)

; Something specified for concept and all attributes except legs
(defun no-legs nil
  (cat-init)
  (cat-conds)
  (setq perceive-list '((perceive '((object (state 0) (id i1))
                                    (alive (id i1) (value true))
                                    (color (id i1) (value brown))
                                    (mobile (id i1) (value false))
                                    (weight (id i1) (value 100))
                                    (concept (id i1) (value dog))
                                    ))))
  t)

; Something specified for all attributes except legs
(defun no-concept-legs nil
  (cat-init)
  (cat-conds)
  (setq perceive-list '((perceive '((object (state 0) (id i1))
                                    (alive (id i1) (value true))
                                    (color (id i1) (value brown))
                                    (mobile (id i1) (value false))
                                    (weight (id i1) (value 100))
                                    ))))
  t)

; Something specified for concept and all attributes except weight
(defun no-weight nil
  (cat-init)
  (cat-conds)
  (setq perceive-list '((perceive '((object (state 0) (id i1))
                                    (alive (id i1) (value true))
                                    (legs (id i1) (value 4))
                                    (color (id i1) (value brown))
                                    (mobile (id i1) (value false))
                                    (concept (id i1) (value dog))
                                    ))))
  t)

; Something specified for all attributes except weight
(defun no-concept-weight nil
  (cat-init)
  (cat-conds)
  (setq perceive-list '((perceive '((object (state 0) (id i1))
                                    (alive (id i1) (value true))
                                    (legs (id i1) (value 4))
                                    (color (id i1) (value brown))
                                    (mobile (id i1) (value false))
                                    ))))
  t)

; Simplified semantic memory with just one attribute
(defun cat1 nil
  (init)
  (new-type 'id :constants '(i1 i2 i3))
  (new-type 'type :constants '(walker table dog human))
  (new-type 'color :constants '(silver brown white))

  (predicate 'concept :perception t :arguments '((id id) (value type %)))
  (predicate 'color :perception t :arguments '((id id) (value color %)))
  (predicate 'object :perception t :world 'closed :arguments '((state state) (id id)))

  ; Function predicates
  (predicate 'concept-f :arguments '((value type %))
             :function 1)
  (predicate 'concept-color :arguments '((concept type) (color color %))
             :function '((.95 walker silver) (.05 walker brown)
                               (.05 table silver) (.95 table brown)
                               (.05 dog silver) (.7 dog brown) (.25 dog white)
                               (.5 human brown) (.5 human white)))

  (setq pre-d '((ppwm 'concept) (ppwm 'color)))

  ; Prior on concept  
  (conditional 'concept
               :conditions '((object (state (state)) (id (id))))
               :condacts '((concept (id (id)) (value (concept)))
                           (concept-f (value (concept))))
               )

  ; Conditional distribution on attributes given concept
  (conditional 'concept-color*join
               :conditions '((object (state (state)) (id (id))))
               :condacts '((concept (id (id)) (value (concept)))
                           (color (id (id)) (value (color)))
                           (concept-color (concept (concept)) (color (color))))
               )

  t)

; Color silver
(defun color-silver1 nil
  (cat1)
  (setq perceive-list '((perceive '((object (state 0) (id i1))
                                    (color (id i1) (value silver))
                                    ))))
  t)

; Test whether negative domain elements are okay
; Simplified semantic memory with one attribute (negative number of legs)
(defun cat1n nil
  (init)
  (new-type 'id :constants '(i1 i2 i3))
  (new-type 'type :constants '(walker table dog human))
  (new-type 'n04 :numeric t :discrete t :min -4 :max 1)

  (predicate 'concept :perception t :arguments '((id id) (value type %)))
  (predicate 'legs :perception t :arguments '((id id) (value n04 %)))
  (predicate 'object :perception t :world 'closed :arguments '((state state) (id id)))

  ; Prior on concept  
  (conditional 'concept
               :conditions '((object (state (state)) (id (id))))
               :condacts '((concept (id (id)) (value (concept))))
               :function-variable-names '(concept)
               :function '((.25 *)))

  ; Conditional distribution on attributes given concept
  
  (conditional 'concept-legs
               :conditions '((object (state (state)) (id (id))))
               :condacts '((concept (id (id)) (value (concept)))
                           (legs (id (id)) (value (legs))))
               :function-variable-names '(concept legs)
               :function '((1 walker -4)
                               (.9 table -4) (.1 table -3)
                               (.01 dog -1) (.02 dog -2) (.1 dog -3) (.87 dog -4)
                               (.01 human 0) (.02 human -1) (.97 human -2)))
  )

; Color silver
(defun legs-2 nil
  (cat1n)
  (setq perceive-list '((perceive '((object (state 0) (id i1))
                                    (legs (id i1) (value -2))
                                    ))))
  t)

; Simplified semantic memory with two attributes
(defun cat2 nil
  (init)
  (new-type 'id :constants '(i1 i2 i3))
  (new-type 'type :constants '(walker table dog human))
  (new-type 'color :constants '(silver brown white))
  (new-type 'i04 :numeric t :discrete t :min 0 :max 5)

  (predicate 'concept :perception t :arguments '((id id) (value type %)))
  (predicate 'color :perception t :arguments '((id id) (value color %)))
  (predicate 'legs :perception t :arguments '((id id) (value i04 %)))
  (predicate 'object :perception t :world 'closed :arguments '((state state) (id id)))

  ; Prior on concept  
  (conditional 'concept
               :conditions '((object (state (state)) (id (id))))
               :condacts '((concept (id (id)) (value (concept))))
               :function-variable-names '(concept)
               :function '((.25 *)))

  ; Conditional distribution on attributes given concept

  (conditional 'concept-color
               :conditions '((object (state (state)) (id (id))))
               :condacts '((concept (id (id)) (value (concept)))
                           (color (id (id)) (value (color))))
               :function-variable-names '(concept color)
               :function '((.95 walker silver) (.05 walker brown)
                           (.05 table silver) (.95 table brown)
                           (.05 dog silver) (.7 dog brown) (.25 dog white)
                           (.5 human brown) (.5 human white)))
  
  (conditional 'concept-legs
               :conditions '((object (state (state)) (id (id))))
               :condacts '((concept (id (id)) (value (concept)))
                           (legs (id (id)) (value (legs))))
               :function-variable-names '(concept legs)
               :function '((1 walker 4)
                           (.9 table 4) (.1 table 3)
                           (.01 dog 1) (.02 dog 2) (.1 dog 3) (.87 dog 4)
                           (.01 human 0) (.02 human 1) (.97 human 2)))
  )

; Color silver
(defun color-silver2 nil
  (cat2)
  (setq perceive-list '((perceive '((object (state 0) (id i1))
                                    (color (id i1) (value silver))
                                    ))))
  t)

; Simplified semantic memory with two attributes (just condacts)
(defun ssm nil
  (init)
  (new-type 'type :constants '(walker table dog human))
  (new-type 'color :constants '(silver brown white))
  (new-type 'i04 :numeric t :discrete t :min 0 :max 5)

  (predicate 'concept :perception t :arguments '((value type %)))
  (predicate 'color :perception t :arguments '((value color %)))
  (predicate 'legs :perception t :arguments '((value i04 %)))

  (setq pre-d '((ppwm 'concept 'array) (ppwm 'color 'array) (ppwm 'legs 'array)))

  ; Prior on concept  
  (conditional 'concept
               :condacts '((concept (value (concept))))
               :function-variable-names '(concept)
               :function '((.25 *)))

  ; Conditional distribution on attributes given concept

  (conditional 'concept-color
               :condacts '((concept (value (concept)))
                           (color (value (color))))
               :function-variable-names '(concept color)
               :function '((.95 walker silver) (.05 walker brown)
                           (.05 table silver) (.95 table brown)
                           (.05 dog silver) (.7 dog brown) (.25 dog white)
                           (.5 human brown) (.5 human white)))
  
  (conditional 'concept-legs
               :condacts '((concept (value (concept)))
                           (legs (value (legs))))
               :function-variable-names '(concept legs)
               :function '((1 walker 4)
                           (.9 table 4) (.1 table 3)
                           (.01 dog 1) (.02 dog 2) (.1 dog 3) (.87 dog 4)
                           (.01 human 0) (.02 human 1) (.97 human 2)))
  )

; Color silver
(defun ssm-color-silver nil
  (ssm)
  (setq perceive-list '((perceive '((color (value silver))))))
  t)

; Simple program for testing episodic memory
; 0: No object
; 1: walker silver false true 4 10
; 2: human white true true 2 150
; 3: human brown true true 2 125
; 4: dog silver true true 4 50
; 5: silver
; 6: not alive, 4 legs
; 7: not alive, 2 legs
; 8: dog brown
; 9: walker, silver, alive
; 10: not alive
; Each episode is learned for the time slot that is one greater than the episode number

(defparameter *ep-per* '((perceive '((concept (value walker)) (color (value silver)) (alive (value false)) (mobile (value true)) (legs (value 4)) (weight (value 10))))
                         (perceive '((concept (value human)) (color (value white)) (alive (value true)) (mobile (value true)) (legs (value 2)) (weight (value 150))))
                         (perceive '((concept (value human)) (color (value brown)) (alive (value true)) (mobile (value true)) (legs (value 2)) (weight (value 125))))
                         (perceive '((concept (value dog)) (color (value silver)) (alive (value true)) (mobile (value true)) (legs (value 4)) (weight (value 50))))
                         (perceive '((concept (value walker)) (color (value *)) (alive (value *)) (mobile (value *)) (legs (value *)) (weight (value *))))
                         (perceive '((concept (value *)) (color (value silver)) (alive (value *)) (mobile (value *)) (legs (value *)) (weight (value *))))
                         (perceive '((concept (value *)) (color (value *)) (alive (value false)) (mobile (value *)) (legs (value 4)) (weight (value *))))
                         (perceive '((concept (value *)) (color (value *)) (alive (value false)) (mobile (value *)) (legs (value 2)) (weight (value *))))
                         (perceive '((concept (value dog)) (color (value brown)) (alive (value *)) (mobile (value *)) (legs (value *)) (weight (value *))))
                         (perceive '((concept (value walker)) (color (value silver)) (alive (value true)) (mobile (value *)) (legs (value *)) (weight (value *))))
                         (perceive '((concept (value *)) (color (value *)) (alive (value false)) (mobile (value *)) (legs (value *)) (weight (value *))))
                         )
  )
(defvar ep-per)

(defun episodic nil
  (init)
  (setq gdl-subtractive-normalization nil) ; Necessary so that give divisive normalization, and thus exponential rather than linear decay in time
  (setq exponential-product-gradient nil)
  (setq threshold-for-dense-connection 15) ; Makes it easier to understand messages at temporal variable
;  (setq trace-gdl '(time-cff time-concept*episodic-learn))
  (learn '(:e))
  (setq trace-perception t)
  (setq ep-per *ep-per*)
  (setq perceive-list '((eval (pop ep-per))))
  (setq pre-d '((format trace-stream "~&~%Temporal prior:") (pa 'time*episodic)
                (format trace-stream "~&~%Episodic retrieval:")
                (format trace-stream "~&  Time[~S]: " (best-in-plm (vn-posterior (predicate-from-name 'time*episodic)))) (ppvn 'time*episodic)
                (format trace-stream "~&  Concept[~S]: " (best-in-plm (vn-posterior (predicate-from-name 'concept*episodic)) 0)) (ppvn 'concept*episodic)
                (format trace-stream "~&  Color[~S]: " (best-in-plm (vn-posterior (predicate-from-name 'color*episodic)) 0)) (ppvn 'color*episodic)
                (format trace-stream "~&  Alive[~S]: " (best-in-plm (vn-posterior (predicate-from-name 'alive*episodic)) 0)) (ppvn 'alive*episodic)
                (format trace-stream "~&  Mobile[~S]: " (best-in-plm (vn-posterior (predicate-from-name 'mobile*episodic)) 0)) (ppvn 'mobile*episodic)
                (format trace-stream "~&  Legs[~S]: " (best-in-plm (vn-posterior (predicate-from-name 'legs*episodic)) 0)) (ppvn 'legs*episodic)
                (format trace-stream "~&  Weight[~S]: " (best-in-plm (vn-posterior (predicate-from-name 'weight*episodic)) 0)) (ppvn 'weight*episodic)))

;  (setq post-d '((format trace-stream "~&~%Concept episodic memory:") (pa 'time-concept*episodic-learn)))

  (new-type 'type :constants '(walker table dog human))
  (new-type 'color :constants '(silver brown white))
  (new-type 'i04 :numeric t :discrete t :min 0 :max 5)
  (new-type 'weight :numeric t :min 0 :max 500)

  (predicate 'concept :world 'closed :perception t :arguments '((state state) (value type !)))
  (predicate 'color :world 'closed :perception t :arguments '((state state) (value color !)))
  (predicate 'alive :world 'closed :perception t :arguments '((state state) (value boolean !)))
  (predicate 'mobile :world 'closed :perception t :arguments '((state state) (value boolean !)))
  (predicate 'legs :world 'closed :perception t :arguments '((state state) (value i04 !)))
  (predicate 'weight :world 'closed :perception t :arguments '((state state) (value weight !)))
  
  t)

(defun test-episodic nil
  (episodic)
  (d 12)
  )

; Replay a sequence of episodes starting from a retrieved one
(defparameter *ep-per-replay* '((perceive '((concept (value walker)) (color (value silver)) (alive (value false)) (mobile (value true)) (legs (value 4)) (weight (value 10))))
                                nil
                                (perceive '((concept (value human)) (color (value white)) (alive (value true)) (mobile (value true)) (legs (value 2)) (weight (value 150))))
                                nil
                                (perceive '((concept (value human)) (color (value brown)) (alive (value true)) (mobile (value true)) (legs (value 2)) (weight (value 125))))
                                nil
                                (perceive '((concept (value dog)) (color (value silver)) (alive (value true)) (mobile (value true)) (legs (value 4)) (weight (value 50))))
                                nil
                                (perceive '((concept (value walker)) (color (value *)) (alive (value *)) (mobile (value *)) (legs (value *)) (weight (value *))))
                                nil
                                (perceive '((concept (value *)) (color (value silver)) (alive (value *)) (mobile (value *)) (legs (value *)) (weight (value *))))
                                nil
                                (perceive '((concept (value *)) (color (value *)) (alive (value false)) (mobile (value *)) (legs (value 4)) (weight (value *))))
                                nil
                                (perceive '((concept (value *)) (color (value *)) (alive (value false)) (mobile (value *)) (legs (value 2)) (weight (value *))))
                                nil
                                (perceive '((concept (value dog)) (color (value brown)) (alive (value *)) (mobile (value *)) (legs (value *)) (weight (value *))))
                                nil
                                (perceive '((concept (value walker)) (color (value silver)) (alive (value true)) (mobile (value *)) (legs (value *)) (weight (value *))))
                                nil
                                (perceive '((concept (value *)) (color (value *)) (alive (value false)) (mobile (value *)) (legs (value *)) (weight (value *))))
                                )
  )

(defun episodic-replay nil
  (init '(replay))
  (setq gdl-subtractive-normalization nil) ; Necessary so that give divisive normalization, and thus exponential rather than linear decay in time
  (setq exponential-product-gradient nil)
  (setq threshold-for-dense-connection 15) ; Makes it easier to understand messages at temporal variable
;  (setq trace-gdl '(time-cff time-concept*episodic-learn))
  (learn '(:e))
  (setq trace-perception t)
  (setq ep-per *ep-per-replay*)
  (setq perceive-list '((eval (pop ep-per))))
  (setq pre-d '((format trace-stream "~&~%Temporal prior:") (pa 'time*episodic-cff)
                (format trace-stream "~&~%Episodic retrieval:")
                (format trace-stream "~&  Time[~S]: " (best-in-plm (vn-posterior (predicate-from-name 'time*episodic)))) (ppvn 'time*episodic)
                (format trace-stream "~&  Concept[~S]: " (best-in-plm (vn-posterior (predicate-from-name 'concept*episodic)) 0)) (ppvn 'concept*episodic)
                (format trace-stream "~&  Color[~S]: " (best-in-plm (vn-posterior (predicate-from-name 'color*episodic)) 0)) (ppvn 'color*episodic)
                (format trace-stream "~&  Alive[~S]: " (best-in-plm (vn-posterior (predicate-from-name 'alive*episodic)) 0)) (ppvn 'alive*episodic)
                (format trace-stream "~&  Mobile[~S]: " (best-in-plm (vn-posterior (predicate-from-name 'mobile*episodic)) 0)) (ppvn 'mobile*episodic)
                (format trace-stream "~&  Legs[~S]: " (best-in-plm (vn-posterior (predicate-from-name 'legs*episodic)) 0)) (ppvn 'legs*episodic)
                (format trace-stream "~&  Weight[~S]: " (best-in-plm (vn-posterior (predicate-from-name 'weight*episodic)) 0)) (ppvn 'weight*episodic)))

  (setq post-d '((format trace-stream "~&~%Replay Episode:") (ppfn 'time*replay)
                 (ppfn 'selected nil '((max wm-state) (argmax wm-operator)))))

  (new-type 'type :constants '(walker table dog human))
  (new-type 'color :constants '(silver brown white))
  (new-type 'i04 :numeric t :discrete t :min 0 :max 5)
  (new-type 'weight :numeric t :min 0 :max 500)

  (predicate 'concept :world 'closed :perception t :arguments '((state state) (value type !)))
  (predicate 'color :world 'closed :perception t :arguments '((state state) (value color !)))
  (predicate 'alive :world 'closed :perception t :arguments '((state state) (value boolean !)))
  (predicate 'mobile :world 'closed :perception t :arguments '((state state) (value boolean !)))
  (predicate 'legs :world 'closed :perception t :arguments '((state state) (value i04 !)))
  (predicate 'weight :world 'closed :perception t :arguments '((state state) (value weight !)))

  (predicate 'time*replay :world 'closed :arguments '((value time !)))

  ; Start replay at episode 1 when see episode 6 (not alive, 4 legs)
  (conditional 'start-replay
               :conditions '((time (value 13))
                             (time*episodic (value (t))))
               :actions '((time*replay (value (t))))
               )

  ; Propose a replay step whenever there is a replay time
  (conditional 'propose-replay
               :conditions '((state (state (s)))
                             (time*replay (value (t))))
               :actions '((selected (state (s)) (operator replay)))
               )

  ; Access content of episodic memory for replay step
  (conditional 'replay-access
               :conditions '((state (state (s)))
                             (selected (state (s)) (operator replay))
                             (time*replay (value (t))))
               :actions '((time*episodic (value (t))))
               )

  ; Increment replay time
  (conditional 'replay-increment
               :conditions '((state (state (s)))
                             (selected (state (s)) (operator replay))
                             (time*replay (value (t))))
               :actions '((time*replay (value (t 1))))
               )
  (when open-world-wmfns
    (evidence '((time*episodic .01)))
    )
  
  t)

(defun test-episodic-replay nil
  (episodic-replay)
  (d 25)
  )

; Program for learning a random sequence of episodes

; Get a random element from a discrete type (form its name)
(defun random-element (type-name)
  (let* ((type (type-from-name type-name))
         (span (stype-span type)))
    (unless type
      (error "Type unknown in attempt to generate random element")
      )
    (unless (or (stype-discrete type)
                (floatp (stype-span type))
                )
      (setq span (coerce span 'float))
      )
    (if (stype-constants type)
        (nth (random span) (stype-constants type))
      (random span)))
  )

; Create one random episode
; With probability (1 - prob-value) specify no specific value
(defun random-episode (predicates prob-value)
  (unless (and (>= prob-value 0) (<= prob-value 1))
    (error "Specified PROB-VALUE in RANDOM-EPISODE not in [0,1]")
    )
  (let (ep)
    (dolist (p predicates)
      (let (pep)
        (dolist (a (predicate-arguments p))
          (unless (eq (argument-name a) 'state)
            (push (list (argument-name a)
                        (if (< (random 1.0) prob-value)
                            (random-element (argument-type-name a))
                          '*)) pep)
            )
          )
        (push (cons (predicate-name p) (reverse pep)) ep)
        )
      )
    (list 'perceive (list 'quote (reverse ep)))
    )
  )

; Create the arguments for a random closed-world discrete selection state predicate
(defun random-cwdss-arguments (typev min-args max-args)
  (let ((args (list '(state state)))
        (nargs (+ (random (- max-args min-args)) min-args))
        (rank (length typev))
        )
    (dotimes (i (1- nargs))
      (push (list (gentemp "ARG") (stype-name (aref typev (random rank)))) args)
      )
    (push (list (gentemp "ARG") (stype-name (aref typev (random rank))) '!) args)
    (reverse args))
  )

; Create a random closed-world discrete selection state predicate
(defun random-cwdss-predicate (typev min-args max-args)
  (predicate (gentemp "PRED") :world 'closed :perception t :arguments (random-cwdss-arguments typev min-args max-args))
  )

; Generate a vector of types
(defun vector-of-types (max-domain)
  (let ((typev (init-vector max-domain)))
    (dotimes (i max-domain)
      (setf (aref typev i) (new-type (gentemp "TYPE") :numeric t :discrete t :min 0 :max (1+ i)))
      )
    typev)
  )

; Create a random set of episodic predicates
(defun random-episodic-predicates (min-preds max-preds min-args max-args max-domain)
  (let ((npreds (+ (random (- max-preds min-preds)) min-preds))
        (vts (vector-of-types max-domain))
        preds
        )
    (dotimes (i npreds)
      (push (random-cwdss-predicate vts min-args max-args) preds)
      )
    preds)
  )

; Global variable for tracking randomly generated episodic predicates
(defvar episodic-predicates)

; Create a list of random episodes
(defun random-episodes (nepisodes min-preds max-preds min-args max-args max-domain prob-value)
  (let (eps)
    (setq episodic-predicates (random-episodic-predicates min-preds max-preds min-args max-args max-domain))
    (dotimes (i nepisodes)
      (push (random-episode episodic-predicates prob-value) eps)
      )
    eps)
  )

; Learn a series of random episodes
(defun episodic-random (nepisodes)
  (init)
  (setq gdl-subtractive-normalization nil) ; Necessary so that give divisive normalization, and thus exponential rather than linear decay in time
  (learn '(:e))
  (setq trace-perception t)
  (setq ep-per (random-episodes nepisodes 1 4 1 3 4 .8))
  (setq perceive-list '((eval (pop ep-per))))
  (setq pre-d '((format trace-stream "~&~%Temporal prior:") (pa 'time*episodic-cff)))
  (dotimes (i (+ nepisodes 1))
    (d 1)
    )
  (dolist (p episodic-predicates)
    (format trace-stream "~&~%Episodic memory for predicate ~S:" (predicate-name p))
    (pa (concat-symbols `(time- ,(predicate-name p) *episodic-learn)) nil '((constant state 0)))
    )
  (dolist (timing (reverse (mapcar #'decision-statistics-run-time global-decision-statistics)))
    (format t "~S," timing)
    )
  )

; Program for simple linked production
(defun init-rule (&optional reverse)
  (init)
  (new-type 'id :constants '(i1 i2 i3 i4 i5 i6 i7))
  
  (predicate 'next :world 'closed :arguments '((id id) (value id)))

  (setq post-d '((ppfn 'next nil 'array)))
  
  (conditional 'trans
               :conditions '(
                             (next (id (a)) (value (b)))
                             (next (id (b)) (value (c)))
                             )
               :actions '((next (id (a)) (value (c))))
               )

  (when reverse
    (conditional 'reverse
                 :conditions '(
                               (next (id (a)) (value (b)))
                               )
                 :actions '((next (id (b)) (value (a))))
                 )
    )
  t)

; One possible match
(defun rule-one (&optional reverse)
  (init-rule reverse)
  (evidence '((next (id i1) (value i2))
              (next (id i2) (value i3))
              ))
  t)

(defun test-rule-one nil
  (rule-one)
  (d 1)
  (ppfn 'next nil 'array info-stream)
  )

; Two possible matches
(defun rule-two (&optional reverse)
  (init-rule reverse)
  (evidence '((next (id i1) (value i2))
              (next (id i2) (value i3))
              (next (id i4) (value i5))
              (next (id i5) (value i6))
              ))
  t)

; Program for simple linked production
(defun init-rule2 (&optional reverse)
  (init)
  (new-type 'id :constants '(i1 i2 i3 i4 i5 i6 i7))
  
  (predicate 'next :world 'closed :arguments '((id id) (value id) (unique boolean !)))

  (setq post-d '((ppwm 'next)))
  
  (conditional 'trans
               :conditions '(
                             (next (id (a)) (value (b)) (unique true))
                             (next (id (b)) (value (c)) (unique true))
                             )
               :actions '((next (id (a)) (value (c)) (unique true)))
               )

  (when reverse
    (conditional 'reverse
                 :conditions '(
                               (next (id (a)) (value (b)) (unique true))
                               )
                 :actions '((next (id (b)) (value (a)) (unique-true)))
                 )
    )
  t)

; One possible match
(defun rule-one2 (&optional reverse)
  (init-rule2 reverse)
  (evidence '((next (id i1) (value i2) (unique true))
              (next (id i2) (value i3) (unique true))
              ))
  t)

; Two possible matches
(defun rule-two2 (&optional reverse)
  (init-rule2 reverse)
  (evidence '((next (id i1) (value i2) (unique true))
              (next (id i2) (value i3) (unique true))
              (next (id i4) (value i5) (unique true))
              (next (id i5) (value i6) (unique true))
              ))
  t)

; Simple test for constraint processing with the two color problem
(defun constraint (&optional learn)
  (let (function)
    (init)
    (if learn
        (progn
          (learn '(:gd))
          (setq function 1)
          )
      (progn
        (learn)
        (setq function '((1 red blue) (1 blue red) (0 red red) (0 blue blue)))
        )
      )
    
    (new-type 'cell :constants '(c1 c2 c3 c4))
    (new-type 'color :constants '(red blue))
    
    (predicate 'assign :perception t :arguments '((cell cell) (color color %)))

    ; Function predicates
    (predicate 'constraint12 :arguments '((color1 color) (color2 color)))
    (predicate 'constraint13 :arguments '((color1 color) (color3 color)))
    (predicate 'constraint24 :arguments '((color2 color) (color4 color)))
    (predicate 'constraint34 :arguments '((color3 color) (color4 color)))

    (conditional 'c12*join
                 :condacts '(
                             (assign (cell c1) (color (color1)))
                             (assign (cell c2) (color (color2)))
                             (constraint12 (color1 (color1)) (color2 (color2)))
                             )
                 )
    
    (conditional 'c13
                 :condacts '(
                             (assign (cell c1) (color (color1)))
                             (assign (cell c3) (color (color3)))
                             (constraint13 (color1 (color1)) (color3 (color3)))
                             )
                 )
    
    (conditional 'c24
                 :condacts '(
                             (assign (cell c2) (color (color2)))
                             (assign (cell c4) (color (color4)))
                             (constraint24 (color2 (color2)) (color4 (color4)))
                             )
                 )
    
    (conditional 'c34
                 :condacts '(
                             (assign (cell c3) (color (color3)))
                             (assign (cell c4) (color (color4)))
                             (constraint34 (color3 (color3)) (color4 (color4)))
                             )
                 )

    ; Function conditionals

    (conditional 'c12*function
                 :condacts '((constraint12 (color1 (color1)) (color2 (color2))))
                 :function-variable-names '(color1 color2)
                 :normal '(color1 color2)
                 :function function
                 )

    (conditional 'c13*function
                 :condacts '((constraint13 (color1 (color1)) (color3 (color3))))
                 :function-variable-names '(color1 color3)
                 :normal '(color1 color3)
                 :function function
                 )

    (conditional 'c24*function
                 :condacts '((constraint24 (color2 (color2)) (color4 (color4))))
                 :function-variable-names '(color2 color4)
                 :normal '(color2 color4)
                 :function function
                 )

    (conditional 'c34*function
                 :condacts '((constraint34 (color3 (color3)) (color4 (color4))))
                 :function-variable-names '(color3 color4)
                 :normal '(color3 color4)
                 :function function
                 )

    )
  t)

; Test constraint program
(defun ct nil
  (constraint)
  (setq post-d '((ppwm 'assign)))
  (setq perceive-list '((perceive '(
                                   (assign (cell c1) (color blue))
                                   )
                                 )
                       ))
  (d 1)
  )

; Assign evidence
(defun ce (type)
  (if (eq type 'blue)
      (setq perceive-list '((perceive '(
                                        (assign (cell c1) (color blue))
                                        (assign (cell c2) (color red))
                                        (assign (cell c3) (color red))
                                        (assign (cell c4) (color blue))
                                        )
                                      )))
    (setq perceive-list '((perceive '(
                                        (assign (cell c1) (color red))
                                        (assign (cell c2) (color blue))
                                        (assign (cell c3) (color blue))
                                        (assign (cell c4) (color red))
                                        )
                                      ))))
  )

; Test what messages go into function nodes when full results in evidence
(defun cl (iterations)
  (constraint t)
  (setq post-d '((format trace-stream "~&") (pcfs)))
  (dotimes (i iterations)
    (ce 'blue)
    (d 1)
    (ce 'red)
    (d 1)
    )
  )


; Eight puzzle

; Print Eight Puzzle board as an array
(defun pepb (&optional state stream)
  (unless stream (setq stream trace-stream))
  (unless state (setq state 0))
  (pa 'board t `((constant wm-state ,state) (argmax wm-tile)) stream)
  )

; A program for the Eight Puzzle based on a 2D board
; No subgoaling
(defun ep7i (&optional el) ; Whether to do episodic learning
  (init '(left right up down))
  (when el (learn '(:e)))

  (setq pre-d '(
                )
        )

  (setq post-d '((ppfn 'selected)
                 (format trace-stream "~&~%")
                 (pepb)
                 (when episodic-learning (print-episodic-memory))
                 )
        )

  (new-type 'dimension :numeric t :min 0 :max 3)
  (new-type 'tile :numeric t :discrete t :min 0 :max 9)

  (predicate 'board :world 'closed :arguments '((state state) (x dimension) (y dimension) (tile tile !)))
  (predicate 'operator :world 'closed :persistent nil :arguments '((id operator %) (state state) (x dimension) (y dimension)))
  (predicate 'goal :world 'closed :arguments '((state state) (x dimension) (y dimension) (tile tile !)))
  (predicate 'success :world 'closed :arguments '((state state)))

  (conditional 'left
               :conditions '((state (state (s)))
                             (board (state (s)) (x (x)) (y (y)) (tile (t)))
                             (board (state (s)) (x (x -1)) (y (y)) (tile 0))
                             )
               :actions '(
                          (operator (state (s)) (id left) (x (x)) (y (y)))
                           )
               )

  (conditional 'right
               :conditions '((state (state (s)))
                             (board (state (s)) (x (x)) (y (y)) (tile (t)))
                             (board (state (s)) (x (x 1)) (y (y)) (tile 0))
                             )
               :actions '(
                          (operator (state (s)) (id right) (x (x)) (y (y)))
                           )
               )

  (conditional 'up
               :conditions '((state (state (s)))
                             (board (state (s)) (x (x)) (y (y)) (tile (t)))
                             (board (state (s)) (x (x)) (y (y -1)) (tile 0))
                             )
               :actions '(
                          (operator (state (s)) (id up) (x (x)) (y (y)))
                           )
               )

  (conditional 'down
               :conditions '((state (state (s)))
                             (board (state (s)) (x (x)) (y (y)) (tile (t)))
                             (board (state (s)) (x (x)) (y (y 1)) (tile 0))
                             )
               :actions '(
                          (operator (state (s)) (id down) (x (x)) (y (y)))
                           )
               )

  (conditional 'acceptable ; Make all operators on the current state acceptable
               :conditions '((state (state (s)))
                             (operator (id (o)) (state (s)) (x (x)) (y (y)))
                             )
               :actions '((selected (state (s)) (operator (o))))
               :function .1
               )

  (conditional 'move-left ; Move tile left (and blank right)
               :conditions '((state (state (s)))
                             (selected (state (s)) (operator left))
                             (operator (id left) (state (s)) (x (x)) (y (y)))
                             (board (state (s)) (x (x)) (y (y)) (tile (t)))
                             (board (state (s)) (x (x -1)) (y (y)) (tile 0))
                             )
               :actions '((board (state (s)) (x (x)) (y (y)) (tile 0))
                          (board - (state (s)) (x (x -1)) (y (y)) (tile 0))
                          (board (state (s)) (x (x -1)) (y (y)) (tile (t)))
                          (board - (state (s)) (x (x)) (y (y)) (tile (t)))
                          )
               )

  (conditional 'move-right ; Move tile right (and blank left)
               :conditions '((state (state (s)))
                             (selected (state (s)) (operator right))
                             (operator (id right) (state (s)) (x (x)) (y (y)))
                             (board (state (s)) (x (x)) (y (y)) (tile (t)))
                             (board (state (s)) (x (x 1)) (y (y)) (tile 0))
                             )
               :actions '((board (state (s)) (x (x)) (y (y)) (tile 0))
                          (board - (state (s)) (x (x 1)) (y (y)) (tile 0))
                          (board (state (s)) (x (x 1)) (y (y)) (tile (t)))
                          (board - (state (s)) (x (x)) (y (y)) (tile (t)))
                          )
               )

  (conditional 'move-up ; Move tile up (and blank down)
               :conditions '((state (state (s)))
                             (selected (state (s)) (operator up))
                             (operator (id up) (state (s)) (x (x)) (y (y)))
                             (board (state (s)) (x (x)) (y (y)) (tile (t)))
                             (board (state (s)) (x (x)) (y (y -1)) (tile 0))
                             )
               :actions '((board (state (s)) (x (x)) (y (y)) (tile 0))
                          (board - (state (s)) (x (x)) (y (y -1)) (tile 0))
                          (board (state (s)) (x (x)) (y (y -1)) (tile (t)))
                          (board - (state (s)) (x (x)) (y (y)) (tile (t)))
                          )
               )

  (conditional 'move-down ; Move tile down (and blank up)
               :conditions '((state (state (s)))
                             (selected (state (s)) (operator down))
                             (operator (id down) (state (s)) (x (x)) (y (y)))
                             (board (state (s)) (x (x)) (y (y)) (tile (t)))
                             (board (state (s)) (x (x)) (y (y 1)) (tile 0))
                             )
               :actions '((board (state (s)) (x (x)) (y (y)) (tile 0))
                          (board - (state (s)) (x (x)) (y (y 1)) (tile 0))
                          (board (state (s)) (x (x)) (y (y 1)) (tile (t)))
                          (board - (state (s)) (x (x)) (y (y)) (tile (t)))
                          )
               )

  (conditional 'left-best ; Make operators best that move tile into goal location
               :conditions '((state (state (s)))
                             (operator (id left) (state (s)) (x (x)) (y (y)))
                             (board (state (s)) (x (x)) (y (y)) (tile (t)))
                             (goal (state (s)) (x (x -1)) (y (y)) (tile (t)))
                             )
               :actions '((selected (state (s)) (operator left)))
               )

  (conditional 'goal-reject ; Reject an operator that moves a tile from its desired location
               :conditions '((state (state (s)))
                             (operator (id (o)) (state (s)) (x (x)) (y (y)))
                             (goal (state (s)) (x (x)) (y (y)) (tile (t)))
                             (board (state (s)) (x (x)) (y (y)) (tile (t)))
                             )
               :actions '((selected - (state (s)) (operator (o))))
               )

  (conditional 'previous-reject-left-right ; Reject left operator when previous is right
               :conditions '((state (state (s)))
                             (selected (state (s)) (operator right))
                             (operator (state (s)) (id right) (x (px)) (y (py)))
                             (operator (state (s)) (id left) (x (x)) (y (y)))
                             )
               :actions '((selected - (state (s)) (operator left))
                          )
               )

  (conditional 'previous-reject-right-left ; Reject right operator when previous is left
               :conditions '((state (state (s)))
                             (selected (state (s)) (operator left))
                             (operator (state (s)) (id left) (x (px)) (y (py)))
                             (operator (state (s)) (id right) (x (x)) (y (y)))
                             )
               :actions '((selected - (state (s)) (operator right))
                          )
               )

  (conditional 'previous-reject-up-down ; Reject up operator when previous is down
               :conditions '((state (state (s)))
                             (selected (state (s)) (operator down))
                             (operator (state (s)) (id down) (x (px)) (y (py)))
                             (operator (state (s)) (id up) (x (x)) (y (y)))
                             )
               :actions '((selected - (state (s)) (operator up))
                          )
               )

  (conditional 'previous-reject-down-up ; Reject down operator when previous is up
               :conditions '((state (state (s)))
                             (selected (state (s)) (operator up))
                             (operator (state (s)) (id up) (x (px)) (y (py)))
                             (operator (state (s)) (id down) (x (x)) (y (y)))
                             )
               :actions '((selected - (state (s)) (operator down))
                          )
               )

  (conditional 'goal-test
               :conditions '((state (state (s)))
                             (board (state (s)) (x (x1)) (y (y1)) (tile 1))
                             (goal (state (s)) (x (x1)) (y (y1)) (tile 1))
                             (board (state (s)) (x (x2)) (y (y2)) (tile 2))
                             (goal (state (s)) (x (x2)) (y (y2)) (tile 2))
                             (board (state (s)) (x (x3)) (y (y3)) (tile 3))
                             (goal (state (s)) (x (x3)) (y (y3)) (tile 3))
                             (board (state (s)) (x (x4)) (y (y4)) (tile 4))
                             (goal (state (s)) (x (x4)) (y (y4)) (tile 4))
                             (board (state (s)) (x (x5)) (y (y5)) (tile 5))
                             (goal (state (s)) (x (x5)) (y (y5)) (tile 5))
                             (board (state (s)) (x (x6)) (y (y6)) (tile 6))
                             (goal (state (s)) (x (x6)) (y (y6)) (tile 6))
                             (board (state (s)) (x (x7)) (y (y7)) (tile 7))
                             (goal (state (s)) (x (x7)) (y (y7)) (tile 7))
                             (board (state (s)) (x (x8)) (y (y8)) (tile 8))
                             (goal (state (s)) (x (x8)) (y (y8)) (tile 8))
                             )
               :actions '((success (state (s)))
                          )
               )

  (conditional 'halt
               :conditions '((success (state 0)))
               :actions '((halt))
               )

  t)

; Initialize board and goal for 2d 8P 
(defun ep7e nil
; Board
; 123
; 8 5
; 746
  (evidence '((board (state 0) (x 0) (y 0) (tile 1))
              (board (state 0) (x 1) (y 0) (tile 2))
              (board (state 0) (x 2) (y 0) (tile 3))
              (board (state 0) (x 0) (y 1) (tile 8))
              (board (state 0) (x 1) (y 1) (tile 0))
              (board (state 0) (x 2) (y 1) (tile 5))
              (board (state 0) (x 0) (y 2) (tile 7))
              (board (state 0) (x 1) (y 2) (tile 4))
              (board (state 0) (x 2) (y 2) (tile 6))
; Goal
; 123
; 8 4
; 765
              (goal (state 0) (x 0) (y 0) (tile 1))
              (goal (state 0) (x 1) (y 0) (tile 2))
              (goal (state 0) (x 2) (y 0) (tile 3))
              (goal (state 0) (x 0) (y 1) (tile 8))
              (goal (state 0) (x 1) (y 1) (tile 0))
              (goal (state 0) (x 2) (y 1) (tile 4))
              (goal (state 0) (x 0) (y 2) (tile 7))
              (goal (state 0) (x 1) (y 2) (tile 6))
              (goal (state 0) (x 2) (y 2) (tile 5))
              )
            )
  )

; Initialize board and goal for 2d 8P
(defun ep7e2 nil
; Board
; 123
; 845
; 7 6
  (evidence '((board (state 0) (x 0) (y 0) (tile 1))
              (board (state 0) (x 1) (y 0) (tile 2))
              (board (state 0) (x 2) (y 0) (tile 3))
              (board (state 0) (x 0) (y 1) (tile 8))
              (board (state 0) (x 1) (y 1) (tile 4))
              (board (state 0) (x 2) (y 1) (tile 5))
              (board (state 0) (x 0) (y 2) (tile 7))
              (board (state 0) (x 1) (y 2) (tile 0))
              (board (state 0) (x 2) (y 2) (tile 6))
; Goal
; 123
; 8 4
; 765
              (goal (state 0) (x 0) (y 0) (tile 1))
              (goal (state 0) (x 1) (y 0) (tile 2))
              (goal (state 0) (x 2) (y 0) (tile 3))
              (goal (state 0) (x 0) (y 1) (tile 8))
              (goal (state 0) (x 1) (y 1) (tile 0))
              (goal (state 0) (x 2) (y 1) (tile 4))
              (goal (state 0) (x 0) (y 2) (tile 7))
              (goal (state 0) (x 1) (y 2) (tile 6))
              (goal (state 0) (x 2) (y 2) (tile 5))
              )
            )
  )

; Initialize board and goal for 2d 8P
(defun ep7e3 nil
; Board
; 123
; 67
; 548
  (evidence '((board (state 0) (x 0) (y 0) (tile 1))
              (board (state 0) (x 1) (y 0) (tile 2))
              (board (state 0) (x 2) (y 0) (tile 3))
              (board (state 0) (x 0) (y 1) (tile 6))
              (board (state 0) (x 1) (y 1) (tile 7))
              (board (state 0) (x 2) (y 1) (tile 0))
              (board (state 0) (x 0) (y 2) (tile 5))
              (board (state 0) (x 1) (y 2) (tile 4))
              (board (state 0) (x 2) (y 2) (tile 8))
; Goal
; 123
; 8 4
; 765
              (goal (state 0) (x 0) (y 0) (tile 1))
              (goal (state 0) (x 1) (y 0) (tile 2))
              (goal (state 0) (x 2) (y 0) (tile 3))
              (goal (state 0) (x 0) (y 1) (tile 8))
              (goal (state 0) (x 1) (y 1) (tile 0))
              (goal (state 0) (x 2) (y 1) (tile 4))
              (goal (state 0) (x 0) (y 2) (tile 7))
              (goal (state 0) (x 1) (y 2) (tile 6))
              (goal (state 0) (x 2) (y 2) (tile 5))
              )
            )
  )

(defun ep7 (&optional el)
;  (learn)
  (ep7i el)
  (ep7e)
  t)

(defun ep72 (&optional el)
;  (learn)
  (ep7i el)
  (ep7e2)
  t)

(defun ep73 (&optional el)
;  (learn)
  (ep7i el)
  (ep7e3)
  t)

; A program for the Eight Puzzle based on a 2D board
; No subgoaling
(defun ep8i (&optional el) ; Whether to do episodic learning
  (init)
  (setq gdl-subtractive-normalization nil)
  (when el
    (learn '(:e))
;    (setq trace-gdl '(time-selected*episodic-learn time-cff))
    )

  (when episodic-learning
    (setq pre-d '((format trace-stream "~&~%Operator retrieved from episodic memory:~%")
                   (ppvn 'selected*episodic)))
    )

  (setq post-d '((ppfn 'selected nil '((max wm-state) (argmax wm-operator)))
                 (format trace-stream "~&~%")
                 (pepb)
                 (when episodic-learning
                   (format trace-stream "~&~%Episodic memory:~%")
;                   (print-episodic-memory)
;                   (pplm 'time-board*next)
                   (pa 'time)
                   (format trace-stream "~&~%")
;                   (parray 'time-selected*episodic-learn nil '((constant state 0) (argmax operator)))
                   (parray 'time-selected*episodic-learn nil '((constant wm-state 0)))
                   (parray 'time-selected*episodic-learn nil '((constant wm-state 0) (argmax wm-operator)))
                   )
                 )
        )

  (new-type 'dimension :numeric t :min 0 :max 3)
  (new-type 'tile :numeric t :discrete t :min 0 :max 9)

  (predicate 'board :world 'closed :arguments '((state state) (x dimension) (y dimension) (tile tile !)))
  (predicate 'goal :world 'closed :arguments '((state state) (x dimension) (y dimension) (tile tile !)))
  (predicate 'success :world 'closed :arguments '((state state)))

  (init-operators 'type 'tile)

  (conditional 'left-acceptable
               :conditions '((state (state (s)))
                             (board (state (s)) (x (x)) (y (y)) (tile (t)))
                             (board (state (s)) (x (x -1)) (y (y)) (tile 0))
                             )
               :actions '((selected (state (s)) (operator (t))))
               :function .1
               )

  (conditional 'right-acceptable
               :conditions '((state (state (s)))
                             (board (state (s)) (x (x)) (y (y)) (tile (t)))
                             (board (state (s)) (x (x 1)) (y (y)) (tile 0))
                             )
               :actions '((selected (state (s)) (operator (t))))
               :function .1
               )

  (conditional 'up-acceptable
               :conditions '((state (state (s)))
                             (board (state (s)) (x (x)) (y (y)) (tile (t)))
                             (board (state (s)) (x (x)) (y (y -1)) (tile 0))
                             )
               :actions '((selected (state (s)) (operator (t))))
               :function .1
               )

  (conditional 'down-acceptable
               :conditions '((state (state (s)))
                             (board (state (s)) (x (x)) (y (y)) (tile (t)))
                             (board (state (s)) (x (x)) (y (y 1)) (tile 0))
                             )
               :actions '((selected (state (s)) (operator (t))))
               :function .1
               )

  (conditional 'move-left ; Move tile left (and blank right)
               :conditions '((state (state (s)))
                             (selected (state (s)) (operator (t)))
                             (board (state (s)) (x (x)) (y (y)) (tile (t)))
                             (board (state (s)) (x (x -1)) (y (y)) (tile 0))
                             )
               :actions '((board (state (s)) (x (x)) (y (y)) (tile 0))
                          (board (state (s)) (x (x -1)) (y (y)) (tile (t)))
                          )
               )

  (conditional 'move-right ; Move tile right (and blank left)
               :conditions '((state (state (s)))
                             (selected (state (s)) (operator (t)))
                             (board (state (s)) (x (x)) (y (y)) (tile (t)))
                             (board (state (s)) (x (x 1)) (y (y)) (tile 0))
                             )
               :actions '((board (state (s)) (x (x)) (y (y)) (tile 0))
                          (board (state (s)) (x (x 1)) (y (y)) (tile (t)))
                          )
               )

  (conditional 'move-up ; Move tile up (and blank down)
               :conditions '((state (state (s)))
                             (selected (state (s)) (operator (t)))
                             (board (state (s)) (x (x)) (y (y)) (tile (t)))
                             (board (state (s)) (x (x)) (y (y -1)) (tile 0))
                             )
               :actions '((board (state (s)) (x (x)) (y (y)) (tile 0))
                          (board (state (s)) (x (x)) (y (y -1)) (tile (t)))
                          )
               )

  (conditional 'move-down ; Move tile down (and blank up)
               :conditions '((state (state (s)))
                             (selected (state (s)) (operator (t)))
                             (board (state (s)) (x (x)) (y (y)) (tile (t)))
                             (board (state (s)) (x (x)) (y (y 1)) (tile 0))
                             )
               :actions '((board (state (s)) (x (x)) (y (y)) (tile 0))
                          (board (state (s)) (x (x)) (y (y 1)) (tile (t)))
                          )
               )

  (conditional 'goal-left-best ; Make left operator best that moves tile into goal location
               :conditions '((state (state (s)))
                             (board (state (s)) (x (x)) (y (y)) (tile (t)))
                             (board (state (s)) (x (x -1)) (y (y)) (tile 0))
                             (goal (state (s)) (x (x -1)) (y (y)) (tile (t)))
                             )
               :actions '((selected (state (s)) (operator (t))))
               )

  (conditional 'goal-right-best ; Make right operator best that moves tile into goal location
               :conditions '((state (state (s)))
                             (board (state (s)) (x (x)) (y (y)) (tile (t)))
                             (board (state (s)) (x (x 1)) (y (y)) (tile 0))
                             (goal (state (s)) (x (x 1)) (y (y)) (tile (t)))
                             )
               :actions '((selected (state (s)) (operator (t))))
               )

  (conditional 'goal-up-best ; Make up operator best that moves tile into goal location
               :conditions '((state (state (s)))
                             (board (state (s)) (x (x)) (y (y)) (tile (t)))
                             (board (state (s)) (x (x)) (y (y -1)) (tile 0))
                             (goal (state (s)) (x (x)) (y (y -1)) (tile (t)))
                             )
               :actions '((selected (state (s)) (operator (t))))
               )

  (conditional 'goal-down-best ; Make down operator best that moves tile into goal location
               :conditions '((state (state (s)))
                             (board (state (s)) (x (x)) (y (y)) (tile (t)))
                             (board (state (s)) (x (x)) (y (y 1)) (tile 0))
                             (goal (state (s)) (x (x)) (y (y 1)) (tile (t)))
                             )
               :actions '((selected (state (s)) (operator (t))))
               )

  (conditional 'goal-reject ; Reject an operator that moves a tile from its desired location
               :conditions '((state (state (s)))
                             (goal (state (s)) (x (x)) (y (y)) (tile (t)))
                             (board (state (s)) (x (x)) (y (y)) (tile (t)))
                             )
               :actions '((selected - (state (s)) (operator (t))))
               )

  (conditional 'goal-test
               :conditions '((state (state (s)))
                             (board (state (s)) (x (x1)) (y (y1)) (tile 1))
                             (goal (state (s)) (x (x1)) (y (y1)) (tile 1))
                             (board (state (s)) (x (x2)) (y (y2)) (tile 2))
                             (goal (state (s)) (x (x2)) (y (y2)) (tile 2))
                             (board (state (s)) (x (x3)) (y (y3)) (tile 3))
                             (goal (state (s)) (x (x3)) (y (y3)) (tile 3))
                             (board (state (s)) (x (x4)) (y (y4)) (tile 4))
                             (goal (state (s)) (x (x4)) (y (y4)) (tile 4))
                             (board (state (s)) (x (x5)) (y (y5)) (tile 5))
                             (goal (state (s)) (x (x5)) (y (y5)) (tile 5))
                             (board (state (s)) (x (x6)) (y (y6)) (tile 6))
                             (goal (state (s)) (x (x6)) (y (y6)) (tile 6))
                             (board (state (s)) (x (x7)) (y (y7)) (tile 7))
                             (goal (state (s)) (x (x7)) (y (y7)) (tile 7))
                             (board (state (s)) (x (x8)) (y (y8)) (tile 8))
                             (goal (state (s)) (x (x8)) (y (y8)) (tile 8))
                             )
               :actions '((success (state (s)))
                          )
               )

  (conditional 'halt
               :conditions '((success (state 0)))
               :actions '((halt))
               )
  t)

(defun ep8 (&optional el)
;  (learn)
  (ep8i el)
  (ep7e)
  t)

(defun ep82 (&optional el)
;  (learn)
  (ep8i el)
  (ep7e2)
  t)

; See when episodically learned operators are retrieved
(defun ep82e (&optional retrieval-cycles)
  (ep8i t)
  (ep7e2)
  (d 7)
  (learn)
  (conditional 'suggest-episodic-operator
               :conditions '((selected*episodic (state (s)) (operator (o))))
               :actions '((selected (state (s)) (operator (o))))
               )
  (ep7e2)
  (evidence '((success - (state *)) (halt -)))
  (when retrieval-cycles
    (d retrieval-cycles)
    )
  )

(defun test-eight-puzzle (&optional el)
  (ep82 el)
  (d 10)
  (when episodic-learning
    (format info-stream "~&~%")
    (pa 'time-board*episodic-learn nil '((constant wm-state 0) (argmax wm-tile)))
    (pa 'time-selected*episodic-learn nil '((constant wm-state 0)))
    )
  )

(defun test-print-eight-puzzle ()
  (test-eight-puzzle)
  (pa 'board t))

(defun ep83 (&optional el)
;  (learn)
  (ep8i el)
  (ep7e3)
  t)

; A program for the Eight Puzzle based on a 2D board
; Gradient ascent based on comparison of board and goal
(defun ep9i (&optional el) ; Whether to do episodic learning
  (init)
  (setq gdl-subtractive-normalization nil)
  (when el
    (learn '(:e))
;    (setq trace-gdl '(time-selected*episodic-learn time-cff))
    )

  (setq post-d '((ppfn 'selected nil '((max wm-state) (argmax wm-operator)))
                 (format trace-stream "~&~%State 0:~&")
                 (pepb 0)
                 (when (> bottom-state 0)
                   (ppwm 'operator-evaluation)
                   )
                 (when (> bottom-state 1)
                   (format trace-stream "~&~%State 2:~&")
                   (pepb 2)
                   (ppwm 'state-evaluation)
                   )
                 (when episodic-learning
                   (format trace-stream "~&~%Episodic memory:~%")
                   (pa 'time)
                   (format trace-stream "~&~%")
                   (parray 'time-selected*episodic-learn)
                   (format trace-stream "~&~%Operator retrieved from episodic memory:~%")
                   (ppvn 'selected*episodic)
                   )
                 )
        )

  (new-type 'dimension :numeric t :min 0 :max 3)
  (new-type 'tile :numeric t :discrete t :min 0 :max 9)

  (init-operators 'type 'tile t)

  (predicate 'board :world 'closed :arguments '((state state) (x dimension) (y dimension) (tile tile !)))
  (predicate 'board*e :arguments '((state state) (x dimension %) (y dimension %) (tile tile %)))
  (predicate 'goal :world 'closed :arguments '((state state) (x dimension) (y dimension) (tile tile !)))
  (predicate 'goal*e :arguments '((state state) (x dimension %) (y dimension %) (tile tile %)))
  (predicate 'success :world 'closed :arguments '((state state)))
  (predicate 'state-evaluation :arguments '((state state)))
  (predicate 'operator-evaluation :world 'closed :no-normalize t :arguments '((state state) (operator operator %)))
  (predicate 'completed :world 'closed :arguments '((state state) (operator operator)))
  (predicate 'simulated :world 'closed :arguments '((state state) (operator operator) (status flag !))) ; Flag added so can't chain on it until decision

  (conditional 'left-acceptable
               :conditions '((state (state (s)))
                             (board (state (s)) (x (x)) (y (y)) (tile (t)))
                             (board (state (s)) (x (x -1)) (y (y)) (tile 0))
                             (operator (tile (t)) (operator (o)))
                             )
               :actions '((selected (state (s)) (operator (o))))
               :function .1
               )

  (conditional 'right-acceptable
               :conditions '((state (state (s)))
                             (board (state (s)) (x (x)) (y (y)) (tile (t)))
                             (board (state (s)) (x (x 1)) (y (y)) (tile 0))
                             (operator (tile (t)) (operator (o)))
                             )
               :actions '((selected (state (s)) (operator (o))))
               :function .1
               )

  (conditional 'up-acceptable
               :conditions '((state (state (s)))
                             (board (state (s)) (x (x)) (y (y)) (tile (t)))
                             (board (state (s)) (x (x)) (y (y -1)) (tile 0))
                             (operator (tile (t)) (operator (o)))
                             )
               :actions '((selected (state (s)) (operator (o))))
               :function .1
               )

  (conditional 'down-acceptable
               :conditions '((state (state (s)))
                             (board (state (s)) (x (x)) (y (y)) (tile (t)))
                             (board (state (s)) (x (x)) (y (y 1)) (tile 0))
                             (operator (tile (t)) (operator (o)))
                             )
               :actions '((selected (state (s)) (operator (o))))
               :function .1
               )

  (conditional 'move-left ; Move tile left (and blank right)
               :conditions '((state (state (s)))
                             (selected (state (s)) (operator (o)))
                             (operator (tile (t)) (operator (o)))
                             (board (state (s)) (x (x)) (y (y)) (tile (t)))
                             (board (state (s)) (x (x -1)) (y (y)) (tile 0))
                             )
               :actions '((board (state (s)) (x (x)) (y (y)) (tile 0))
                          (board (state (s)) (x (x -1)) (y (y)) (tile (t)))
                          )
               )

  (conditional 'move-right ; Move tile right (and blank left)
               :conditions '((state (state (s)))
                             (selected (state (s)) (operator (o)))
                             (operator (tile (t)) (operator (o)))
                             (board (state (s)) (x (x)) (y (y)) (tile (t)))
                             (board (state (s)) (x (x 1)) (y (y)) (tile 0))
                             )
               :actions '((board (state (s)) (x (x)) (y (y)) (tile 0))
                          (board (state (s)) (x (x 1)) (y (y)) (tile (t)))
                          )
               )

  (conditional 'move-up ; Move tile up (and blank down)
               :conditions '((state (state (s)))
                             (selected (state (s)) (operator (o)))
                             (operator (tile (t)) (operator (o)))
                             (board (state (s)) (x (x)) (y (y)) (tile (t)))
                             (board (state (s)) (x (x)) (y (y -1)) (tile 0))
                             )
               :actions '((board (state (s)) (x (x)) (y (y)) (tile 0))
                          (board (state (s)) (x (x)) (y (y -1)) (tile (t)))
                          )
               )

  (conditional 'move-down ; Move tile down (and blank up)
               :conditions '((state (state (s)))
                             (selected (state (s)) (operator (o)))
                             (operator (tile (t)) (operator (o)))
                             (board (state (s)) (x (x)) (y (y)) (tile (t)))
                             (board (state (s)) (x (x)) (y (y 1)) (tile 0))
                             )
               :actions '((board (state (s)) (x (x)) (y (y)) (tile 0))
                          (board (state (s)) (x (x)) (y (y 1)) (tile (t)))
                          )
               )

  (conditional 'goal-test
               :conditions '((state (state (s)))
                             (board (state (s)) (x (x1)) (y (y1)) (tile 1))
                             (goal (state (s)) (x (x1)) (y (y1)) (tile 1))
                             (board (state (s)) (x (x2)) (y (y2)) (tile 2))
                             (goal (state (s)) (x (x2)) (y (y2)) (tile 2))
                             (board (state (s)) (x (x3)) (y (y3)) (tile 3))
                             (goal (state (s)) (x (x3)) (y (y3)) (tile 3))
                             (board (state (s)) (x (x4)) (y (y4)) (tile 4))
                             (goal (state (s)) (x (x4)) (y (y4)) (tile 4))
                             (board (state (s)) (x (x5)) (y (y5)) (tile 5))
                             (goal (state (s)) (x (x5)) (y (y5)) (tile 5))
                             (board (state (s)) (x (x6)) (y (y6)) (tile 6))
                             (goal (state (s)) (x (x6)) (y (y6)) (tile 6))
                             (board (state (s)) (x (x7)) (y (y7)) (tile 7))
                             (goal (state (s)) (x (x7)) (y (y7)) (tile 7))
                             (board (state (s)) (x (x8)) (y (y8)) (tile 8))
                             (goal (state (s)) (x (x8)) (y (y8)) (tile 8))
                             )
               :actions '((success (state (s)))
                          )
               )

  ; Make evaluation operators best in subgoal for tied operators
  (conditional 'evaluate-best
               :conditions '((state (state (s)))
                             (impasse (state (s)) (type tie) (operator (o)))
                             (evaluate-operator (operator (eo)) (evaluate (o)))
                             )
               :actions '((selected (state (s)) (operator (eo))))
               )

  ;Reject completed evaluation operators
  (conditional 'evaluate-reject
               :conditions '((state (state (s)))
                             (impasse (state (s)) (type tie) (operator (o)))
                             (evaluate-operator (operator (eo)) (evaluate (o)))
                             (completed (state (s)) (operator (eo)))
                             )
               :actions '((selected - (state (s)) (operator (eo))))
               )

  ; Make operator to be evaluated best in no-change for evaluation operator
  (conditional 'evaluation-operator-best
               :conditions '((state (state (s)))
                             (impasse (state (s)) (type no-change) (operator (eo)))
                             (evaluate-operator (operator (eo)) (evaluate (o))))
               :actions '((selected (state (s)) (operator (o))))
               )

  ; Copy down board for use in evaluation
  (conditional 'evaluation-board
               :conditions '((state (state (s)))
                             (impasse (state (s)) (type no-change) (operator (eo)))
                             (evaluate-operator (operator (eo)))
                             (impasse (state (s -1)) (type tie))
                             (board (state (s -2)) (x (x)) (y (y)) (tile (t)))
                             (board - (state (s)))
                             )
               :actions '((board (state (s)) (x (x)) (y (y)) (tile (t))))
               )

  ; Copy down goals for use in evaluation
  (conditional 'evaluation-goal
               :conditions '((state (state (s)))
                             (impasse (state (s)) (type no-change) (operator (eo)))
                             (evaluate-operator (operator (eo)))
                             (impasse (state (s -1)) (type tie))
                             (goal (state (s -2)) (x (x)) (y (y)) (tile (t)))
                             )
               :actions '((goal (state (s)) (x (x)) (y (y)) (tile (t))))
               )

  ; Convert board into all unique for evaluation
  (conditional 'board-unique
               :conditions '((board (state (s)) (x (x)) (y (y)) (tile (t))))
               :condacts '((board*e (state (s)) (x (x)) (y (y)) (tile (t))))
               )

  ; Convert goal into all unique for evaluation
  (conditional 'goal-unique
               :conditions '((goal (state (s)) (x (x)) (y (y)) (tile (t))))
               :condacts '((goal*e (state (s)) (x (x)) (y (y)) (tile (t))))
               )

  ; Mark that simulated operator has run
  (conditional 'operator-simulated
               :conditions '((state (state (s)))
                             (selected (state (s)) (operator (o)))
                             (impasse (state (s)) (type no-change) (operator (eo)))
                             (evaluate-operator (evaluate (eo)) (operator (o)))
                             )
               :actions '((simulated (state (s)) (operator (o)) (status true)))
               )
               

  ; Compute an evaluation for a state by comparing with goal and summarizing everything out
  (conditional 'evaluate-state
               :conditions '((state (state (s)))
                             (board*e (state (s)) (x (x)) (y (y)) (tile (t)))
                             (goal*e (state (s)) (x (x)) (y (y)) (tile (t)))
                             )
               :actions '((state-evaluation (state (s))))
               )

  ; When operator simulated, return evaluation
  (conditional 'return-state-evaluation
               :conditions '((state (state (s)))
                             (simulated (state (s)) (operator (o)) (status true))
                             (state-evaluation (state (s)))
                             (impasse (state (s)) (type no-change) (operator (eo)))
                             (evaluate-operator (evaluate (o)) (operator (eo)))
                             (selected (state (s -1)) (operator (eo)))
                             )
               :actions '((operator-evaluation (state (s -1)) (operator (o))))
               )

  ; When operator simulated, return completion
  (conditional 'return-completion
               :conditions '((state (state (s)))
                             (simulated (state (s)) (operator (o)) (status true))
                             (impasse (state (s)) (type no-change) (operator (eo)))
                             (evaluate-operator (evaluate (o)) (operator (eo)))
                             (selected (state (s -1)) (operator (eo)))
                             )
               :actions '((completed (state (s -1)) (operator (eo))))
               )

  ; Return evaluations on offer operators once they have all been evaluated
  (conditional 'return-operator-evaluations
               :conditions '((state (state (s)))
                             (impasse (state (s)) (type tie) (operator (o)))
                             (impasse (state (s 1)) (type none))
                             (operator-evaluation (state (s)) (operator (o)))
                             )
               :actions '((selected (state (s -1)) (operator (o)))
                          )
               )

  ; Return evaluations on offer operators once they have all been evaluated
  (conditional 'select-randomly-after-impasse
               :conditions '((state (state (s)))
                             (impasse (state (s)) (type tie) (operator (o)))
                             (impasse (state (s 1)) (type none))
                             )
               :actions '((detect-impasses - (state (s -1)) (value true))
                          )
               )

  (conditional 'halt
               :conditions '((success (state 0)))
               :actions '((halt))
               )
  t)

(defun ep9 (&optional el)
;  (learn)
  (ep9i el)
  (ep7e)
  t)

(defun ep92 (&optional el)
;  (learn)
  (ep9i el)
  (ep7e2)
  t)

(defun ep93 (&optional el)
;  (learn)
  (ep9i el)
  (ep7e3)
  t)

;-----------
; A program for the Eight Puzzle based on a 2D board
; Gradient ascent based on automated comparison of board and goal
(defun ep10i (&optional el) ; Whether to do episodic learning
  (init)
  (setq compute-progress t)
  (setq trace-attention t)
  (setq gdl-subtractive-normalization nil)
  (when el
    (learn '(:e))
;    (setq trace-gdl '(time-selected*episodic-learn time-cff))
    )

  (setq post-d '((ppfn 'selected nil '((argmax wm-operator)))
                 (format trace-stream "~&~%State 0:~&")
                 (pepb 0)
                 (when (> bottom-state 0)
                   (ppwm 'operator-evaluation)
                   )
                 (when (> bottom-state 1)
                   (format trace-stream "~&~%State 2:~&")
                   (pepb 2)
                   (format t "State evaluation: ")
                   (pa (integrate-out-all-but-state-dimension-plm (node-function (perception-node-from-name 'board*progress))))
                   )
                 (when episodic-learning
                   (format trace-stream "~&~%Episodic memory:~%")
                   (pa 'time)
                   (format trace-stream "~&~%")
                   (parray 'time-selected*episodic-learn)
                   (format trace-stream "~&~%Operator retrieved from episodic memory:~%")
                   (ppvn 'selected*episodic)
                   )
                 )
        )

  (new-type 'dimension :numeric t :min 0 :max 3)
  (new-type 'tile :numeric t :discrete t :min 0 :max 9)

  (init-operators 'type 'tile t)

  (predicate 'board :world 'closed :arguments '((state state) (x dimension) (y dimension) (tile tile !))
             :goal '((board*goal (state 0) (x 0) (y 0) (tile 1))
                     (board*goal (state 0) (x 1) (y 0) (tile 2))
                     (board*goal (state 0) (x 2) (y 0) (tile 3))
                     (board*goal (state 0) (x 0) (y 1) (tile 8))
;                    (board*goal (state 0) (x 1) (y 1) (tile 0))
                     (board*goal (state 0) (x 2) (y 1) (tile 4))
                     (board*goal (state 0) (x 0) (y 2) (tile 7))
                     (board*goal (state 0) (x 1) (y 2) (tile 6))
                     (board*goal (state 0) (x 2) (y 2) (tile 5))
                     ))
; Goal
; 123
; 8 4
; 765

  (predicate 'success :world 'closed :arguments '((state state)))
  (predicate 'operator-evaluation :world 'closed :no-normalize t :arguments '((state state) (operator operator %)))
  (predicate 'completed :world 'closed :arguments '((state state) (operator operator)))
  (predicate 'simulated :world 'closed :arguments '((state state) (operator operator) (status flag !))) ; Flag added so can't chain on it until decision

  (conditional 'left-acceptable
               :conditions '((state (state (s)))
                             (board (state (s)) (x (x)) (y (y)) (tile (t)))
                             (board (state (s)) (x (x -1)) (y (y)) (tile 0))
                             (operator (tile (t)) (operator (o)))
                             )
               :actions '((selected (state (s)) (operator (o))))
               :function .1
               )

  (conditional 'right-acceptable
               :conditions '((state (state (s)))
                             (board (state (s)) (x (x)) (y (y)) (tile (t)))
                             (board (state (s)) (x (x 1)) (y (y)) (tile 0))
                             (operator (tile (t)) (operator (o)))
                             )
               :actions '((selected (state (s)) (operator (o))))
               :function .1
               )

  (conditional 'up-acceptable
               :conditions '((state (state (s)))
                             (board (state (s)) (x (x)) (y (y)) (tile (t)))
                             (board (state (s)) (x (x)) (y (y -1)) (tile 0))
                             (operator (tile (t)) (operator (o)))
                             )
               :actions '((selected (state (s)) (operator (o))))
               :function .1
               )

  (conditional 'down-acceptable
               :conditions '((state (state (s)))
                             (board (state (s)) (x (x)) (y (y)) (tile (t)))
                             (board (state (s)) (x (x)) (y (y 1)) (tile 0))
                             (operator (tile (t)) (operator (o)))
                             )
               :actions '((selected (state (s)) (operator (o))))
               :function .1
               )

  (conditional 'move-left ; Move tile left (and blank right)
               :conditions '((state (state (s)))
                             (selected (state (s)) (operator (o)))
                             (operator (tile (t)) (operator (o)))
                             (board (state (s)) (x (x)) (y (y)) (tile (t)))
                             (board (state (s)) (x (x -1)) (y (y)) (tile 0))
                             )
               :actions '((board (state (s)) (x (x)) (y (y)) (tile 0))
                          (board (state (s)) (x (x -1)) (y (y)) (tile (t)))
                          )
               )

  (conditional 'move-right ; Move tile right (and blank left)
               :conditions '((state (state (s)))
                             (selected (state (s)) (operator (o)))
                             (operator (tile (t)) (operator (o)))
                             (board (state (s)) (x (x)) (y (y)) (tile (t)))
                             (board (state (s)) (x (x 1)) (y (y)) (tile 0))
                             )
               :actions '((board (state (s)) (x (x)) (y (y)) (tile 0))
                          (board (state (s)) (x (x 1)) (y (y)) (tile (t)))
                          )
               )

  (conditional 'move-up ; Move tile up (and blank down)
               :conditions '((state (state (s)))
                             (selected (state (s)) (operator (o)))
                             (operator (tile (t)) (operator (o)))
                             (board (state (s)) (x (x)) (y (y)) (tile (t)))
                             (board (state (s)) (x (x)) (y (y -1)) (tile 0))
                             )
               :actions '((board (state (s)) (x (x)) (y (y)) (tile 0))
                          (board (state (s)) (x (x)) (y (y -1)) (tile (t)))
                          )
               )

  (conditional 'move-down ; Move tile down (and blank up)
               :conditions '((state (state (s)))
                             (selected (state (s)) (operator (o)))
                             (operator (tile (t)) (operator (o)))
                             (board (state (s)) (x (x)) (y (y)) (tile (t)))
                             (board (state (s)) (x (x)) (y (y 1)) (tile 0))
                             )
               :actions '((board (state (s)) (x (x)) (y (y)) (tile 0))
                          (board (state (s)) (x (x)) (y (y 1)) (tile (t)))
                          )
               )

  (conditional 'goal-test
               :conditions '((state (state (s)))
                             (board (state (s)) (x (x1)) (y (y1)) (tile 1))
                             (board*goal (state (s)) (x (x1)) (y (y1)) (tile 1))
                             (board (state (s)) (x (x2)) (y (y2)) (tile 2))
                             (board*goal (state (s)) (x (x2)) (y (y2)) (tile 2))
                             (board (state (s)) (x (x3)) (y (y3)) (tile 3))
                             (board*goal (state (s)) (x (x3)) (y (y3)) (tile 3))
                             (board (state (s)) (x (x4)) (y (y4)) (tile 4))
                             (board*goal (state (s)) (x (x4)) (y (y4)) (tile 4))
                             (board (state (s)) (x (x5)) (y (y5)) (tile 5))
                             (board*goal (state (s)) (x (x5)) (y (y5)) (tile 5))
                             (board (state (s)) (x (x6)) (y (y6)) (tile 6))
                             (board*goal (state (s)) (x (x6)) (y (y6)) (tile 6))
                             (board (state (s)) (x (x7)) (y (y7)) (tile 7))
                             (board*goal (state (s)) (x (x7)) (y (y7)) (tile 7))
                             (board (state (s)) (x (x8)) (y (y8)) (tile 8))
                             (board*goal (state (s)) (x (x8)) (y (y8)) (tile 8))
                             )
               :actions '((success (state (s)))
                          )
               )

  ; Make evaluation operators best in subgoal for tied operators
  (conditional 'evaluate-best
               :conditions '((state (state (s)))
                             (impasse (state (s)) (type tie) (operator (o)))
                             (evaluate-operator (operator (eo)) (evaluate (o)))
                             )
               :actions '((selected (state (s)) (operator (eo))))
               )

  ;Reject completed evaluation operators
  (conditional 'evaluate-reject
               :conditions '((state (state (s)))
                             (impasse (state (s)) (type tie) (operator (o)))
                             (evaluate-operator (operator (eo)) (evaluate (o)))
                             (completed (state (s)) (operator (eo)))
                             )
               :actions '((selected - (state (s)) (operator (eo))))
               )

  ; Make operator to be evaluated best in no-change for evaluation operator
  (conditional 'evaluation-operator-best
               :conditions '((state (state (s)))
                             (impasse (state (s)) (type no-change) (operator (eo)))
                             (evaluate-operator (operator (eo)) (evaluate (o))))
               :actions '((selected (state (s)) (operator (o))))
               )

  ; Copy down board for use in evaluation
  (conditional 'evaluation-board
               :conditions '((state (state (s)))
                             (impasse (state (s)) (type no-change) (operator (eo)))
                             (evaluate-operator (operator (eo)))
                             (impasse (state (s -1)) (type tie))
                             (board (state (s -2)) (x (x)) (y (y)) (tile (t)))
                             (board - (state (s)))
                             )
               :actions '((board (state (s)) (x (x)) (y (y)) (tile (t))))
               )

  ; Copy down goal for use in evaluation
  (conditional 'evaluation-goal
               :conditions '((state (state (s)))
                             (impasse (state (s)) (type no-change) (operator (eo)))
                             (evaluate-operator (operator (eo)))
                             (impasse (state (s -1)) (type tie))
                             (board*goal (state (s -2)) (x (x)) (y (y)) (tile (t)))
                             )
               :actions '((board*goal (state (s)) (x (x)) (y (y)) (tile (t))))
               )

  ; Mark that simulated operator has run
  (conditional 'operator-simulated
               :conditions '((state (state (s)))
                             (selected (state (s)) (operator (o)))
                             (impasse (state (s)) (type no-change) (operator (eo)))
                             (evaluate-operator (evaluate (eo)) (operator (o)))
                             )
               :actions '((simulated (state (s)) (operator (o)) (status true)))
               )

  ; When operator simulated, return evaluation
  (conditional 'return-state-evaluation
               :conditions '((state (state (s)))
                             (simulated (state (s)) (operator (o)) (status true))
                             (board*progress (state (s)))
                             (impasse (state (s)) (type no-change) (operator (eo)))
                             (evaluate-operator (evaluate (o)) (operator (eo)))
                             (selected (state (s -1)) (operator (eo)))
                             )
               :actions '((operator-evaluation (state (s -1)) (operator (o))))
               )

  ; When operator simulated, return completion
  (conditional 'return-completion
               :conditions '((state (state (s)))
                             (simulated (state (s)) (operator (o)) (status true))
                             (impasse (state (s)) (type no-change) (operator (eo)))
                             (evaluate-operator (evaluate (o)) (operator (eo)))
                             (selected (state (s -1)) (operator (eo)))
                             )
               :actions '((completed (state (s -1)) (operator (eo))))
               )

  ; Return evaluations on offer operators once they have all been evaluated
  (conditional 'return-operator-evaluations
               :conditions '((state (state (s)))
                             (impasse (state (s)) (type tie) (operator (o)))
                             (impasse (state (s 1)) (type none))
                             (operator-evaluation (state (s)) (operator (o)))
                             )
               :actions '((selected (state (s -1)) (operator (o)))
                          )
               )

  ; Return evaluations on offer operators once they have all been evaluated
  (conditional 'select-randomly-after-impasse
               :conditions '((state (state (s)))
                             (impasse (state (s)) (type tie) (operator (o)))
                             (impasse (state (s 1)) (type none))
                             )
               :actions '((detect-impasses - (state (s -1)) (value true))
                          )
               )

  (conditional 'halt
               :conditions '((success (state 0)))
               :actions '((halt))
               )
  t)

(defun ep102 (&optional el)
;  (learn)
  (ep10i el)
; Board
; 123
; 845
; 7 6
  (evidence '((board (state 0) (x 0) (y 0) (tile 1))
              (board (state 0) (x 1) (y 0) (tile 2))
              (board (state 0) (x 2) (y 0) (tile 3))
              (board (state 0) (x 0) (y 1) (tile 8))
              (board (state 0) (x 1) (y 1) (tile 4))
              (board (state 0) (x 2) (y 1) (tile 5))
              (board (state 0) (x 0) (y 2) (tile 7))
              (board (state 0) (x 1) (y 2) (tile 0))
              (board (state 0) (x 2) (y 2) (tile 6))))
  t)


; A program for testing state adjacency
(defun sa nil
  (init)
  (new-type 'value :constants '(a b))

  (predicate 'test :world 'closed :arguments '((state state) (value value !)))
  (predicate 'result :world 'closed :arguments '((state state) (value value)))

  (conditional 'test-sa-condition
               :conditions '((test (state (state)) (value (value)))
                             (test (state (state 1)) (value (value)))
                             )
               :actions '((result (state (state)) (value (value)))
                          )
               )

;  (conditional 'test-sa-action
;               :conditions '((test (state (state)) (value (value))))
;               :actions '((result (state (state -4)) (value (value))))
;               )

  (evidence '((test (state 0) (value a))
              (test (state 1) (value a))
              (test (state 2) (value b))
              (test (state 3) (value b))
              )
            )
  t)

; A program for detecting overlap of 8P tiles
(defun o1i nil
  (init)

  (new-type 'dimension :numeric t :min 0 :max 3)
  (new-type 'tile :numeric t :discrete t :min 0 :max 9)

  (predicate 'board :world 'closed :arguments '((state state) (x dimension) (y dimension) (tile tile)))
  (predicate 'overlap :world 'closed :arguments '((state state)))

  (conditional 'overlap
               :conditions '((board (state (s)) (x (x)) (y (y)) (tile 1))
                             (board (state (s)) (x (x)) (y (y)) (tile 2))
                             )
               :actions '((overlap (state (s)))
                          )
               )
  )

; Tiles not overlapping
(defun o1e nil
  (evidence '((board (state 0) (x 0) (y 0) (tile 1))
              (board (state 0) (x 1) (y 0) (tile 2))
              )
            )
  )

; Tiles  overlapping
(defun o1e2 nil
  (evidence '((board (state 0) (x 0) (y 0) (tile 1))
              (board (state 0) (x .5) (y 0) (tile 2))
              )
            )
  )

(defun o1 nil
  (o1i)
  (o1e)
  t)

(defun o12 nil
  (o1i)
  (o1e2)
  t)

; Test affine (with a tetromino), but with empty space actually empty
(defun test-affine nil
  (init)
  (new-type 'c4 :numeric t :discrete nil :min 0 :max 4)
  (predicate 'tetromino :world 'closed :arguments '((x c4) (y c4) (present boolean !)))

  (conditional 'rotate-90
               :conditions '((tetromino (x (x)) (y (y)) (present true)))
               :actions '((tetromino (x (y (:coefficient -1 :offset 4))) (y (x)) (present true)))
               )
  (conditional 'rotate-90-cond
               :conditions '((tetromino (x (x (:from y :coefficient -1 :offset 4))) (y (y (:from x))) (present true)))
               )

  (conditional 'reflect-x
               :conditions '((tetromino (x (x)) (y 1) (present true)))
               :actions '((tetromino (x (x (:coefficient -1 :offset 4))) (y 1) (present true)))
               )
  (conditional 'reflect-x-cond
               :conditions '((tetromino (x (x (:coefficient -1 :offset 4))) (y 1) (present true)))
               )

  (conditional 'scale-half
               :conditions '((tetromino (x (x)) (y 1) (present true)))
               :actions '((tetromino (x (x (:coefficient 1/2))) (y 1) (present true)))
               )
  (conditional 'scale-half-cond
               :conditions '((tetromino (x (x (:coefficient 1/2))) (y 1) (present true)))
               )

  (conditional 'scale-double
               :conditions '((tetromino (x (x)) (y 1) (present true)))
               :actions '((tetromino (x (x (:coefficient 2))) (y (y)) (present true)))
               )

  (conditional 'translate-2
               :conditions '((tetromino (x (x)) (y 1) (present true)))
               :actions '((tetromino (x (x 2)) (y 1) (present true)))
               )
  (conditional 'translate-2-cond
               :conditions '((tetromino (x (x 2)) (y 1) (present true)))
               )

  (conditional 'translate-2a
               :conditions '((tetromino (x (x)) (y 1) (present true)))
               :actions '((tetromino (x (x (:offset 2))) (y 1) (present true)))
               )
  (conditional 'translate-2a-cond
               :conditions '((tetromino (x (x (:offset 2))) (y 1) (present true)))
               )

  (conditional 'translate-minus-2
               :conditions '((tetromino (x (x)) (y 1) (present true)))
               :actions '((tetromino (x (x -2)) (y 1) (present true)))
               )
  (conditional 'translate-minus-2a
               :conditions '((tetromino (x (x)) (y 1) (present true)))
               :actions '((tetromino (x (x (:offset -2))) (y 1) (present true)))
               )

  (conditional 'scale-half-in-place
               :conditions '((tetromino (x (x)) (y (y)) (present true)))
               :actions '((tetromino (x (x (:coefficient 1/2 :offset 1))) (y (y)) (present true)))
               )
  (conditional 'scale-half-in-place-cond
               :conditions '((tetromino (x (x (:coefficient 1/2 :offset 1))) (y (y)) (present true)))
               )

; Z tetrimino
  (evidence '((tetromino (x (1/2 5/2)) (y 1) (present true))
              (tetromino (x (3/2 7/2)) (y 2) (present true))
              )
            )
  )

(defun xta nil
  (test-affine)
  (d 0)
  (g)
  nil
  )

; Test affine (with a tetromino), for just rotate in condition
(defun test-rotate-cond nil
  (init)
  (new-type 'c4 :numeric t :discrete nil :min 0 :max 4)
  (predicate 'tetromino :world 'closed :arguments '((x c4) (y c4) (present boolean !)))

  (conditional 'rotate-90-cond
               :conditions '((tetromino (x (x (:from y :coefficient -1 :offset 4))) (y (y (:from x))) (present true)))
               )

; Z tetrimino
  (evidence '((tetromino (x (1/2 5/2)) (y 1) (present true))
              (tetromino (x (3/2 7/2)) (y 2) (present true))
              )
            )
  )

(defun xtrc nil
  (test-rotate-cond)
  (d 0)
  (g)
  nil
  )

; Test affine (with a tetromino), variant without :from in action
(defun test-rotate-variant nil
  (init)
  (new-type 'c4 :numeric t :discrete nil :min 0 :max 4)
  (predicate 'tetromino :world 'closed :arguments '((x c4) (y c4) (present boolean !)))

  (conditional 'rotate-90
               :conditions '((tetromino (x (x)) (y (y)) (present true)))
               :actions '((tetromino (x (y (:coefficient -1 :offset 4))) (y (x)) (present true)))
               )

; Z tetrimino
  (evidence '((tetromino (x (1/2 5/2)) (y 1) (present true))
              (tetromino (x (3/2 7/2)) (y 2) (present true))
              )
            )
  )

(defun xtrv nil
  (test-rotate-variant)
  (d 0)
  (g)
  nil
  )

; Test operations on multiple tetrominos
(defun mt nil
  (init)
  (new-type 'c :numeric t :discrete nil :min 0 :max 7)
  (new-type 'd :numeric t :discrete t :min 0 :max 10)
  (predicate 'field :world 'closed :arguments '((ts d) (x c) (y c)))
  (predicate 'overlap :world 'closed :arguments '((os d) (x c) (y c)))
  (predicate 'collision :world 'closed :arguments '((os d) (value Boolean !)))
  (predicate 'union :world 'closed :arguments '((x c) (y c)))
  (predicate 'left-edge :world 'closed :arguments '((x c) (y c)))

  (setq post-d '((ppfn 'field) (ppfn 'overlap) (ppfn 'collision) (ppfn 'union) (ppfn 'left-edge)))

  ; Rotate Z tetromino in 0 and add it to 3, shifting it 2 down so overlaps slightly with original z
  (conditional 'add-rotate-shift-3
               :conditions '((field (ts 0) (x (x)) (y (y))))
               :actions '((field (ts 3) (x (y (:coefficient -1 :offset 4))) (y (x (:offset 2))))
                          )
               )
  
  ; Scale Z tetronimon add add it to 4, shifting it to the right
  (conditional 'add-invert-scale-shift-4
               :conditions '((field (ts 0) (x (x)) (y (y))))
               :actions '((field (ts 4) (x (x (:coefficient -1/2 :offset 6))) (y (y)))
                          )
               )

  ; Delete the tetromino in 1
  (conditional 'delete-1
               :actions '((field - (ts 1))
                          )
               )

  ; Compute overlap
  (conditional 'overlap-0-2
               :conditions '((field (ts 0) (x (x)) (y (y)))
                             (field (ts 2) (x (x)) (y (y)))
                             )
               :actions '((overlap (os 0) (x (x)) (y (y)))
                          )
               )

  ; Compute overlap
  (conditional 'overlap-0-3
               :conditions '((field (ts 0) (x (x)) (y (y)))
                             (field (ts 3) (x (x)) (y (y)))
                             )
               :actions '((overlap (os 1) (x (x)) (y (y)))
                          )
               )

  ; Compute overlap
  (conditional 'overlap-2-3
               :conditions '((field (ts 2) (x (x)) (y (y)))
                             (field (ts 3) (x (x)) (y (y)))
                             )
               :actions '((overlap (os 2) (x (x)) (y (y)))
                          )
               )

  ; Determine if there is any collision from overlap
  (conditional 'collision
               :conditions '((overlap (os (o)) (x (x)) (y (y))))
               :actions '((collision (os (o)) (value true)))
               )

  ; Compute union of all planes in field
  (conditional 'union
               :conditions '((field (ts (ts)) (x (x)) (y (y))))
               :actions '((union (x (x)) (y (y))))
               )

  ; Detect left edge of unioned image
  (conditional 'left-edge
              :conditions '((union (x (x)) (y (y)))
                            (union - (x (x (:offset -.0001))) (y (y)))
                            )
              :actions '((left-edge (x (x)) (y (y))))
              )

  ; Three Z tetriminos
  (evidence '((field (ts 0) (x (1/2 5/2)) (y 1))
              (field (ts 0) (x (3/2 7/2)) (y 2))

              (field (ts 1) (x (1/2 5/2)) (y 3))
              (field (ts 1) (x (3/2 7/2)) (y 4))

              (field (ts 2) (x (1/2 5/2)) (y 5))
              (field (ts 2) (x (3/2 7/2)) (y 6))

              )
            )
  )

(defun mt2 nil
  (init)
  (new-type 'c :numeric t :discrete nil :min 0 :max 7)
  (new-type 'd :numeric t :discrete t :min 0 :max 10)
  (predicate 'field :world 'closed :arguments '((ts d) (x c) (y c)))
  (predicate 'image :world 'closed :arguments '((x c) (y c)))
  (setq post-d '((ppfn 'field)))
  (conditional 'rotate-90
               :conditions '((field (ts 0) (x (x)) (y (y))))
               :actions '((field (ts 1) (x (y (:coefficient -1 :offset 4))) (y (x))))
               )

  (conditional 'rotate-90-cond
               :conditions '((field (ts 0) (x (x (:from y :coefficient -1 :offset 4))) (y (y (:from x)))))
               :actions '((field (ts 2) (x (x)) (y (y))))
               )

  (conditional 'rotate-90-condact
               :condacts '((image (x (x (:from y :coefficient -1 :offset 4))) (y (y (:from x)))))
               )

  (conditional 'reflect-x
               :conditions '((field (ts 0) (x (x)) (y (y))))
               :actions '((field (ts 3) (x (x (:coefficient -1 :offset 4))) (y (y))))
               )

  (conditional 'scale-half-in-place
               :conditions '((field (ts 0) (x (x)) (y (y))))
               :actions '((field (ts 4) (x (x (:coefficient 1/2 :offset 1))) (y (y))))
               )

  ; Two Z tetriminos
  (evidence '((field (ts 0) (x (1/2 5/2)) (y 1))
              (field (ts 0) (x (3/2 7/2)) (y 2))

              (image (x (1/2 5/2)) (y 1))
              (image (x (3/2 7/2)) (y 2))
              )
            )
  )

; Determine which object is above and below the other
(defun ab nil
  (init)
  (setq unique-weights-only nil)
  (new-type 'c :numeric t :discrete nil :min 0 :max 7)
  (new-type 'd :numeric t :discrete t :min 0 :max 10)
  (predicate 'field :world 'closed :arguments '((ts d) (x c) (y c)))
  (predicate 'below :world 'closed :arguments '((ts d !)))
  (predicate 'above :world 'closed :arguments '((ts d !)))

  (setq post-d '((ppfn 'below) (ppfn 'above)))

  (conditional 'below
               :conditions '((field (ts (ts)) (x (x)) (y (y (:filter (* 0 .1))))))
               :actions '((below (ts (ts))))
               )

  (conditional 'above
               :conditions '((field (ts (ts)) (x (x)) (y (y (:filter (* 1 -.1))))))
               :actions '((above (ts (ts))))
               )

  ; Two Z tetriminos
  (evidence '((field (ts 0) (x (1/2 5/2)) (y 1))
              (field (ts 0) (x (3/2 7/2)) (y 2))

              (field (ts 1) (y (0 2)) (x 1))
              (field (ts 1) (y (1 3)) (x 2))
              )
            )
  )

; Line detector
(defun line-detector nil
  (init)
  (new-type 'c4 :numeric t :discrete nil :min 0 :max 4)
  (predicate 'tetromino :world 'closed :arguments '((x c4) (y c4)))
  (predicate 'edge :world 'closed :arguments '((x c4) (y c4)))

  (setq post-d '((ppfn 'edge)))

  (conditional 'left-edge
               :conditions '((tetromino (x (x)) (y (y)))
                             (tetromino - (x (x -.00001)) (y (y)))
                             )
               :actions '((edge (x (x)) (y (y))))
               )

; Z tetrimino
  (evidence '((tetromino (x (1/2 5/2)) (y 1))
              (tetromino (x (3/2 7/2)) (y 2))
              )
            )
  )

; Line detector with noise
(defun line-detector-noise nil
  (init)
  (new-type 'c4 :numeric t :discrete nil :min 0 :max 4)
  (predicate 'object :world 'open :perception t :arguments '((x c4) (y c4)))
  (predicate 'edge :world 'open :perception t :arguments '((x c4) (y c4)))



  (conditional 'left-edge
               :conditions '((object (x (x)) (y (y)))
                             (object - (x (x -.00001)) (y (y)))
                             )
               :actions '((edge (x (x)) (y (y))))
               )

;  (conditional 'smooth-forward
;               :conditions '((edge (x (x)) (y (y))))
;               :actions '((edge (x (x)) (y (yd .2))))
;               :function-variable-names '(y yd)
;               :function .2
;               )

;  (conditional 'smooth-backward
;               :conditions '((edge (x (x)) (y (y))))
;               :actions '((edge (x (x)) (y (yd -.2))))
;               :function-variable-names '(y yd)
;               :function .2
;               )

  (conditional 'smooth
               :condacts '((edge (x (x)) (y (y)))
                           (edge (x (x)) (y (yd .2))))
               :function-variable-names '(y yd)
               :function .9
               )

; Object
  (setq perceive-list '((perceive '((object .01 (x (0 4)) (y (0 2)))
                                    (object .01 (x (0 1)) (y (2 3)))
                                    (object .99 (x (1 2)) (y (2 2.4)))
                                    (object .01 (x (1 1.0001)) (y (2.4 2.6)))
                                    (object .99 (x (1.0001 2)) (y (2.4 2.6)))
                                    (object .99 (x (1 2)) (y (2.6 3)))
                                    (object .01 (x (2 4)) (y (2 3)))
                                    (object .01 (x (0 4)) (y (3 4)))
                                    ))))
  )

(defun xldn nil
  (line-detector-noise)
  (d 0)
  (g)
  nil
  )

; Noisy line smoothing
(defun smooth nil
  (init)
  (new-type 'c9 :numeric t :discrete nil :min 0 :max 9)
  (predicate 'edge :world 'open :perception t :arguments '((x c9) (occupied Boolean %)))
  (predicate 'edge2 :world 'closed :arguments '((x c9)))

;  (conditional 'smooth-1
;               :condacts '((edge (x (x)) (occupied (o)))
;                           (edge (x (x .1)) (occupied (o))))
;               :function .5
;              )

  (conditional 'smooth-2
               :condacts '((edge (x (x)) (occupied (o)))
                           (edge (x (x .2)) (occupied (o))))
;               :function .25
              )

  (conditional 'smooth-3
               :condacts '((edge (x (x)) (occupied (o)))
                           (edge (x (x .3)) (occupied (o))))
;               :function .1
              )

  (conditional 'smooth-4
               :condacts '((edge (x (x)) (occupied (o)))
                           (edge (x (x .4)) (occupied (o))))
;               :function .05
              )

  (conditional 'result
               :conditions '((edge (x (x)) (occupied true)))
               :actions '((edge2 (x (x))))
               )

;  (conditional 'smooth
;               :condacts '((edge (x (x)))
;                           (edge (x (xo .2))))
;               :function-variable-names '(x xo)
;               :function .9
;               )

; edge
  (setq perceive-list '((perceive '((edge .05 (x (0 2)) (occupied true))
                                    (edge .95 (x (0 2)) (occupied false))
                                    (edge .95 (x (2 4.4)) (occupied true))
                                    (edge .05 (x (2 4.4)) (occupied false))
                                    (edge .05 (x (4.4 4.6)) (occupied true))
                                    (edge .95 (x (4.4 4.6)) (occupied false))
                                    (edge .95 (x (4.6 7)) (occupied true))
                                    (edge .05 (x (4.6 7)) (occupied false))
                                    (edge .05 (x (7 9)) (occupied true))
                                    (edge .95 (x (7 9)) (occupied false))
                                    ))))
  t)

(defun xs nil
  (smooth)
  (d 0)
  (g)
  nil
  )

; Noisy line smoothing
(defun smooth2 nil
  (init)
  (new-type 'c4 :numeric t :discrete nil :min 0 :max 9)
  (predicate 'edge :world 'open :perception t :arguments '((x c4)))
  (predicate 'edge2 :world 'open :arguments '((x c4)))

  (conditional 'direct
               :conditions '((edge (x (x))))
               :actions '((edge2 (x (x))))
               )
  (conditional 'smooth-right-1
               :conditions '((edge (x (x))))
               :actions '((edge2 (x (x .1))))
               :function .5
               )
  (conditional 'smooth-left-1
               :conditions '((edge (x (x))))
               :actions '((edge2 (x (x -.1))))
               :function .5
               )
  (conditional 'smooth-right-2
               :conditions '((edge (x (x))))
               :actions '((edge2 (x (x .2))))
               :function .25
               )
  (conditional 'smooth-left-2
               :conditions '((edge (x (x))))
               :actions '((edge2 (x (x -.2))))
               :function .25
               )
  (conditional 'smooth-right-3
               :conditions '((edge (x (x))))
               :actions '((edge2 (x (x .3))))
               :function .1
               )
  (conditional 'smooth-left-3
               :conditions '((edge (x (x))))
               :actions '((edge2 (x (x -.3))))
               :function .1
               )
  (conditional 'smooth-right-4
               :conditions '((edge (x (x))))
               :actions '((edge2 (x (x .4))))
               :function .05
               )
  (conditional 'smooth-left-4
               :conditions '((edge (x (x))))
               :actions '((edge2 (x (x -.4))))
               :function .05
               )

; edge
  (setq perceive-list '((perceive '((edge .05 (x (0 2)))
                                    (edge .95 (x (2 4.4)))
                                    (edge .05 (x (4.4 4.6)))
                                    (edge .95 (x (4.6 7)))
                                    (edge .05 (x (7 9)))))))
  )

(defun xs2 nil
  (smooth2)
  (d 0)
  (pwm)
  nil
  )

; Noisy line smoothing
(defun smooth3 nil
  (init)
  (new-type 'c9 :numeric t :discrete nil :min 0 :max 9)
  (predicate 'edge :world 'open :perception t :arguments '((x c9) (occupied Boolean %)))
  (predicate 'edge2 :world 'closed :arguments '((x c9)))

;  (conditional 'smooth-1-r
;               :conditions '((edge (x (x)) (occupied (o))))
;               :actions '((edge (x (x .1)) (occupied (o)))
;               :function .2
;              )
;  (conditional 'smooth-1-l
;               :conditions '((edge (x (x)) (occupied (o))))
;               :actions '((edge (x (x -.1)) (occupied (o))))
;               :function .2
;              )

  (conditional 'smooth-2-r
               :conditions '((edge (x (x)) (occupied (o))))
               :actions '((edge (x (x .2)) (occupied (o))))
               :function .1
              )
  (conditional 'smooth-2-l
               :conditions '((edge (x (x)) (occupied (o))))
               :actions '((edge (x (x -.2)) (occupied (o))))
               :function .1
              )

  (conditional 'smooth-3-r
               :conditions '((edge (x (x)) (occupied (o))))
               :actions '((edge (x (x .3)) (occupied (o))))
               :function .05
              )
  (conditional 'smooth-3-l
               :conditions '((edge (x (x)) (occupied (o))))
               :actions '((edge (x (x -.3)) (occupied (o))))
               :function .05
              )

  (conditional 'smooth-4-r
               :conditions '((edge (x (x)) (occupied (o))))
               :actions '((edge (x (x .4)) (occupied (o))))
               :function .025
              )
  (conditional 'smooth-4-l
               :conditions '((edge (x (x)) (occupied (o))))
               :actions '((edge (x (x -.4)) (occupied (o))))
               :function .025
              )

  (conditional 'result
               :conditions '((edge (x (x)) (occupied true)))
               :actions '((edge2 (x (x))))
               )

;  (conditional 'smooth
;               :condacts '((edge (x (x)))
;                           (edge (x (xo .2))))
;               :function-variable-names '(x xo)
;               :function .9
;               )

; edge
  (setq perceive-list '((perceive '((edge .05 (x (0 2)) (occupied true))
                                    (edge .95 (x (0 2)) (occupied false))
                                    (edge .95 (x (2 4.4)) (occupied true))
                                    (edge .05 (x (2 4.4)) (occupied false))
                                    (edge .05 (x (4.4 4.6)) (occupied true))
                                    (edge .95 (x (4.4 4.6)) (occupied false))
                                    (edge .95 (x (4.6 7)) (occupied true))
                                    (edge .05 (x (4.6 7)) (occupied false))
                                    (edge .05 (x (7 9)) (occupied true))
                                    (edge .95 (x (7 9)) (occupied false))))))
  )

(defun xs3 nil
  (smooth3)
  (d 0)
  (g)
  nil
  )

; Tetris
(defun tetris nil
  (init)
  (new-type 'c4 :numeric t :discrete nil :min 0 :max 4)
  (new-type 'c8 :numeric t :discrete nil :min 0 :max 8)
  (new-type 'c12 :numeric t :discrete nil :min 0 :max 12)
  (predicate 'tetromino :world 'closed :arguments '((x c4) (y c4)))
  (predicate 'occupied :world 'closed :arguments '((x c8) (y c12)))
  (predicate 'free :world 'closed :arguments '((x c8) (y c12)))
  (predicate 'left :world 'closed :arguments '())

;  (conditional 'rotate-90
;               :conditions '((tetromino (x (x)) (y (y))))
;               :actions '((tetromino (x (x (:from y :coefficient -1 :offset 4))) (y (y (:from x)))))
;               )

;  (conditional 'z-space
;               :conditions '((occupied (x (x)) (y (y)))
;                             (occupied (x (x 1)) (y (y 1)))
;                             (occupied (x (x 2)) (y (y 1)))
;                             (occupied - (x (x)) (y (y -1)))
;                             (occupied - (x (x 1)) (y (y)))
;                             (occupied - (x (x 2)) (y (y)))
;                             )
;               :actions '((free (x (x)) (y (y))))
;               )

;  (conditional 'add-object
;               :conditions '((tetromino (x (x)) (y (y))))
;               :actions '((occupied (x (x 2)) (y (y 4))))
;               )

  (conditional 'left-of-1
               :conditions '((tetromino (x (0 1)) (y (y))))
               :actions '((left))
               )

; Z tetrimino
  (evidence '((tetromino (x (1/2 5/2)) (y 1))
              (tetromino (x (3/2 7/2)) (y 2))
              )
            )

; Board with bottom row filled and one gap of two in row above
  (evidence '((occupied (x (0 8)) (y 11))
              (occupied (x (0 2)) (y 10))
              (occupied (x (4 8)) (y 10))
              )
            )
  )

(defun xt nil
  (tetris)
  (d 0)
  nil
  )

; Program to test filters (generalization on constant tests)
(defun filter nil
  (init)
  (new-type 'c4 :numeric t :discrete nil :min 0 :max 4)
  (predicate 'object :world 'closed :arguments '((x c4) (y c4 !) (z c4)))

  (conditional 'test-filter
               :conditions '((object (x (x (:filter ((1 3) .1 0) (3 .2 0)))) (y (y (:filter ((1 3) .4 1.1) (3 .6 1.2)))) (z (z)))
                             (object (x (:filter ((1 2) 1 0))) (y (:filter (3 .4 .2) (2 .3 .5))))
                             )
               )

  (evidence '((object 2 (x (0 4)) (y (0 4)) (z (0 4)))))
  )

; 3D mental imagery
(defun 3dmt nil
  (init)
  (new-type 'c :numeric t :discrete nil :min 0 :max 7)
  (new-type 'd :numeric t :discrete t :min 0 :max 10)
  (predicate 'field :world 'closed :arguments '((ts d) (x c) (y c) (z c)))
  (predicate 'overlap :world 'closed :arguments '((os d) (x c) (y c) (z c)))
  (predicate 'collision :world 'closed :arguments '((os d) (value Boolean !)))
  (predicate 'union :world 'closed :arguments '((x c) (y c) (z c)))
  (predicate 'left-edge :world 'closed :arguments '((x c) (y c) (z c)))

  (setq post-d '((ppfn 'field) (ppfn 'overlap) (ppfn 'collision) (ppfn 'union) (ppfn 'left-edge)))

  ; Rotate Z tetromino in 0 and add it to 3, shifting it 2 down so overlaps slightly with original z
  (conditional 'add-rotate-shift-3
               :conditions '((field (ts 0) (x (x)) (y (y)) (z (z))))
               :actions '((field (ts 3) (x (y (:coefficient -1 :offset 4))) (y (x (:offset 2))) (z (z)))
                          )
               )
  
  ; Scale Z tetronimo and add it to 4, shifting it to the right
  (conditional 'add-invert-scale-shift-4
               :conditions '((field (ts 0) (x (x)) (y (y)) (z (z))))
               :actions '((field (ts 4) (x (x (:coefficient -1/2 :offset 6))) (y (y)) (z (z)))
                          )
               )

  ; Delete the tetromino in 1
  (conditional 'delete-1
               :actions '((field - (ts 1) (x (x)) (y (y)) (z (z)))
                          )
               )

  ; Compute overlap
  (conditional 'overlap-0-2
               :conditions '((field (ts 0) (x (x)) (y (y)) (z (z)))
                             (field (ts 2) (x (x)) (y (y)) (z (z)))
                             )
               :actions '((overlap (os 0) (x (x)) (y (y)) (z (z)))
                          )
               )

  ; Compute overlap
  (conditional 'overlap-0-3
               :conditions '((field (ts 0) (x (x)) (y (y)) (z (z)))
                             (field (ts 3) (x (x)) (y (y)) (z (z)))
                             )
               :actions '((overlap (os 1) (x (x)) (y (y)) (z (z)))
                          )
               )

  ; Compute overlap
  (conditional 'overlap-2-3
               :conditions '((field (ts 2) (x (x)) (y (y)) (z (z)))
                             (field (ts 3) (x (x)) (y (y)) (z (z)))
                             )
               :actions '((overlap (os 2) (x (x)) (y (y)) (z (z)))
                          )
               )

  ; Determine if there is any collision from overlap
  (conditional 'collision
               :conditions '((overlap (os (o)) (x (x)) (y (y)) (z (z))))
               :actions '((collision (os (o)) (value true)))
               )

  ; Compute union of all planes in field
  (conditional 'union
               :conditions '((field (ts (ts)) (x (x)) (y (y)) (z (z))))
               :actions '((union (x (x)) (y (y)) (z (z))))
               )

  ; Detect left edge of unioned image
  (conditional 'left-edge
              :conditions '((union (x (x)) (y (y)) (z (z)))
                            (union - (x (x (:offset -.0001))) (y (y)) (z (z)))
                            )
              :actions '((left-edge (x (x)) (y (y)) (z (z))))
              )

  ; Three Z tetriminos
  (evidence '((field (ts 0) (x (1/2 5/2)) (y 1) (z 1))
              (field (ts 0) (x (3/2 7/2)) (y 2) (z 1))

              (field (ts 1) (x (1/2 5/2)) (y 3) (z 1))
              (field (ts 1) (x (3/2 7/2)) (y 4) (z 1))

              (field (ts 2) (x (1/2 5/2)) (y 5) (z 1))
              (field (ts 2) (x (3/2 7/2)) (y 6) (z 1))

              )
            )
  )

; Naive Bayes gradient descent learning from data files

; Datasets for learning

(defvar dataset-datapaths)
(setq dataset-datapaths
      '(
        ; Simple symbolic concept
        (ad ad "Learn ad.txt")

        ; UCI Balloon datasets
        (a-s balloon "UCI Data Sets/Balloons/adult-stretch.data.txt") ; Adult or Stretch
        (a+s balloon "UCI Data Sets/Balloons/adult+stretch.data.txt") ; Adult and Stretch
        (y-s balloon "UCI Data Sets/Balloons/yellow-small.data.txt") ; Yellow and Small or ? (second clause missing in description)
        (y-s+a-s balloon "UCI Data Sets/Balloons/yellow-small+adult-stretch.data.txt") ; (Yellow and Small) or (Adult and Stretch)

        ; Simple logical tests
        (and logical "and.txt")
        (or logical "or.txt")
        (xor logical "xor.txt")

        ; Object (like in semantic and episodic memories) test
        (simple object "object.txt")
        (simple-test object "object test.txt")
        ))

(defvar dataset-definitions)
(setq dataset-definitions
      '(
        (ad a ((a (symbolic b c)) (d (symbolic e f g h))))
        (balloon inflated ((color (symbolic yellow purple)) (size (symbolic large small))
                          (act (symbolic stretch dip)) (age (symbolic adult child))
                          (inflated (symbolic t f))))
        (logical output ((input1 (symbolic t f)) (input2 (symbolic t f)) (output (symbolic t f))))
        (object concept ((color (symbolic silver brown white)) (legs (discrete 0 5)) (alive (symbolic t f))
                              (mobile (symbolic t f)) (weight (continuous 0 500)) (concept (symbolic walker table dog human))))
        ))

(defun setup-dataset (datapath category &optional unsupervised test)
  (setup-gd datapath test (if test (list category) nil) (if unsupervised '(category) nil))
  (when test
    (setq post-d
          (append `((format trace-stream "~&~%~S: " (best-in-plm (vnp ',category))) (ppvn ',category))
                    post-d))
    )
  t)

; Learn from dataset via gradient descent learning
(defun gdl (train test &optional unsupervised training-cycles trace lr-fraction-sp)
  (let (path-triad definition-triad dataset datapath category definition)
    ; Training
    (setq path-triad (assoc train dataset-datapaths))
    (unless path-triad
      (error "Unknown training dataset version: ~S!" train)
      )
    (setq dataset (cadr path-triad))
    (setq datapath (merge-pathnames (caddr path-triad) dataset-path))
    (setq definition-triad (assoc dataset dataset-definitions))
    (unless definition-triad
      (error "Unknown dataset: ~S!" dataset)
      )
    (setq category (cadr definition-triad))
    (setq definition (caddr definition-triad))
    (when unsupervised
      ; Category needs to go at end of list so doesn't disturb order of data read on line
      (setq definition (append definition `((* category (discrete 0 ,unsup-categories)))))
      )
    (define-data-set definition unsupervised trace)
    (setq learning-rate-fraction-of-smoothing-parameter lr-fraction-sp)
    (setq pre-t `((format trace-stream "~&~%   >>> Training Cycle <<<")
                  (setup-dataset ',datapath ',category ',unsupervised)
                  (setq post-t '((close data-stream)))
                  ))
    (unless (eq (trials training-cycles) interrupt-symbol)
      ; Testing
      (setq pre-t '())
      (format trace-stream "~&~%   >>> Testing <<<")
      (setq path-triad (assoc test dataset-datapaths))
      (unless path-triad
        (error "Unknown testing dataset version: ~S!" test)
        )
      (setq datapath (merge-pathnames (caddr path-triad) dataset-path))
      (setup-dataset datapath category unsupervised t)
      (when (equal (stype-constants (type-from-name category)) '(t f))
        (setq post-t `((close data-stream) (print-gd-test-results '(,category))))
        )
      (trials 1 t)
      (format trace-stream "~&~%") (pcfs)
      )
    )
  )

; Very simple form of distribution learning
(defun simple-gdl (ntypes)
  (init)
  (learn '(:gd))
  (setq learning-rate .001)
  (format trace-stream "Setting learning rate to .001")
  (new-type 'type :numeric t :discrete t :min 0 :max ntypes)
  (predicate 'concept :arguments '((value type %)))
  (setq pre-d '((ppwm 'concept)))
  (setq post-d '((format trace-stream "~&") (pcf 'concept)))
  ; Prior on concept  
  (conditional 'concept
               :condacts '((concept (value (concept))))
               :function-variable-names '(concept)
               :normal 'concept
               :function `((,(/ 1.0 ntypes) *)))
  )

; Return a random number in 0-((length ps) - 1) biased according to ps
(defun br4 (ps)
  (let ((r (random 10))
        (min 0))
    (dotimes (i (length ps))
      (setq min (+ min (nth i ps)))
      (when (< r min) (return i))
      )
    )
  )

; Run times trials according to the distribution in ps
; ps is a list of four numbers, one for each category type
(defun sgdl (ps times)
  (let ((fs (init-vector (length ps) 0))
        tn
        )
    (simple-gdl (length ps))
    (dotimes (i times)
      (setq tn (br4 ps))
      (setf (aref fs tn) (+ (aref fs tn) 1))
      (evidence `((concept (value ,tn))))
      (d 1)
      )
    (dotimes (tt (length ps))
      (setf (aref fs tt) (/ (aref fs tt) (* times 1.0)))
      )
    fs)
  )

; Multiagent 1D Grid
(defun ma-grid2 nil
  (init nil '(a b c))
  (init-operators 'symbols '(left right) t) ; Detect impasses
  (setq pre-run '(
                  )
        )
  (setq pre-d '(
                )
        )
  (setq post-d '((ppfn 'selected)
                 (ppfn 'impasse)
                 (ppfn 'location)
                 )
        )
  (new-type 'c6 :numeric t :discrete t :min 0 :max 6)
  (predicate 'location :world 'closed :arguments '((agent agent) (state state) (x c6 !)))

  ; Select operator
  (conditional 'select-operator
               :conditions '((location (agent (a)) (state 0) (x (x))))
               :actions '((selected (agent (a)) (state 0) (operator (o))))
               :function-variable-names '(a x o)
               :function '((.2 a * left) (.8 a * right)
                           (.8 b * left) (.2 b * right)
                           (.1 c * *)
                           )
               )

  ; Move left
  (conditional 'move-left
               :conditions '((selected (agent (a)) (state 0) (operator left))
                             (location (agent (a)) (state 0) (x (x)))
                             )
               :actions '((location (agent (a)) (state 0) (x (x -1)))
                          )
               )

  ; Move right
  (conditional 'move-right
               :conditions '((selected (agent (a)) (state 0) (operator right))
                             (location (agent (a)) (state 0) (x (x)))
                             )
               :actions '((location (agent (a)) (state 0) (x (x 1)))
                          )
               )

  ; Prefer left for an agent if reach a tie impasse on it
  ; This is to test removal of reflective states with multiple agents
  (conditional 'tie-left-best
               :conditions '((impasse (agent (a)) (state 1) (type tie)))
               :actions '((selected (agent (a)) (state 0) (operator left)))
               :function 1
               )

  (evidence '((location (agent a) (state 0) (x 2))
              (location (agent b) (state 0) (x 3))
              (location (agent c) (state 0) (x 4))
              )
            )
  )

; Test reuse of same variable within a pattern
; Simple test with a single reuse of one variable
(defun vr nil
  (init)
  (predicate 'test :world 'closed :arguments '((a boolean) (b boolean)))
  (conditional 'vrc
               :conditions '((test (a (v)) (b (v))))
               )
  (evidence '((test (a true) (b *))))
  )

; Complex test with multiple reused variables and other variables
(defun vr2 nil
  (init)
  (new-type 'tri :constants '(x y z))
  (predicate 'test :world 'closed :arguments '((a boolean) (b boolean) (c boolean) (d tri) (e tri) (f tri)))
  (conditional 'vrc
               :conditions '((test (a (v)) (b (v)) (c (m)) (d (n)) (e (n)) (f (n))))
               )
  (evidence '((test (a true) (b *) (c false) (d x) (e *) (f *))))
  )

; Test to see if error will be signalled when try to reuse a variable in an action
(defun vr3 nil
  (init)
  (predicate 'test :world 'closed :arguments '((a boolean) (b boolean)))
  (conditional 'vrc
               :actions '((test (a (v)) (b (v))))
               )
  (evidence '((test (a true) (b *))))
  )

; Test for what happens when there is a linear function over the combined variables
(defun vr4 nil
  (init)
  (new-type 'c03 :discrete nil :min 0 :max 3)
  (predicate 'test :world 'closed :arguments '((a c03) (b c03 !)))
  (conditional 'vrc
               :conditions '((test (a (v)) (b (v))))
               )
  (evidence '((test (1 0 3) (a *) (b *))))
  )

; Test use of constants in open-world condacts
(defun oc nil
  (init)
  (predicate 'o :arguments '((a boolean) (b boolean %)))

  (conditional 'oc1
               :condacts '((o (a true) (b (b))))
               :function-variable-names '(b)
               :function-default 1
               :function '((.5 true) (.3 false))
               )

  (conditional 'oc2
               :condacts '((o (a false) (b (b))))
               :function-variable-names '(b)
               :function-default 1
               :function '((.2 true) (.7 false))
               )
  )

; Test selecting expected value
(defun ev nil
  (init)
  (new-type 'ten :numeric t :min 0 :max 10)
  (predicate 'expect1 :world 'closed :arguments '((expect ten %)))
  (predicate 'expect2 :world 'closed :arguments '((expect ten $)))

  (conditional 'expect
               :conditions '((expect1 (expect (e))))
               :actions '((expect2 (expect (e))))
               )

  (evidence '((expect1 (expect *))))
  t)


; Test use of variable offset, apply-coefficient-to-offset and using both filters and an affine
(defun vo nil
  (init)
  (setq pre-run '(
                  )
        )
  (setq pre-d '(
                )
        )
  (setq post-d '(
                 )
        )

  (new-type 'utility :numeric t :discrete t :min 0 :max 10)

  (predicate 'utility :perception t :arguments '((value utility %)))
  (predicate 'combined :arguments '((value utility %)))
  (predicate 'reward :perception t :arguments '((value utility %)))

  ; Variable offset in action
  (conditional 'vo
               :conditions '((utility (value (u)))
                             (reward (value (r)))
                             (combined (value (x 1 (:filter (4 1 .5)))))
                             )
               :actions '((combined (value (u (:offset r :pad 0))))
                          (combined (value (u (:coefficient .5 :offset r :pad 0))))
                          (combined (value (u (:coefficient .5 :offset r :pad 0 :apply-coefficient-to-offset t)))))
               )

  (setq perceive-list '((perceive '((utility (value 3))
                                    (reward (value 2))))))
  t
  )

; Test negative domain values
(defun nd nil
  (init)
  (setq pre-run '(
                  )
        )
  (setq pre-d '(
                )
        )
  (setq post-d '(
                 )
        )

  (new-type 'utility :numeric t :discrete t :min -5 :max 5)

  (predicate 'utility :perception t :arguments '((value utility %)))
  (predicate 'combined :arguments '((value utility %)))
  (predicate 'reward :perception t :arguments '((value utility %)))

  ; Variable offset in action
  (conditional 'vo
               :conditions '((utility (value (u)))
                             (reward (value (r)))
                             )
               :actions '((combined (value (u (:offset r :pad 0))))
                          (combined (value (u (:offset -2 :pad 0))))
                          (combined (value (u (:offset -8 :pad 0 :coefficient .5 :apply-coefficient-to-offset t))))
                          )
               )

  (setq perceive-list '((perceive '((utility (value 1))
                                    (reward (value 3))))))
  )

; 1D Grid for reinforcement learning (RL)

; Return currently selected location
(defun current-location ()
  (let (v)
    (setq v (value-in-state 'location base-level-state 'x))
    (when center-discrete-numeric-on-integer
      (setq v (+ v 1/2))
      )
    v)
  )

; Assign a fixed reward based on location
(defun assign-reward (rewards)
  (let ((cl (current-location)))
    (eval `(perceive (quote ((reward .1 (x *) (value *)) ; Empty WM of any previous rewards
                             (reward (x ,cl) (value ,(aref rewards cl))))))) ; Add reward for current state
    )
  )

; 1D Grid for RL

; Fixed vector of rewards for use in assign-reward
(defparameter rewards7 (vector 0 0 0 0 9 0 0 0))

(defun init-rl-grid7 (learn &optional start load-evidence model-free)
  (init '(left right) nil t) ; center-discrete-numeric-on-integer
;  (setq learning-rate-fraction-of-smoothing-parameter nil)
  (operator-selection 'boltzmann)
  (when learn
    (learn '(:gd))
    (setq perceive-list '((assign-reward rewards7) perceive-list))
    )
  (when (eq learn :dp)
    (setq diachronic-prediction t)
    )

  (setq post-d '((ppfn 'selected)
                 (ppfn 'location)
                 (when diachronic-prediction
                   (ppvn 'location*next)
                   )
                 )
        )

  (setq post-t '((format trace-stream "~&~%PROJECTED FF (EV):~&")
                 (pa 'projectedc nil '((expected u)))
                 (format trace-stream "~&~%Q FF (EV):~&")
                 (pa 'qc nil '((expected q)))
                 (format trace-stream "~&~%REWARD FF (EV):~&")
                 (pa 'rewardc nil '((expected r)))
                 (when diachronic-prediction
                   (when (member 'transition (graph-conditionals cg) :key #'conditional-name)
                     (format trace-stream "~&~%TRANSITION FF:~&")
                     (pa 'transition)
                     )
                   (when (member 'location-prediction (graph-conditionals cg) :key #'conditional-name)
                     (format trace-stream "~&~%LOCATION-PREDICTION FF:~&")
                     (pa 'location-prediction)
                     )
                   )
                 (format trace-stream "~&~%")
                 )
        )

  (new-type 'location :numeric t :discrete t :min 0 :max 8)
  (new-type 'utility :numeric t :discrete t :min 0 :max 10)

  (predicate 'location :world 'closed :arguments '((state state) (x location !)))
  (unless diachronic-prediction
    (predicate (concat-symbols (list 'location prediction-suffix)) :arguments '((state state) (x location %)))
    )
  (predicate 'projected :arguments '((x location) (value utility %)))
  (predicate 'reward :perception t :arguments '((x location) (value utility %)))
  (predicate 'q :arguments '((operator operator) (x location) (value utility %)))

  ; Q value for operator given present state
  (conditional 'qc
               :conditions '((state (state (s)))
                             (location (state (s)) (x (x))))
               :condacts '((q (operator (o)) (x (x)) (value (q))))
               :function-variable-names '(x o q)
               :normal 'q
               :function '((.1 * * *)
                           (1 (0 2) left 0) (0 (0 2) left (1 10)) ; Don't go left from 1 (or 0)
                           (1 (6 8) right 0) (0 (6 8) right (1 10)) ; Don't go right from 6 (or 7)
                           )
               )

  ; Select operator based on Q value
  (conditional 'select-operator
               :conditions '((state (state (s)))
                             (location (state (s)) (x (x)))
                             (q (operator (o)) (x (x)) (value (q (:filter (* 0 .1))))))
               :actions '((selected (state (s)) (operator (o))))
               )

  ; Transition function
  (unless (or model-free automatic-action-models)
    (conditional 'transition
                 :conditions '((state (state (s)))
                               (location (state (s)) (x (x)))
                               (selected (state (s)) (operator (o))))
                 :condacts `((,(concat-symbols (list 'location prediction-suffix)) (state (s)) (x (nx))))
                 :function-variable-names '(x o nx)
                 :normal 'nx
                 :function (if diachronic-prediction
                               '((.125 * * *))
                             '((1 0 left 0) (1 1 left 0) (1 2 left 1) (1 3 left 2) (1 4 left 3) (1 5 left 4) (1 6 left 5) (1 7 left 6)
                               (1 7 right 7) (1 6 right 7) (1 5 right 6) (1 4 right 5) (1 3 right 4) (1 2 right 3) (1 1 right 2) (1 0 right 1))
                             )
                 )
    )

  ; Backup utility to q
  (conditional 'backup
               :conditions `((state (state (s)))
                             (location (state (s)) (x (x)))
                             (selected (state (s)) (operator (o)))
                             (,(concat-symbols (list 'location prediction-suffix)) (state (s)) (x (nx)))
                             (reward (x (nx)) (value (r)))
                             (projected (x (nx)) (value (p))))
               :actions '((q (operator (o)) (x (x)) (value (p (:coefficient .95 :offset r :pad 0 :apply-coefficient-to-offset t))))
                          (projected (x (x)) (value (p (:coefficient .95 :offset r :pad 0 :apply-coefficient-to-offset t)))))
               )

  ; Projected future utility
  (conditional 'projectedc
               :condacts '((projected (x (x)) (value (u))))
               :function-variable-names '(x u)
               :normal 'u
               :function '((.1 * *) (1 0 0) (0 0 (1 10)) (1 4 0) (0 4 (1 10)) (1 7 0) (0 7 (1 10)))
               )

  ; State reward (local)
  (conditional 'rewardc
               :condacts '((reward (x (x)) (value (r))))
               :function-variable-names '(x r)
               :normal 'r
               :function '((1 0 0) (0 0 (1 10)) (1 7 0) (0 7 (1 10)) (.1 (1 7) *))
               )

  ; Move left
  (conditional 'move-left
               :conditions '((state (state (s)))
                             (selected (state (s)) (operator left))
                             (location (state (s)) (x (x))))
               :actions '((location (state (s)) (x (x -1)))
;                          (location - (state (s)) (x (x)))
                          )
               )

  ; Move right
  (conditional 'move-right
               :conditions '((state (state (s)))
                             (selected (state (s)) (operator right))
                             (location (state (s)) (x (x))))
               :actions '((location (state (s)) (x (x 1)))
;                          (location - (state (s)) (x (x)))
                          )
               )

  ; Don't move to 0
  (conditional 'no-zero
               :conditions '((state (state (s)))
                             (location (state (s)) (x 1)))
               :actions '((selected - (state (s)) (operator left)))
               )

  ; Don't move to 7
  (conditional 'no-seven
               :conditions '((location (state (s)) (x 6)))
               :actions '((selected - (state (s)) (operator right)))
               :function 0
               )

  ; Halt when reach location 4
  (conditional 'halt
               :conditions '((location (state 0) (x 4)))
               :actions '((halt))
               )

  (when load-evidence (rle7 start nil))
  nil)

; Brief init
(defun brief-init-rl-grid7 (learn)
  (learn learn)
  (setq center-discrete-numeric-on-integer t)
  )

; Top level function to call for reinforcement learning
; If initial is true, initialize graph
; Start is the starting location in the grid
; Repeat is the number of trials to run
; Model-free determines whether include conditionals for action models
(defun rl-grid7 (learn &optional initial start repeat model-free)
  (if initial
      (init-rl-grid7 learn start (= repeat 0) model-free)
    (brief-init-rl-grid7 learn)
    )
  (if (= repeat 0)
      (d 0)
    (rlr7 start repeat initial))
  )

(defun test-rl-mb-7 ()
  (rl-grid7 :gd t 1 30)
  (format info-stream "~&~%PROJECTED FF (EV):~&")
  (pa 'projectedc nil '((expected u)) info-stream)
  (format info-stream "~&~%Q FF (EV):~&")
  (pa 'qc nil '((expected q)) info-stream)
  (format info-stream "~&~%REWARD FF (EV):~&")
  (pa 'rewardc nil '((expected r)) info-stream)
  (format info-stream "~&~%")
  (print-global-decision-statistics info-stream)
  )
(defun test-rl-dp-7 ()
  (rl-grid7 :dp t 1 35)
  (format info-stream "~&~%PROJECTED FF (EV):~&")
  (pa 'projectedc nil '((expected u)) info-stream)
  (format info-stream "~&~%Q FF (EV):~&")
  (pa 'qc nil '((expected q)) info-stream)
  (format info-stream "~&~%REWARD FF (EV):~&")
  (pa 'rewardc nil '((expected r)) info-stream)
  (format info-stream "~&~%")
  (format info-stream "~&~%TRANSITION FF:~&")
  (pa 'transition nil nil info-stream)
  (print-global-decision-statistics info-stream)
  )
(defun test-rl-mf-7 ()
  (rl-grid7 :dp t 1 40 t)
  (format info-stream "~&~%PROJECTED FF (EV):~&")
  (pa 'projectedc nil '((expected u)) info-stream)
  (format info-stream "~&~%Q FF (EV):~&")
  (pa 'qc nil '((expected q)) info-stream)
  (format info-stream "~&~%REWARD FF (EV):~&")
  (pa 'rewardc nil '((expected r)) info-stream)
  (format info-stream "~&~%")
  (print-global-decision-statistics info-stream)
  )

; Load evidence
(defun rle7 (&optional start continue)
  (unless start (setq start 2))
  (if open-world-wmfns
      (evidence `((location (state 0) (x ,start))
              (projected .1 (x (1 7))) (projected 1 (x 0) (value 0)) (projected 1 (x 7) (value 0))
              (q .1)) continue)
    (evidence `((location (state 0) (x ,start))) continue))
  )

; Continue with new evidence (use this function to explore more evidence, with initial nil)
; Start is the location at which to start (or a list with a sequence of start locations)
; Repeat is the number of times to repeat (list of) start location(s)
; Initial says that this is the first run with these conditionals
(defun rlr7 (&optional start repeat initial)
  (unless repeat (setq repeat 1))
  (when (numberp start) (setq start (list start)))
  (catch 'interrupt-rl
    (dotimes (i repeat)
      (dolist (s start)
        (rle7 s (not initial))
        (format trace-stream "~&~&Start location: ~S" s)
        (when (eq (trials 1 (not initial)) interrupt-symbol)
          (throw 'interrupt-rl interrupt-symbol)
          )
        (setq initial nil)
        )
      )
    )
  )

; 1D Grid for RL

; Fixed vector of rewards for use in assign-reward
(defparameter rewards8 (vector 0 0 0 0 9 0 0 0))

(defun test-rl-print (stream)
  (format stream "~&~%PROJECTED FF (EV):~&")
  (pa 'projected nil '((expected wm-value)) stream)
  (format stream "~&~%Q FF (EV):~&")
  (pa 'q nil '((expected wm-value)) stream)
  (format stream "~&~%REWARD FF (EV):~&")
  (pa 'reward nil '((expected wm-value)) stream)
  (format stream "~&~%")
  )

(defun init-rl-grid8 (learn &optional start load-evidence model-free)
  (init '(left right) nil t) ; center-discrete-numeric-on-integer
;  (setq learning-rate-fraction-of-smoothing-parameter nil)
;  (setq trace-gdl '(projected-c))
  (operator-selection 'boltzmann)
  (when learn
    (learn '(:gd))
    (setq perceive-list '((assign-reward rewards7) perceive-list))
    )
  (when (eq learn :dp)
    (setq diachronic-prediction t)
    )
  (when (eq learn :am)
    (learn '(:am))
    )
  (setq post-d '((ppfn 'selected)
                 (ppfn 'location)
                 (when diachronic-prediction
                   (ppvn 'location*next)
                   )
                 )
        )

  (setq post-t '((test-rl-print trace-stream)
                 (when (and diachronic-prediction
                            (member 'transition (graph-conditionals cg))
                            )
                   (format trace-stream "~&~%TRANSITION FF:~&")
                   (pa (concat-symbols (list 'location- 'selected- 'location prediction-suffix)) nil nil trace-stream)
                   )
                 (format trace-stream "~&~%")
                 )
        )

  (new-type 'location :numeric t :discrete t :min 0 :max 8)
  (new-type 'utility :numeric t :discrete t :min 0 :max 10)

  (predicate 'location :world 'closed :arguments '((state state) (x location !)))
  (unless diachronic-prediction
    (predicate (concat-symbols (list 'location prediction-suffix)) :arguments '((state state) (x location %)))
    )
  (predicate 'projected
             :arguments '((x location) (value utility %))
             :function '((.1 * *) (1 0 0) (0 0 (1 10)) (1 4 0) (0 4 (1 10)) (1 7 0) (0 7 (1 10)))
             )
  (predicate 'projected*next
             :arguments '((x location) (value utility %))
             :function 'projected
             )
  (predicate 'reward :perception t
             :arguments '((x location) (value utility %))
             :function '((1 0 0) (0 0 (1 10)) (1 7 0) (0 7 (1 10)) (.1 (1 7) *))
             )
  (predicate 'q
             :arguments '((x location) (operator operator) (value utility %))
             :function '((.1 * * *)
                         (1 (0 2) left 0) (0 (0 2) left (1 10)) ; Don't go left from 1 (or 0)
                         (1 (6 8) right 0) (0 (6 8) right (1 10)) ; Don't go right from 6 (or 7)
                         )
             )

  ; Function predicates
  (unless automatic-action-models
    (predicate (concat-symbols (list 'location- 'selected- 'location prediction-suffix))
               :arguments '((location location) (operator operator) (next-location location %))
               :function (if diachronic-prediction
                             1
                           '((1 0 left 0) (1 1 left 0) (1 2 left 1) (1 3 left 2) (1 4 left 3) (1 5 left 4) (1 6 left 5) (1 7 left 6)
                             (1 7 right 7) (1 6 right 7) (1 5 right 6) (1 4 right 5) (1 3 right 4) (1 2 right 3) (1 1 right 2) (1 0 right 1))
                           )
               )
    )

  ; Q value for operator given present state
  (conditional 'q-c
               :conditions '((state (state (s)))
                             (location (state (s)) (x (x))))
               :condacts '((q (operator (o)) (x (x)) (value (q))))
               )

  ; Select operator based on Q value
  (conditional 'select-operator
               :conditions '((state (state (s)))
                             (location (state (s)) (x (x)))
                             (q (operator (o)) (x (x)) (value (q (:filter (* 0 .1))))))
               :actions '((selected (state (s)) (operator (o))))
               )

  ; Transition function
  (unless (or model-free automatic-action-models)
    (conditional 'transition
                 :conditions '((state (state (s)))
                               (location (state (s)) (x (x)))
                               (selected (state (s)) (operator (o))))
                 :condacts `((,(concat-symbols (list 'location prediction-suffix)) (state (s)) (x (nx)))
                             (,(concat-symbols (list 'location- 'selected- 'location prediction-suffix)) (location (x)) (operator (o)) (next-location (nx))))
                 )
    )

  ; Backup utility to projected
  (conditional 'backup-projected
               :conditions `((state (state (s)))
                             (location (state (s)) (x (x)))
                             (selected (state (s)) (operator (o)))
                             (,(concat-symbols (list 'location prediction-suffix)) (state (s)) (x (nx)))
                             (reward (x (nx)) (value (r)))
                             (projected*next (x (nx)) (value (p))))
               :actions '((projected (x (x)) (value (p (:coefficient .95 :offset r :pad 0 :apply-coefficient-to-offset t)))))
               )

  ; Backup utility to q
  (conditional 'backup-q
               :conditions `((state (state (s)))
                             (location (state (s)) (x (x)))
                             (selected (state (s)) (operator (o)))
                             (,(concat-symbols (list 'location prediction-suffix)) (state (s)) (x (nx)))
                             (reward (x (nx)) (value (r)))
                             (projected*next (x (nx)) (value (p))))
               :actions '((q (operator (o)) (x (x)) (value (p (:coefficient .95 :offset r :pad 0 :apply-coefficient-to-offset t)))))
               )

  ; Move left
  (conditional 'move-left
               :conditions '((state (state (s)))
                             (selected (state (s)) (operator left))
                             (location (state (s)) (x (x))))
               :actions '((location (state (s)) (x (x -1)))
                          )
               )

  ; Move right
  (conditional 'move-right
               :conditions '((state (state (s)))
                             (selected (state (s)) (operator right))
                             (location (state (s)) (x (x))))
               :actions '((location (state (s)) (x (x 1)))
                          )
               )

  ; Don't move to 0
  (conditional 'no-zero
               :conditions '((state (state (s)))
                             (location (state (s)) (x 1)))
               :actions '((selected - (state (s)) (operator left)))
               )

  ; Don't move to 7
  (conditional 'no-seven
               :conditions '((state (state (s)))
                             (location (state (s)) (x 6)))
               :actions '((selected - (state (s)) (operator right)))
               )

  ; Halt when reach location 4
  (conditional 'halt
               :conditions '((location (state 0) (x 4)))
               :actions '((halt))
               )

  (if diachronic-prediction
      (setq do-not-learn nil)
    (setq do-not-learn `(transition*function ,(concat-symbols (list 'location prediction-suffix))))
    )

  (when load-evidence (rle8 start nil))
  nil)

; Top level function to call for reinforcement learning
; If initial is true, initialize graph
; Start is the starting location in the grid
; Repeat is the number of trials to run
; Model-free determines whether include conditionals for action models
(defun rl-grid8 (learn &optional initial start repeat model-free)
  (if initial
      (init-rl-grid8 learn start (= repeat 0) model-free)
    (rle8 start nil))
  (if (= repeat 0)
      (d 0)
    (rlr8 start repeat initial))
  )

(defun test-rl-mb ()
  (rl-grid8 :gd t 1 30)
  (test-rl-print info-stream)
  (print-global-decision-statistics info-stream)
  )
(defun test-rl-dp ()
  (rl-grid8 :dp t 1 35)
  (test-rl-print info-stream)
  (format info-stream "~&~%TRANSITION FF:~&")
  (pa (concat-symbols (list 'location- 'selected- 'location prediction-suffix)) nil nil info-stream)
  (print-global-decision-statistics info-stream)
  )
(defun test-rl-am ()
  (rl-grid8 :am t 1 35)
  (test-rl-print info-stream)
  (format info-stream "~&~%TRANSITION FF:~&")
  (pa (predicate-name (graph-action-predicate cg)) nil nil info-stream) ; This way of finding the transition function is fragile
  (print-global-decision-statistics info-stream)
  )
(defun test-rl-mf ()
  (rl-grid8 :dp t 1 40 t)
  (test-rl-print info-stream)
  (print-global-decision-statistics info-stream)
  )

; Load evidence
(defun rle8 (&optional start continue)
  (unless start (setq start 2))
  (evidence `((location (state 0) (x ,start))) continue)
  (if open-world-wmfns
      (evidence `((location (state 0) (x ,start))
                  (projected .1 (x (1 7))) (projected 1 (x 0) (value 0)) (projected 1 (x 7) (value 0))
                  (q .1)) continue)
    (evidence `((location (state 0) (x ,start))) continue))
  )

; Continue with new evidence (use this function to explore more evidence, with initial nil)
; Start is the location at which to start (or a list with a sequence of start locations)
; Repeat is the number of times to repeat (list of) start location(s)
; Initial says that this is the first run with these conditionals
(defun rlr8 (&optional start repeat initial)
  (unless repeat (setq repeat 1))
  (when (numberp start) (setq start (list start)))
  (catch 'interrupt-rl
    (dotimes (i repeat)
      (dolist (s start)
        (rle8 s (not initial))
        (format trace-stream "~&~&Start location: ~S" s)
        (when (eq (trials 1 (not initial)) interrupt-symbol)
          (throw 'interrupt-rl interrupt-symbol)
          )
        (setq initial nil)
        )
      )
    )
  )

; Assign a fixed reward based on location
(defun assign-reward9 (rewards)
  (let ((cl (current-location)))
    (eval `(perceive (quote ((reward .1 (location-x *) (value *)) ; Empty WM of any previous rewards
                             (reward (location-x ,cl) (value ,(aref rewards cl))))))) ; Add reward for current state
    )
  )

; 1D Grid for RL with automatic RL structure generation

(defun init-rl-grid9 (&optional start load-evidence)
  (init '(left right) nil t) ; center-discrete-numeric-on-integer
  (operator-selection 'boltzmann)
  (learn '(:rl :am))
  (setq perceive-list '((assign-reward9 rewards7) perceive-list))
  (setq post-d '((ppfn 'selected)
                 (ppfn 'location)
                 (when diachronic-prediction
                   (ppvn 'location*next)
                   )
                 )
        )

  (setq post-t '((test-rl-print trace-stream)
                 (when (and diachronic-prediction
                            (member 'transition (graph-conditionals cg))
                            )
                   )
                 (format trace-stream "~&~%")
                 )
        )

  (new-type 'location :numeric t :discrete t :min 0 :max 8)

  (predicate 'location :world 'closed :arguments '((state state) (x location !)))

  ; Move left
  (conditional 'move-left
               :conditions '((state (state (s)))
                             (selected (state (s)) (operator left))
                             (location (state (s)) (x (x))))
               :actions '((location (state (s)) (x (x -1)))
                          )
               )

  ; Move right
  (conditional 'move-right
               :conditions '((state (state (s)))
                             (selected (state (s)) (operator right))
                             (location (state (s)) (x (x))))
               :actions '((location (state (s)) (x (x 1)))
                          )
               )

  ; Don't move to 0
  (conditional 'no-zero
               :conditions '((state (state (s)))
                             (location (state (s)) (x 1)))
               :actions '((selected - (state (s)) (operator left)))
               )

  ; Don't move to 7
  (conditional 'no-seven
               :conditions '((state (state (s)))
                             (location (state (s)) (x 6)))
               :actions '((selected - (state (s)) (operator right)))
               )

  ; Halt when reach location 4
  (conditional 'halt
               :conditions '((location (state 0) (x 4)))
               :actions '((halt))
               )

  (when load-evidence (rle8 start nil))
  nil)

; Brief init
(defun brief-init-rl-grid9 ()
  (setq center-discrete-numeric-on-integer t)
  )
; Load evidence
(defun rle9 (&optional start continue)
  (unless start (setq start 2))
  (evidence `((location (state 0) (x ,start))) continue)
  (if open-world-wmfns
      (evidence `((location (state 0) (x ,start))
                  (projected .1 (location-x (1 7))) (projected 1 (location- 0) (value 0)) (projected 1 (location-x 7) (value 0))
                  (q .1)) continue)
    (evidence `((location (state 0) (x ,start))) continue))
  )

; Continue with new evidence (use this function to explore more evidence, with initial nil)
; Start is the location at which to start (or a list with a sequence of start locations)
; Repeat is the number of times to repeat (list of) start location(s)
; Initial says that this is the first run with these conditionals
(defun rlr9 (&optional start repeat initial)
  (unless repeat (setq repeat 1))
  (when (numberp start) (setq start (list start)))
  (catch 'interrupt-rl
    (dotimes (i repeat)
      (dolist (s start)
        (rle9 s (not initial))
        (format trace-stream "~&~&Start location: ~S" s)
        (when (eq (trials 1 (not initial)) interrupt-symbol)
          (throw 'interrupt-rl interrupt-symbol)
          )
        (setq initial nil)
        )
      )
    )
  )

; Top level function to call for reinforcement learning
; If initial is true, initialize graph
; Start is the starting location in the grid
; Repeat is the number of trials to run
; Model-free determines whether include conditionals for action models
(defun rl-grid9 (&optional initial start repeat)
  (if initial
      (init-rl-grid9 start (= repeat 0))
    (brief-init-rl-grid9)
    )
  (if (= repeat 0)
      (d 0)
    (rlr9 start repeat initial))
  )

(defun test-rl-rl ()
  (rl-grid9 t 1 50)
  ; Print to listener
  (format trace-stream "~&~%TRANSITION FF:~&")
  (pa (predicate-name (graph-action-predicate cg))) ; This way of finding the transition function is fragile
  (print-global-decision-statistics trace-stream)
  ; Print to main regression testing window
  (format info-stream "~&~%TRANSITION FF:~&")
  (pa (predicate-name (graph-action-predicate cg)) nil nil info-stream) ; This way of finding the transition function is fragile
  (test-rl-print info-stream)
  (print-global-decision-statistics info-stream)
  )

; Program for 2 stage/step POMDP based in 1D corridor, adapted from what was automatically generated by Nicole's code

; Execute operator with some noise
(defun execute-pomdp-operator nil
  (let ((operator (operator-in-state base-level-state))
        (location (value-in-state 'x base-level-state 'x))
        (rand (random 1.0))
        )
    (when operator
      ; Make correct move 80% of time and no move 20%
      (case operator
        (left (when (< rand .8) (setq location (max (- location 1) 0))))
        (right (when (< rand .8) (setq location (min (+ location 1) 7))))
        )
      ; Add new location to WM and flush operator
      (evidence `((x (x ,location)) (selected 0 (state 0) (operator ,operator))))
      )
    )
  )

(defun init-pomdp nil
  (let ((observation-fn '((0 7 5) (0 7 4) (0 7 3) (0 7 2) (0 7 1) (0 7 0) (.1 7 6) (0.9 7 7)
                          (0 6 4) (0 6 3) (0 6 2) (0 6 1) (0 6 0) (.1 6 7) (.1 6 5) (0.8 6 6)
                          (0 5 7) (0 5 3) (0 5 2) (0 5 1) (0 5 0) (.1 5 6) (.1 5 4) (0.8 5 5)
                          (0 4 7) (0 4 6) (0 4 2) (0 4 1) (0 4 0) (.1 4 5) (.1 4 3) (0.8 4 4)
                          (0 3 7) (0 3 6) (0 3 5) (0 3 1) (0 3 0) (.1 3 4) (.1 3 2) (0.8 3 3)
                          (0 2 7) (0 2 6) (0 2 5) (0 2 4) (0 2 0) (.1 2 3) (.1 2 1) (0.8 2 2)
                          (0 1 7) (0 1 6) (0 1 5) (0 1 4) (0 1 3) (.1 1 2) (.1 1 0) (0.8 1 1)
                          (0 0 7) (0 0 6) (0 0 5) (0 0 4) (0 0 3) (0 0 2) (.1 0 1) (0.9 0 0)))
        (transition-fn '((1 7 7 NONE) (.2 7 7 LEFT) (0.8 7 6 LEFT) (1.0 7 7 RIGHT)
                         (1 6 6 NONE) (.2 6 6 LEFT) (0.8 6 5 LEFT) (.2 6 6 RIGHT) (0.8 6 7 RIGHT)
                         (1 5 5 NONE) (.2 5 5 LEFT) (0.8 5 4 LEFT) (.2 5 5 RIGHT) (0.8 5 6 RIGHT)
                         (1 4 4 NONE) (.2 4 4 LEFT) (0.8 4 3 LEFT) (.2 4 4 RIGHT) (0.8 4 5 RIGHT)
                         (1 3 3 NONE) (.2 3 3 LEFT) (0.8 3 2 LEFT) (.2 3 3 RIGHT) (0.8 3 4 RIGHT)
                         (1 2 2 NONE) (.2 2 2 LEFT) (0.8 2 1 LEFT) (.2 2 2 RIGHT) (0.8 2 3 RIGHT)
                         (1 1 1 NONE) (.2 1 1 LEFT) (0.8 1 0 LEFT) (.2 1 1 RIGHT) (0.8 1 2 RIGHT)
                         (1 0 0 NONE) (1.0 0 0 LEFT) (.2 0 0 RIGHT) (0.8 0 1 RIGHT)))
        (utility-fn '((0.1 7) (0.1 6) (0.1 5) (0.5 4) (1.0 3) (3 2) (1.0 1) (0.5 0)))
        )
        
    (init '(left right none))
    
    (setq pre-d '((pprefs)))
    (setq perceive-list '((execute-pomdp-operator)))
    (setq post-d '((format trace-stream "~&~%   >>> ~S(~S)" (operator-in-state base-level-state) (value-in-state 'x base-level-state 'x))))
    
    (new-type 'location :numeric t :discrete t :min 0 :max 8)
    
    (predicate 'x-1 :arguments '((x location %)))
    (predicate 'x-2 :arguments '((x location %)))
    (predicate 'x-3 :arguments '((x location %)))
    (predicate 'operator-1 :arguments '((name operator)))
    (predicate 'operator-2 :arguments '((name operator)))
    (predicate 'x :perception t :world 'closed :arguments '((state state) (x location !))) ; Actual location

    ; Function predicates
    (predicate 'observation :arguments '((x location) (x-1 location)))
    (predicate 'transition12 :arguments '((x-1 location) (operator operator) (x-2 location)))
    (predicate 'transition23 :arguments '((x-2 location) (operator operator) (x-3 location)))
    
    ; Noise in observing current state
    (CONDITIONAL 'OBSERVATION
                 :CONDITIONS '((X (state 0) (X (X)))) ; True state
                 :CONDACTS '((X-1 (X (X1))) ; Observed state
                             (observation (x (x)) (x-1 (x1))))
                 )
    
    (CONDITIONAL 'TRANSITION-STEP-1
                 :CONDACTS '((X-1 (X (X1)))
                             (X-2 (X (X2)))
                             (OPERATOR-1 (NAME (O)))
                             (transition12 (x-1 (x1)) (operator (o)) (x-2 (x2))))
                 )
    
    (CONDITIONAL 'TRANSITION-STEP-2
                 :CONDACTS '((X-2 (X (X2)))
                             (X-3 (X (X3)))
                             (OPERATOR-2 (NAME (O)))
                             (transition23 (x-2 (x2)) (operator (o)) (x-3 (x3))))
                 )
    
    (CONDITIONAL 'ACCEPTABLE
                 :CONDITIONS '((OPERATOR-1 (NAME (O))))
                 :ACTIONS '((SELECTED (state 0) (OPERATOR (O))))
                 )
    
    (CONDITIONAL 'GOAL-TEST
                 :CONDITIONS '((x (state 0) (x 2)))
                 :ACTIONS '((HALT))
                 )

    ; Function conditionals
    (CONDITIONAL 'OBSERVATION*function
                 :CONDACTS '((observation (x (x)) (x-1 (x1))))
                 :FUNCTION-VARIABLE-NAMES '(X X1)
                 :FUNCTION observation-fn
                 )

    (CONDITIONAL 'TRANSITION-STEP-1*function
                 :CONDACTS '((transition12 (x-1 (x1)) (operator (o)) (x-2 (x2))))
                 :FUNCTION-VARIABLE-NAMES '(X1 X2 O)
                 :FUNCTION transition-fn
                 )

    (CONDITIONAL 'UTILITY-STEP-1*function
                 :CONDACTS '((X-2 (X (X2))))
                 :FUNCTION-VARIABLE-NAMES '(X2)
                 :FUNCTION utility-fn
                 )

    (CONDITIONAL 'TRANSITION-STEP-2*function
                 :CONDACTS '((transition23 (x-2 (x2)) (operator (o)) (x-3 (x3))))
                 :FUNCTION-VARIABLE-NAMES '(X2 X3 O)
                 :FUNCTION transition-fn
                 )

    (CONDITIONAL 'UTILITY-STEP-2*function
                 :CONDACTS '((X-3 (X (X3))))
                 :FUNCTION-VARIABLE-NAMES '(X3)
                 :FUNCTION utility-fn
                 )
    
    (evidence '((x (state 0) (x 6))))
    )
  )

; Single stage POMDP (and, alternatively, random walk) for exploring learning open-world transition function in presence of both action and perception noise
; Learning does not yet work right in the POMDP, but it does for the random walk

; True location in world
(defvar pomdp1-location)

; Perceive results of operator with some noise
; Correct-prob is probability that peak is at correct location
; Correct-mass is how much of the probability mass is at the correct location
(defun perceive-pomdp1-location (&optional correct-prob correct-mass)
  (unless correct-prob (setq correct-prob .8))
  (unless correct-mass (setq correct-mass .8))
  (let ((rand (random 1.0))
        location ; Perceived location
        1-cm
        )
    (setq 1-cm (- 1 correct-mass))
    (setq location pomdp1-location)
    ; Perceive new location with correct-prob of getting right (and otherwise on one side)
    (cond ((= pomdp1-location 0)
           (when (>= rand correct-prob) (setq location 1))
           )
          ((= pomdp1-location 7)
           (when (>= rand correct-prob) (setq location 6))
           )
          (t
           (when (>= rand correct-prob)
             (if (< (random 1.0) .5)
                 (setq location (1- pomdp1-location))
               (setq location (1+ pomdp1-location)))
             )
           )
          )
    ; Zero out all perception for predicate x
    (perceive '((x 0)))
    ; Generate noisy perceptions based on correct-mass
    (perceive `((x ,correct-mass (state 0) (x ,location)))) ; Correct-mass at location
    ; Divide incorrect mass among adjacent locations when they exist
    (cond ((= location 0)
           (perceive `((x ,1-cm (state 0) (x 1))))
           )
          ((= location 7)
           (perceive `((x ,1-cm (state 0) (x 6))))
           )
          (t
           (perceive `((x ,(/ 1-cm 2) (state 0) (x ,(1- location)))
                       (x ,(/ 1-cm 2) (state 0) (x ,(1+ location)))
                       )
                     )
           )
          )
      )
  )

; Execute operator with some noise
(defun execute-pomdp1-operator (&optional correct-prob)
  (unless correct-prob (setq correct-prob .8))
  (let ((operator (operator-in-state base-level-state))
        (rand (random 1.0))
        )
    (when operator
      ; Make correct move action-noise percent of time
      (case operator
        (left (when (< rand correct-prob) (setq pomdp1-location (max (- pomdp1-location 1) 0))))
        (right (when (< rand correct-prob) (setq pomdp1-location (min (+ pomdp1-location 1) 7))))
        )
      )
    )
  )

; Create a random transition function
(defun random-transition-fn (nlocs ops)
  (let (tf ; transition-function
        rv) ; Random vector
    (when center-discrete-numeric-on-integer
      (setq nlocs (+ nlocs 1/2))
      )
    (dotimes (l nlocs)
      (dolist (op ops)
        (setq rv (normalize-vector (random-vector nlocs)))
        (dotimes (next-l nlocs)
          (setq tf (cons (list (aref rv next-l) l op next-l) tf))
          )
        )
      )
    (reverse tf))
  )

; POMDP
; Just execute this init and then run for a number of decisions (or call rd1 to run trials)
; This has not yet been updated for sigma25
(defun init-pomdp1 (&optional learn-transition perception-prob perception-mass action-prob)
  (let ((transition-fn '((1 6 NONE 6) (.2 6 LEFT 6) (0.8 6 LEFT 5) (.2 6 RIGHT 6) (0.8 6 RIGHT 7)
                         (1 5 NONE 5) (.2 5 LEFT 5) (0.8 5 LEFT 4) (.2 5 RIGHT 5) (0.8 5 RIGHT 6)
                         (1 4 NONE 4) (.2 4 LEFT 4) (0.8 4 LEFT 3) (.2 4 RIGHT 4) (0.8 4 RIGHT 5)
                         (1 3 NONE 3) (.2 3 LEFT 3) (0.8 3 LEFT 2) (.2 3 RIGHT 3) (0.8 3 RIGHT 4)
                         (1 2 NONE 2) (.2 2 LEFT 2) (0.8 2 LEFT 1) (.2 2 RIGHT 2) (0.8 2 RIGHT 3)
                         (1 1 NONE 1) (.2 1 LEFT 1) (0.8 1 LEFT 0) (.2 1 RIGHT 1) (0.8 1 RIGHT 2)
                         (1 0 NONE 0) (1 0 LEFT 0) (.2 0 RIGHT 0) (0.8 0 RIGHT 1)))
        (utility-fn '((0.05 7) (0.05 6) (0.05 5) (0.25 4) (.5 3) (1 2) (.5 1) (0.25 0)))
        )
        
    (init '(left right none))
    (setq do-not-learn '(utility)) ; Don't conver utility function over location into frequency of occurrence of location
    (when learn-transition
      (learn '(:gd :open))
      (setq diachronic-prediction t)
      )
    (operator-selection 'boltzmann)
    (setq pomdp1-location 6) ; Intialize true location if not running trials
    (setq pre-t '((setq pomdp1-location 6))) ; Initialize true location on each trial
    (setq pre-run '((format trace-stream "~&~%True location: ~S" pomdp1-location)
                    (when (= pomdp1-location 2) (halt))
                    ))
    (setq perceive-list `((perceive-pomdp1-location ,perception-prob ,perception-mass)))
    (setq action-list `((execute-pomdp1-operator ,action-prob)))
    (setq pre-d '((format trace-stream "~&~%Distribution over next perceived location: ") (ppvn 'x*next)
                  (format trace-stream "~&~%Distribution calculated over current location: ") (ppvn 'x)
                  (format trace-stream "~&") (pprefs)
                  ))
    (setq post-d '((format trace-stream "~&~%Best guess as to current location: ~S" (nonstate-value 'x*selected))
                   (format trace-stream "~&Selected action: ~S" (operator-in-state base-level-state))
;                   (unless (plm-full (node-function (predicate-wm (predicate-from-name 'selected*next))))
;                       (format trace-stream "~&Next action: ~S" (value-in-state 'selected*next 0 'operator)))
                   ))
    (when learn-transition
      (setq post-t (append post-d '((format trace-stream "~&~%Transition function: ") (pcf 'transition*function))))
      )
    
    (new-type 'location :numeric t :discrete t :min 0 :max 8)
    
    (predicate 'x :perception t :arguments '((state state) (x location %)))
    (predicate 'x*selected :world 'closed :arguments '((x location !))) ; Left state off here so that updating it doesn't flush operator
    (unless learn-transition
      (predicate 'x*next :arguments '((state state) (x location %)))
      (predicate 'selected*next :arguments '((state state) (operator operator %)))
      )

    ; Function predicates
    (predicate 'transition :arguments '((x location) (operator operator) (x*next location %)))

    (conditional 'transition-c
                 :condacts '((x (state 0) (x (x1)))
                             (selected*next (state 0) (operator (o)))
                             (x*next (state 0) (x (x2)))
                             (transition (x (x1)) (operator (o)) (x*next (x2)))
                             )
                 )
    
    (conditional 'acceptable
                 :conditions '((selected*next (state 0) (operator (o))))
                 :actions '((selected (state 0) (operator (o))))
                 )

    (conditional 'x*selected
                 :conditions '((x (state 0) (x (x))))
                 :actions '((x*selected (x (x))))
                 )

    ; Function conditionals
        
    (conditional 'utility*function
                 :condacts '((x*next (state 0) (x (x2))))
                 :function-variable-names '(x2)
                 :function utility-fn
                 )

    (conditional 'transition*function
                 :condacts '((transition (x (x1)) (operator (o)) (x*next (x2))))
                 :function-variable-names '(x1 o x2)
                 :normal 'x2
                 :function (if learn-transition
                               (if (eq learn-transition 'random)
                                   (random-transition-fn (stype-max (type-from-name 'location)) (stype-constants (type-from-name 'operator)))
                                 '((.125 * * *)))
                             transition-fn)
                 )

    t)
  )

; Run trials of pomdp1
(defun rd1 (&optional trials learn-transition)
  (unless trials (setq trials 1))
  (init-pomdp1 learn-transition)
  (trials trials)
  )

; Random walk
; Just execute this init and then run for a number of decisions (or call rrw to run trials)
(defun init-rw (&optional learn-transition perception-prob perception-mass action-prob)
  (let ((transition-fn '((1 6 NONE 6) (.2 6 LEFT 6) (0.8 6 LEFT 5) (.2 6 RIGHT 6) (0.8 6 RIGHT 7)
                         (1 5 NONE 5) (.2 5 LEFT 5) (0.8 5 LEFT 4) (.2 5 RIGHT 5) (0.8 5 RIGHT 6)
                         (1 4 NONE 4) (.2 4 LEFT 4) (0.8 4 LEFT 3) (.2 4 RIGHT 4) (0.8 4 RIGHT 5)
                         (1 3 NONE 3) (.2 3 LEFT 3) (0.8 3 LEFT 2) (.2 3 RIGHT 3) (0.8 3 RIGHT 4)
                         (1 2 NONE 2) (.2 2 LEFT 2) (0.8 2 LEFT 1) (.2 2 RIGHT 2) (0.8 2 RIGHT 3)
                         (1 1 NONE 1) (.2 1 LEFT 1) (0.8 1 LEFT 0) (.2 1 RIGHT 1) (0.8 1 RIGHT 2)
                         (1 0 NONE 0) (1 0 LEFT 0) (.2 0 RIGHT 0) (0.8 0 RIGHT 1)))
        )
        
    (init '(left right none))
    (when learn-transition
        (if (eq learn-transition ':am)
            (learn '(:am))
          (progn
            (learn '(:gd))
            (setq diachronic-prediction t)
            ))
        )
    (setq pomdp1-location 6) ; Intialize true location if not running trials
    (setq pre-t '((setq pomdp1-location 6))) ; Initialize true location on each trial
    (setq pre-run '((format trace-stream "~&~%True location: ~S" pomdp1-location)
                    (format trace-stream "~&Perceived location distribution: ") (pppfn 'x)
                    (when (= pomdp1-location 2) (halt))
                    ))
    (setq perceive-list `((perceive-pomdp1-location ,perception-prob ,perception-mass)))
    (setq action-list `((execute-pomdp1-operator ,action-prob)))
    (setq post-run '((format trace-stream "~&~%Distribution calculated over next location: ") (ppvn 'x*next)))
    (setq post-d '((format trace-stream "~&~%Distribution over current location:") (parray 'x t '((constant wm-state 0)))
                   (format trace-stream "~&~%Best guess as to current location: ") (pa 'x*selected)
                   (format trace-stream "~&~%Selected action: ~S" (operator-in-state base-level-state))
                   ))
    (when learn-transition
      (setq post-t (append post-d '((format trace-stream "~&~%Transition function: ") (parray (predicate-name (car (graph-predicates cg))) nil nil trace-stream))))
      )
    
    (new-type 'location :numeric t :discrete t :min 0 :max 8)
    
    (predicate 'x :world 'closed :perception t :arguments '((state state) (x location %)))
    (predicate 'x*selected :world 'closed :arguments '((x location !))) ; Used to capture current best estimate on location for printing

    (unless learn-transition
      (predicate 'x*next :arguments '((state state) (x location %)))
      )
    (unless automatic-action-models
      ; Function predicate
      (predicate 'transition
                 :arguments '((x1 location) (operator operator) (x2 location %))
                 :function (if learn-transition
                               '((.125 * * *))
                             transition-fn))

      (conditional 'transition-c
                   :conditions '((x (state 0) (x (x1)))
                                 (selected (state 0) (operator (o))))
                   :condacts '((x*next (state 0) (x (x2)))
                               (transition (x1 (x1)) (operator (o)) (x2 (x2))))
                   )
      )
    
    (conditional 'acceptable
                 :actions '((selected (state 0) (operator left))
                            (selected (state 0) (operator right))
                            (selected (state 0) (operator none))
                            )
                 )

    (conditional 'x*selected
                 :conditions '((x*next (state 0) (x (x)))
                               )
                 :actions '((x*selected (x (x))))
                 )

    ; The following is necessary to terminate the operator because x*selected doesn't change when we see ourselves in the same location (mostly for NONE)
    (conditional 'reject-selected-operator
                 :conditions '((selected (state 0) (operator (o))))
                 :actions '((selected - (state 0) (operator (o))))
                 )
#|
    ; Function conditionals
    (unless automatic-action-models
      (conditional 'transition*function
                   :condacts '((transition (x1 (x1)) (operator (o)) (x2 (x2))))
                   :function-variable-names '(x1 o x2)
                   :normal 'x2
                   :function (if learn-transition
                                 '((.125 * * *))
                               transition-fn)
                   )
      )
|#
    t)
  )

; Run trials of random walk
(defun rrw (&optional trials learn-transition perception-prob perception-mass action-prob)
  (unless trials (setq trials 1))
  (init-rw learn-transition perception-prob perception-mass action-prob)
  (trials trials)
  )

(defun test-rw-al ()
  (rrw 100 :am .9 .9 .9)
  (format info-stream "~&~%Transition function: ") (parray (predicate-name (car (graph-predicates cg))) nil nil info-stream)
  (print-global-decision-statistics info-stream)
  )

; Test program for impasses
; First get NONE at state 0, then a TIE at state 1, then resolve TIE by selecting operator a,
; then NO-CHANGE on operator a, then obviate the no-change by selection operator b for state 0,
; then apply operator b, and halt.

(defun ti nil
  (init)
  (init-operators 'symbols '(a b) t) ; Detect impasses
  (setq post-d '((ppfn 'selected) (ppfn 'impasse)))

  (predicate 'test :world 'closed :arguments '((state state) (test boolean !)))

  (conditional 'none-tie
               :conditions '((impasse (state 1) (type none)))
               :actions '((selected (state 1) (operator *)))
               :function .1
               )

  (conditional 'resolve-tie
               :conditions '((impasse (state 2) (type tie)))
               :actions '((selected (state 1) (operator a)))
               )

  (conditional 'obviate-no-change
               :conditions '((selected (state 1) (operator a))
                             (impasse (state 2) (type no-change)))
               :actions '((selected (state 0) (operator b)))
               )

  (conditional 'apply-b
               :conditions '((selected (state (s)) (operator b)))
               :actions '((test (state (s)) (test true)))
               )

  (conditional 'halt
               :conditions '((test (state 0) (test true)))
               :actions '((halt))
               )

  (evidence '((test (state 0) (test false))))
  )

; Test program for multiagent impasses
(defun tmi nil
  (init nil 3)
  (init-operators 'symbols '(a b) t) ; Detect impasses
  (setq post-d '((ppfn 'selected) (ppfn 'impasse)))

  (predicate 'test :world 'closed :arguments '((state state) (agent agent) (test boolean !)))

  (conditional 'none-tie
               :conditions '((impasse (state 1) (agent (a)) (type none)))
               :actions '((selected (state 1) (agent (a)) (operator *)))
               :function .1
               )

  (conditional 'resolve-tie
               :conditions '((impasse (state 2) (agent (a (:filter (0 1 0) (2 1 0)))) (type tie)))
               :actions '((selected (state 1) (agent (a)) (operator a)))
               )

  (conditional 'obviate-no-change
               :conditions '((selected (state 1) (agent (a)) (operator a))
                             (impasse (state 2) (agent (a)) (type no-change)))
               :actions '((selected (state 0) (agent (a)) (operator b)))
               )

  (conditional 'apply-b
               :conditions '((selected (state (s)) (agent (a)) (operator b)))
               :actions '((test (state (s)) (agent (a)) (test true)))
               )

  (conditional 'halt
               :conditions '((test (state 0) (agent (a)) (test true)))
               :actions '((halt))
               )

  (evidence '((test (state 0) (agent *) (test false))))
  )

; Test multiple actions
(defun tma nil
  (init)
  (predicate 'test :world 'closed :arguments '((x boolean) (y boolean)))

  (conditional 'test
               :conditions '((test (x (a)) (y (b))))
               :actions '((test (x (a)) (y (b)))
                          (test (x (b)) (y (a))))
               :function .5)
  (evidence '((test (x true) (y false))))
  )

; Test filters with negative results
; Should floor outgoing messages at 0
(defun tf nil
  (init)
  (new-type 'symmetric :numeric t :min -10 :max 10)
  (predicate 'test :world 'closed :arguments '((test symmetric !)))
  (predicate 'act :world 'closed :arguments '((test symmetric !)))

  (conditional 'pass-through
               :conditions '((test (test (t (:filter (* -.5 .1))))))
               :actions '((act (test (t))))
               )

  (conditional 'summarize
               :conditions '((test (test (:filter (* 0 .1)))))
               )

  (conditional 'summarize-1
               :conditions '((test (test (:filter (* -.5 .1)))))
               )

  (conditional 'summarize+1
               :conditions '((test (test (:filter (* .5 .1)))))
               )
  (evidence '((test (test *))))
  )

; Variation on SLAM (simple localization) that uses true perception and diachronic processing to handle representation of two locations

; True location in world
(defvar diachronic-location)
(defvar diachronic-map (vector 'wall 'door1 'none 'none 'door2 'wall))

; Perceive results of operator with some noise
; Correct-prob is probability that peak is at correct location
; Correct-mass is how much of the probability mass is at the correct location
(defun perceive-diachronic-object (&optional correct-prob)
  (unless correct-prob (setq correct-prob 1.0))
  (let ((rand (random 1.0))
        location ; Perceived location
        )
    (setq location diachronic-location)
    ; Perceive new location with correct-prob of getting right (and otherwise on one side)
    (cond ((= diachronic-location 0)
           (when (>= rand correct-prob) (setq location 1))
           )
          ((= diachronic-location 5)
           (when (>= rand correct-prob) (setq location 4))
           )
          (t
           (when (>= rand correct-prob)
             (if (< (random 1.0) .5)
                 (setq location (1- diachronic-location))
               (setq location (1+ diachronic-location)))
             )
           )
          )
    ; Generate object perception
    (perceive `((observed 1 (state 0) (value ,(aref diachronic-map location)))))
    )
  )

; Execute operator with some noise
(defun execute-diachronic-operator (&optional correct-prob)
  (unless correct-prob (setq correct-prob 1))
  (let ((operator (operator-in-state base-level-state))
        (rand (random 1.0))
        )
    (when operator
      ; Make correct move action-noise percent of time
      (case operator
        (left (when (< rand correct-prob) (setq diachronic-location (max (- diachronic-location 1) 0))))
        (right (when (< rand correct-prob) (setq diachronic-location (min (+ diachronic-location 1) 5))))
        )
      )
    )
  )

(defun diachronic-slam (&optional initial-loc perception-prob action-prob attention)
  (init '(left right stay))
  (when attention
    (setq trace-attention t)
    (setq compute-attention t)
    (setq compute-surprise t)
    )
  (setq detect-impasses nil)
  (learn '(:pm :no-normal))
  (new-type 'loc :numeric t :discrete t :min 0 :max 6)
  (new-type 'obj :constants '(wall door1 door2 none))

  (predicate 'location :world 'closed :replace t :arguments '((state state) (value loc %)))
  (predicate 'observed :perception t :arguments '((state state) (value obj %)))

  ; Function predicates
  (predicate 'transition
             :arguments '((loc loc) (operator operator) (locn loc %))
             :learning-rate 0
             :function '((1 5 RIGHT 5) (1 0 LEFT 0) (1 5 STAY 5) (1 4 STAY 4) (1 3 STAY 3) (1 2 STAY 2) (1 1 STAY 1) (1 0 STAY 0) 
                         (0.8 5 LEFT 4) (0.8 4 LEFT 3) (0.8 3 LEFT 2) (0.8 2 LEFT 1) (0.8 1 LEFT 0)
                         (0.8 4 RIGHT 5) (0.8 3 RIGHT 4) (0.8 2 RIGHT 3) (0.8 1 RIGHT 2) (0.8 0 RIGHT 1)
                         (0.2 0 RIGHT 0) (0.2 1 RIGHT 1) (0.2 2 RIGHT 2) (0.2 3 RIGHT 3) (0.2 4 RIGHT 4) 
                         (0.2 1 LEFT 1) (0.2 2 LEFT 2) (0.2 3 LEFT 3) (0.2 4 LEFT 4) (0.2 5 LEFT 5))
             )

  (setq pre-run '((when trace-attention
                    (format trace-stream "~&Perceived surprise function: ~&")
                    (pppfn (predicate-name (car (graph-predicates cg)))) ; Hack leverages that surprise predicate is last created
                    )
                  (format trace-stream "~&~%True location: ~S" diachronic-location)
                  ))
  (setq perceive-list `((perceive-diachronic-object ,perception-prob)))
  (setq action-list `((execute-diachronic-operator ,action-prob)))
  
  (setq pre-d '(
                (format trace-stream "~&~%Distribution over next location: ~&") (ppvn 'location*next)
                ))

  (setq post-d '((format trace-stream "~&~%Distribution over current location: ") (parray 'location nil '((constant wm-state 0)))
;                 (format trace-stream "~&~%Learned map function: ") (parray 'locn-observed) (parray 'locn-observed nil '((argmax obj)))
                 (let ((perception-predicate-name (predicate-name (find-if #'predicate-automated-perception (graph-predicates cg)))))
                       (format trace-stream "~&~%Learned map function: ")
                       (parray perception-predicate-name)
                       (parray perception-predicate-name nil '((argmax wm-value-1)))
                       )
                 (format trace-stream "~&~%Action selected: ") (parray 'selected nil '((constant wm-state 0) (argmax wm-operator)))
                 (format trace-stream "~&~%")
                 (when trace-attention
                   (format trace-stream "~&Learned surprise function: ~&")
                   (ppf (predicate-name (car (graph-predicates cg))) t) ; Hack leverages that surprise predicate is last created
                   )
                 ))

  (conditional 'loc-command-locn ; this conditional for action.
               :conditions '((state (state (s)))
                             (location (state (s)) (value (loc)))
                             (selected (state (s)) (operator (o)))
                             )
               :condacts '((location*next (state (s)) (value (locn)))
                           (transition (loc (loc)) (operator (o)) (locn (locn))))
               )

    (conditional 'acceptable
                 :actions '((selected (state 0) (operator left))
                            (selected (state 0) (operator right))
                            (selected (state 0) (operator stay))
                            )
                 )

    (conditional 'reject
                 :conditions '((selected (state 0) (operator (o))))
                 :actions '((selected - (state 0) (operator (o))))
                 )

    (setq diachronic-location (if initial-loc initial-loc 3))

    (evidence `((location .1 (state 0)) (location .5 (state 0) (value ,diachronic-location))
                (selected (state 0) (operator stay))
                ))
   )


(defun dsl (&optional initial-loc perception-prob action-prob)
  (diachronic-slam initial-loc perception-prob action-prob)
  )

(defun test-slam (&optional attention)
  (diachronic-slam nil nil nil attention)
  (d 300)
;  (format info-stream "~&~%Learned map function: ") (parray 'locn-observed nil nil info-stream) (parray 'locn-observed nil '((argmax obj)) info-stream)
  (format info-stream "~&~%Learned map function: ")
  (let ((perception-predicate-name (predicate-name (find-if #'predicate-automated-perception (graph-predicates cg)))))
    (parray perception-predicate-name nil nil info-stream)
    (parray perception-predicate-name nil '((argmax wm-value-1)) info-stream)
    )
  (print-global-decision-statistics info-stream)
  )

;; TEST SYMBOLIC TYPE EXTENSION
;; CALLING (test-extend-type) CREATES A POS TAGGER MODEL, TRAINS IT WITH WORDS THAT ARE NOT DEFINED AND FINALLY TESTS IT.

; All symbolic
(defun test-extend-type ()
  (pos-tagger-model)
  (train-pos-model)
  (test-pos-model)
)

; With a discrete numeric variable
(defun test-extend-type1 ()
  (pos-tagger-model1)
  (train-pos-model1)
  (test-pos-model1)
)

; With a continuous numeric variable
(defun test-extend-type2 ()
  (pos-tagger-model2)
  (train-pos-model1)
  (test-pos-model1)
)

; Using perception rather than evidence
(defun test-extend-type3 ()
  (pos-tagger-model)
  (train-pos-model3)
  (test-pos-model3)
)

; Define an attribute
(defun define-attribute-pos (attribute value)
  (new-type attribute :constants value)
  (predicate (intern (concatenate 'string (symbol-name attribute)"-PRED"))  :world 'open :perception t :arguments `((,attribute ,attribute %)))
  )

(defun pos-tagger-model ()
  (init)
  (setf extend-type-constants-by-evidence t)
  (define-attribute-pos 'pos '(n v))
  (define-attribute-pos 'prior-pos '(a n))
  (define-attribute-pos 'word '(add be unknown))

  ; Function predicates
  (predicate 'prior-pos-word-pos :arguments '((prior-pos prior-pos %) (word word %) (post-pos pos %)))
  (predicate 'word-pos :arguments '((word word %) (pos pos %)))

  
  (CONDITIONAL 'POS-PRIOR-POS-WORD
               :CONDACTS '(
                           (PRIOR-POS-PRED (PRIOR-POS (PRIOR-POS)))
                           (WORD-PRED (WORD (WORD)))
                           (POS-PRED (POS (POS)))
                           (prior-pos-word-pos (prior-pos (prior-pos)) (word (word)) (post-pos (pos)))
                           )
               )



  (CONDITIONAL 'POS-WORD
               :CONDACTS '(
                           (WORD-PRED (WORD (WORD)))
                           (POS-PRED (POS (POS)))
                           (word-pos (word (word)) (pos (pos)))
                           )
               )

  ; Function conditionals

  (CONDITIONAL 'WORD*function
               :CONDACTS '((WORD-PRED (WORD (WORD))))
               :FUNCTION-VARIABLE-NAMES '(WORD)
               :NORMAL 'WORD
               :FUNCTION 1/3
               )

  (CONDITIONAL 'prior-pos-word-pos*function
               :CONDACTS '(
                           (prior-pos-word-pos (prior-pos (prior-pos)) (word (word)) (post-pos (pos)))
                           )
               :FUNCTION-VARIABLE-NAMES '(PRIOR-POS WORD POS)
               :NORMAL 'POS
               :FUNCTION 1/2
               )

  (CONDITIONAL 'word-pos*function
               :CONDACTS '((word-pos (word (word)) (pos (pos))))
               :FUNCTION-VARIABLE-NAMES '(WORD POS)
               :NORMAL 'POS
               :FUNCTION '((0.6 ADD V) (0.4 ADD N) (0.9 UNKNOWN N) (0.1 UNKNOWN V) (0.1 BE N) (0.9 BE V))
               )

  )

(defun train-pos-model nil
  (learn '(:gd))

  ;Introduce word "HAVE"
  (perceive '((POS-PRED (POS N)) (PRIOR-POS-PRED (PRIOR-POS A)) (WORD-PRED (WORD HAVE))) t)
  (d 1)
  (format trace-stream "~&") (pcfs)

  ;NOTHING NEW IS INTRODUCED
  (perceive '((POS-PRED (POS V)) (PRIOR-POS-PRED (PRIOR-POS N)) (WORD-PRED (WORD HAVE))) t)
  (d 1)
  (format trace-stream "~&") (pcfs)
  
  ;INTRODUCE word "LET" and pos "A"
  (perceive '((POS-PRED (POS A)) (PRIOR-POS-PRED (PRIOR-POS A)) (WORD-PRED (WORD LET))) t)
  (d 1)
  (format trace-stream "~&") (pcfs)
  )

(defun test-pos-model nil 
  (learn)

  (setq pre-d '((ppwm 'pos-pred)))

  (perceive '((PRIOR-POS-PRED (PRIOR-POS A)) (WORD-PRED (WORD HAVE))) t)
  (d 1)
  )

(defun train-pos-model3 nil
  (learn '(:gd))

  ;Introduce word "HAVE"
  (setq perceive-list '((perceive '((POS-PRED (POS N)) (PRIOR-POS-PRED (PRIOR-POS A)) (WORD-PRED (WORD HAVE))) t)))
  (d 1)
  (format trace-stream "~&") (pcfs)

  ;NOTHING NEW IS INTRODUCED
  (setq perceive-list '((perceive '((POS-PRED (POS V)) (PRIOR-POS-PRED (PRIOR-POS N)) (WORD-PRED (WORD HAVE))) t)))
  (d 1)
  (format trace-stream "~&") (pcfs)
  
  ;INTRODUCE word "LET" and pos "A"
  (setq perceive-list '((perceive '((POS-PRED (POS A)) (PRIOR-POS-PRED (PRIOR-POS A)) (WORD-PRED (WORD LET))) t)))
  (d 1)
  (format trace-stream "~&") (pcfs)
  )

(defun test-pos-model3 nil 
  (learn)

  (setq pre-d '((ppwm 'pos-pred)))

  (setq perceive-list '((perceive '((PRIOR-POS-PRED (PRIOR-POS A)) (WORD-PRED (WORD HAVE))) t)))
  (d 1)
  )


(defun pos-tagger-model1 ()
  (init)
  (setf extend-type-constants-by-evidence t)
  (define-attribute-pos 'pos '(n v))
  (new-type 'prior-pos :numeric t :discrete t :min 0 :max 2)
  (predicate 'prior-pos-pred  :world 'open :perception t :arguments '((value prior-pos %)))
    
  (define-attribute-pos 'word '(add be unknown))

  (CONDITIONAL 'WORD
               :CONDACTS '((WORD-PRED (WORD (WORD))))
               :FUNCTION-VARIABLE-NAMES '(WORD)
               :NORMAL 'WORD
               :FUNCTION '((1/3 *)) 
               )
  


  (CONDITIONAL 'POS-PRIOR-POS
               :CONDACTS '(
                          (PRIOR-POS-PRED (VALUE (PRIOR-POS)))
                          (POS-PRED (POS (POS)))
                          )
              :FUNCTION-VARIABLE-NAMES '(PRIOR-POS POS)
              :NORMAL 'PRIOR-POS
              :FUNCTION '((1/2 * *))
               )
 
  (CONDITIONAL 'POS-WORD
               :CONDACTS '(
                           (WORD-PRED (WORD (WORD)))
                           (POS-PRED (POS (POS)))
                           )
               :FUNCTION-VARIABLE-NAMES '(WORD POS)
               :NORMAL 'POS
               :FUNCTION '((0.6 ADD V) (0.4 ADD N) (0.9 UNKNOWN N) (0.1 UNKNOWN V) (0.1 BE N) (0.9 BE V))
               )

  )

(defun train-pos-model1 nil
  (learn '(:gd))

  ;Introduce word "HAVE"
  (perceive '((POS-PRED (POS N)) (PRIOR-POS-PRED (VALUE 0)) (WORD-PRED (WORD HAVE))) t)
  (d 1)
  ;(pfs)

  ;NOTHING NEW IS INTRODUCED
  (perceive '((POS-PRED (POS V)) (PRIOR-POS-PRED (VALUE 1)) (WORD-PRED (WORD HAVE))) t)
  (d 1)
  ;(pfs)
  
  ;INTRODUCE word "LET" and pos "A"
  (perceive '((POS-PRED (POS A)) (PRIOR-POS-PRED (VALUE 0)) (WORD-PRED (WORD LET))) t)
  (d 1)
  ;(pfs)
  )

(defun test-pos-model1 nil 
  (learn)

  (setq pre-d '((ppwm 'pos-pred)))

  (perceive '((PRIOR-POS-PRED (VALUE 0)) (WORD-PRED (WORD HAVE))) t)
  (d 1)
  )

(defun pos-tagger-model2 ()
  (init)
  (setf extend-type-constants-by-evidence t)
  (define-attribute-pos 'pos '(n v))
  (new-type 'prior-pos :numeric t :min 0 :max 2)
  (predicate 'prior-pos-pred  :world 'open :perception t :arguments '((value prior-pos %)))
    
  (define-attribute-pos 'word '(add be unknown))

  (CONDITIONAL 'WORD
               :CONDACTS '((WORD-PRED (WORD (WORD))))
               :FUNCTION-VARIABLE-NAMES '(WORD)
               :NORMAL 'WORD
               :FUNCTION '((1/3 *)) 
               )
  


  (CONDITIONAL 'POS-PRIOR-POS
               :CONDACTS '(
                          (PRIOR-POS-PRED (VALUE (PRIOR-POS)))
                          (POS-PRED (POS (POS)))
                          )
              :FUNCTION-VARIABLE-NAMES '(PRIOR-POS POS)
              :NORMAL 'PRIOR-POS
              :FUNCTION '((1/2 * *))
               )
 
  (CONDITIONAL 'POS-WORD
               :CONDACTS '(
                           (WORD-PRED (WORD (WORD)))
                           (POS-PRED (POS (POS)))
                           )
               :FUNCTION-VARIABLE-NAMES '(WORD POS)
               :NORMAL 'POS
               :FUNCTION '((0.6 ADD V) (0.4 ADD N) (0.9 UNKNOWN N) (0.1 UNKNOWN V) (0.1 BE N) (0.9 BE V))
               )

  )

; Test incrementally storing graded values in closed-world universal predicates
(defun tg ()
  (init)
  (predicate 'test1 :world 'closed :arguments '((arg boolean)))
  (predicate 'test2 :world 'closed :arguments '((arg boolean)))
  (predicate 'test3 :world 'closed :arguments '((arg boolean)))

  (conditional 'test-graded
               :conditions '((test1 (arg (a))))
               :actions '((test2 (arg (a))))
               )
  (conditional 'test-cond
               :conditions '((test2 (arg (a))))
               )
  (evidence '((test1 .7 (arg true))))
  (d 1)
  (ppfn 'test1 nil 'array)
  (ppfn 'test2 nil 'array)
  (evidence '((test1 - (arg true)) (test1 .2 (arg false))))
  (d 1)
  (ppfn 'test1 nil 'array)
  (ppfn 'test2 nil 'array)
  )

; Test use of exponentiation in a condition
(defun tec ()
  (init)
  (predicate 'test1 :world 'closed :arguments '((arg boolean)))
  (predicate 'test2 :world 'closed :arguments '((arg boolean)))

  (conditional 'test-exponentiate-condition
               :conditions '((test1 ^ (arg (a))))
               :actions '((test2 (arg (a))))
               )

  (evidence '((test1 .2 (arg false)) (test1 .7 (arg true))))
  (d 1)
  (ppfn 'test2 nil 'array)
  )

; Test use of probability matching in a decision
(defun tpm nil
  (init '(a b))
  (operator-selection 'prob-match)
;  (setq trace-wm-changes t)

  ; Function predicates
  (predicate 'operator :arguments '((operator operator %)))

  (conditional 'pmatch
               :conditions '((operator (operator (o))))
               :actions '((selected (state 0) (operator (o))))
               )

  ; Function conditionals
  (conditional 'operator*function
               :condacts '((operator (operator (o))))
               :function-variable-names '(o)
               :function '((.9 a) (.1 b)))
  (d 1)
  (format trace-stream "~&") (parray 'selected nil '((constant wm-state 0) (argmax wm-operator)))
  )

; Test adding a conditional after graph has already been initialized
; Simple linked production
(defun tca ()
  (init)
  (new-type 'id :constants '(i1 i2 i3 i4 i5 i6 i7))
  
  (predicate 'next :world 'closed :arguments '((id id) (value id)))

  (setq post-d '((ppfn 'next nil 'array)))
  
  (conditional 'trans
               :conditions '(
                             (next (id (a)) (value (b)))
                             (next (id (b)) (value (c)))
                             )
               :actions '((next (id (a)) (value (c))))
               )

  (evidence '((next (id i1) (value i2))
              (next (id i2) (value i3))
              ))
  (d 1)

  (conditional 'reverse
               :conditions '(
                             (next (id (a)) (value (b)))
                             )
               :actions '((next (id (b)) (value (a))))
               )
  (d 1)
  t)

; Simple program for early chunking experiments
(defun chunk nil
  (init)
  (learn '(:gd))
  (setq diachronic-prediction t)
  (predicate 'in1 :world 'closed :arguments '((state state) (a boolean) (b boolean !)))
  (predicate 'in2 :world 'closed :arguments '((state state) (a boolean) (b boolean !)))
  (predicate 'out :world 'closed :arguments '((state state) (a boolean) (b boolean !)))

  (conditional 'in1-out
               :conditions '((in1 (state (s)) (a (a)) (b (b))))
               :actions '((out (state (s)) (a (a)) (b (b))))
               )

  (conditional 'in2-out
               :conditions '((in2 (state (s)) (a (a)) (b (b))))
               :actions '((out (state (s)) (a (a)) (b (b))))
               )

  (evidence '((in1 (state 0) (a true) (b false))
              (in2 (state 0) (a false) (b true)))
            )

  (create-chunk (predicate-from-name 'out))
  (pcs)

  t)

; Simple program to test deletion of operator (and not replacing it with anything)
(defun ado nil
  (init '(a b))

  (setq post-d '((format trace-stream "~&~%Selected: ") (parray 'selected nil '((constant wm-state 0) (argmax wm-operator)))))

  (conditional 'acceptable
               :actions '((selected (state 0) (operator a)))
               )

  (conditional 'reject
               :conditions '((selected (state 0) (operator a)))
               :actions '((selected - (state 0) (operator a)))
               )
  t)

(defun ado2 nil
  (init)
  (predicate 'boolean :arguments '((temp boolean)))
  (init-operators 'predicates '(boolean) t)

  (setq post-d '((format trace-stream "~&~%Selected: ") (parray 'selected nil '((constant wm-state 0) (argmax wm-operator)))
                 (format trace-stream "~&~%Impasse: ") (parray 'impasse nil '((max wm-operator) (argmax wm-type)))
                 ))

  (conditional 'acceptable
               :actions '((selected (state 0) (operator 0)))
               )

  (conditional 'reject
               :conditions '((selected (state 0) (operator 0))
                             (impasse (state 1) (type no-change) (operator 0))
                             )
               :actions '((selected - (state 0) (operator 0)))
               )
  t)

(defun ado3 nil
  (init nil '(a b))
  (predicate 'boolean :arguments '((temp boolean)))
  (init-operators 'predicates '(boolean) t)

  (setq post-d '((format trace-stream "~&~%Selected: ") (parray 'selected nil '((constant wm-state 0) (argmax wm-operator)))
                 (format trace-stream "~&~%Impasse: ") (parray 'impasse nil '((max wm-operator) (argmax wm-type)))
                 ))

  (conditional 'acceptable
               :actions '((selected (state 0) (agent a) (operator 0)))
               )

  (conditional 'reject
               :conditions '((selected (state 0) (agent a) (operator 0))
                             (impasse (state 1) (agent a) (type no-change) (operator 0))
                             )
               :actions '((selected - (state 0) (agent a) (operator 0)))
               )
  t)

; Try a closed-world (persistent) condact
(defun pec nil
  (init)
  (new-type 'abc :constants '(a b c))
  (predicate 'owd :perception t :arguments '((state state) (value abc %)))
  (predicate 'cwd :world 'closed :arguments '((state state) (value abc %)))

  (conditional 'ow-cw
               :conditions '((owd (state 0) (value (x))))
               :condacts '((cwd (state 0) (value (x))))
               )
  (perceive '((owd .1 (state 0) (value a)) (owd .3 (state 0) (value b)) (owd .6 (state 0) (value c))))
  t)

; Test perception
(defun tper nil
  (init)

  (setq perceive-list '((perceive '((open (arg true))
                                    (closed (arg false))))))

  (predicate 'open :world 'open :perception t :arguments '((arg boolean %)))
  (predicate 'closed :world 'closed :perception t :arguments '((arg boolean !)))

  (conditional 'perception
               :conditions '((closed (arg (ca))))
               :condacts '((open (arg (oa))))
               :actions '((closed (arg (ca))))
               )
  t)

; Test condition ordering
(defun tco nil
  (init)

  (new-type 'sym :constants '(a b c))
  (new-type 'disc :numeric t :discrete t :min 0 :max 1000)
  (new-type 'cont :numeric t :min 0 :max 1000)

  (predicate 's :world 'closed :arguments '((s sym)))
  (predicate 'd :world 'closed :arguments '((d disc)))
  (predicate 'c :world 'closed :arguments '((c cont)))
  (predicate 'sd :world 'closed :arguments '((s sym) (d disc)))
  (predicate 'sc :world 'closed :arguments '((s sym) (c cont)))
  (predicate 'dc :world 'closed :arguments '((d disc) (c cont)))
  (predicate 'sdc :world 'closed :arguments '((s sym) (d disc) (c cont)))

  (conditional 'c1
               :conditions '((sdc (s (s)) (d (d)) (c (c)))
                             (sc (s (s)) (c (c)))
                             (dc (d (d)) (c (c)))
                             (s (s (s)))
                             )
               :actions '((d (d (d))))
               )
  
  (evidence '((sdc (s a) (d 10) (c 500))
              (sdc (s b) (d 100) (c 100))
              (sdc (s c) (d 40) (c 10))
              (sdc (s a) (d 30) (c 70))
              (sc (s a) (c 500))
              (sc (s b) (c 100))
              (sc (s a) (c 70))
              (dc (d 100) (c 100))
              (dc (d 10) (c 500))
              (dc (d 30) (c 70))
              (s (s a)) (s (s b)) (s (s c))
              )
            )
  t)

; Test sharing in conditions
(defun tcs nil
  (init)
  (predicate 'x :world 'closed :arguments '((a boolean) (b boolean)))
  (conditional 'c1
               :conditions '((x (a true))
                             (x (a false))
                             (x - (a false))
                             (x (a true) (b false))
                             (x (a (a)))
                             (x (b (b)))
                             (x (a (a)) (b (b)))
                             )
               )
  (conditional 'c2
               :conditions '((x (a true))
                             (x (b false))
                             (x - (a false))
                             (x (a true) (b false))
                             (x (a (a)))
                             (x (a (a)))
                             (x (b (a)))
                             (x (a (a)) (b (b)))
                             )
               )
  t)

; Test multiple unique dimensions 
(defun tmud nil
  (init)
  (learn '(:gd))
  (setq post-d '((pa 'y) (terpri) (pcfs)))
  (predicate 'x :perception t :arguments '((a boolean) (b boolean %) (c boolean %)))
  (predicate 'y :world 'closed :arguments '((a boolean) (b boolean !) (c boolean !)))

  ; Function predicates
  (predicate 'z :arguments '((a boolean) (b boolean %) (c boolean %)))

  (conditional 'c1
               :conditions '((x (a (a)) (b (b)) (c (c))))
               :condacts '((z (a (a)) (b (b)) (c (c))))
               :actions '((y (a (a)) (b (b)) (c (c))))
               )

  ; Function conditionals

  (conditional 'z*function
               :condacts '((z (a (a)) (b (b)) (c (c))))
               :function-variable-names '(a b c)
               :normal '(a b)
               :function 1)

  (perceive '((x .1 (a *) (b *) (c *)) (x .7 (a true) (b true) (c true))))
  (d 1)
  t)

; Variant of tmud created to test setting portions of functions to be learned to 0 initially
(defun tmud2 nil
  (init)
  (learn '(:gd))
  (setq post-d '((pa 'y) (terpri) (pcfs)))
  (predicate 'x :perception t :arguments '((a boolean) (b boolean %) (c boolean %)))
  (predicate 'y :world 'closed :arguments '((a boolean) (b boolean !) (c boolean !)))

  ; Function predicates
  (predicate 'z :arguments '((a boolean) (b boolean %) (c boolean %)))

  (conditional 'c1
               :conditions '((x (a (a)) (b (b)) (c (c))))
               :condacts '((z (a (a)) (b (b)) (c (c))))
               :actions '((y (a (a)) (b (b)) (c (c))))
               )

  ; Function conditionals

  (conditional 'z*function
               :condacts '((z (a (a)) (b (b)) (c (c))))
               :function-variable-names '(a b c)
               :normal '(a b)
               :function '((1 * * *) (0 true true true))
               )

  (perceive '((x .1 (a *) (b *) (c *)) (x .7 (a true) (b true) (c true))))
;  (d 1)
  t)

; Test new variable in actions
(defun nav nil
  (init)
  (new-type 'm :numeric t :min 0 :max 10)
  (new-type 'n :numeric t :discrete t :min 0 :max 10)
  (predicate 'x :arguments '((a boolean)))
  (predicate 'y :perception t :arguments '((b m %)))
  (predicate 'z :perception t :arguments '((c n %)))

  (conditional 'nav
               :conditions '((x (a (a))))
               :actions '((y (b (b :explicit)))
                          (z (c (c :explicit)))
                          )
               :function .2
               )

  (when open-world-wmfns
    (evidence '((y .001) (z .001)))
    )
  t)

; Test negated actions for no-normalize predicates
; Should multiply by -1 and add in FAN
(defun tna nil
  (init)
  (predicate 'p :no-normalize t :arguments '((x boolean %)))

  (conditional 'tnp
               :actions '((p (x true))
                          (p (x false))
                          )
               )

  (conditional 'tnn
               :actions '((p - (x true))
                          )
               :function 2
               )
  (d 0)
  (pwm)
  t)

; Test row-major initialization of discrete functions
(defun integer-list (n)
  (let (l)
    (dotimes (i n)
      (setq l (cons (- n i) l))
      )
    l)
  )
(defun trmi nil
  (init)
  (new-type 'large :numeric t :discrete t :min 0 :max 1000)
  (predicate 'x
             :arguments '((a boolean) (b boolean) (c boolean))
             :function '(row-major 8 7 6 5 4 3 2 1))
  (predicate 'y
             :arguments '((a large) (b large))
             :function (cons 'row-major (integer-list 1000000)))
  (conditional 'z
               :conditions '((x (a (a)) (b (b)) (c (c))))
               :function-variable-names '(a b c)
               :function '(row-major 7 6 5 4 3 2 1 8))
  t
  )

; Test within-condition variable equality tests
(defun twve nil
  (init)
  (predicate 'test :world 'closed :arguments '((a boolean) (b boolean)))
  (conditional 'test-c
               :conditions '((test (a (x)) (b (x))))
               )
  (evidence '((test (a true) (b *)) (test (a false) (b true))))
  t
  )

; Test variable inequality tests
(defun twvne nil
  (init)
  (predicate 'test :world 'closed :arguments '((a boolean) (b boolean)))
  (predicate 'test2 :world 'closed :arguments '((a boolean)))
  (predicate 'test3 :world 'closed :arguments '((a boolean)))
  (predicate 'test4 :world 'closed :arguments '((a boolean)))
  (predicate 'test5 :world 'closed :arguments '((a boolean)))

  ; Test within-pattern not-equal
  (conditional 'within
               :conditions '((test (a (a)) (b (b (<> a)))))
               )

  ; Test across-pattern not-equal
  (conditional 'across-condition
               :conditions '((test2 (a (a)))
                             (test4 (a (y (<> a))))
                             )
               :actions '((test5 (a (y))))
               )
  (conditional 'across-action
               :conditions '((test2 (a (a)))
                             )
               :actions '((test3 (a (y (<> a)))))
               )


  (evidence '((test (a true) (b *)) (test (a false) (b true))
              (test2 (a false))
              (test4 (a *))))
  t
  )

; Test creating action model with universal variables
(defun tamuv nil
  (init)
  (learn '(:am))
  (predicate 'test :world 'closed :arguments '((state state) (universal boolean) (unique boolean !))
             :action-function '((1 true true true) (.5 false false false) (.5 false false true)))
  (ig)
  (pcs)
  )

; Test a contextualized offset
(defun tcoff nil
  (init)
;  (setq trace-affine t)
  (new-type 'integer :numeric t :discrete t :min 0 :max 10)
  (predicate 'context :world 'closed :arguments '((context boolean) (a integer)))
  (predicate 'offset :world 'closed :arguments '((context boolean) (a integer)))
  (predicate 'result :world 'closed :arguments '((context boolean) (a integer)))
  (conditional 'tco-c
               :conditions '((context (context (c)) (a (ci)))
                             (offset (context (c)) (a (oi)))
                             )
               :actions '((result (context (c)) (a (ci (:offset oi :coefficient 1/2 :apply-coefficient-to-offset t))))
                          )
               )
  
  (evidence '((context (context true) (a 2)) (context (context false) (a 5))
              (offset (context true) (a 2)) (offset (context false) (a 3))))
  t)

; Test closed-world perception
(defun tcwp nil
  (init)
  (learn '(:pm :am))
  (predicate 'test :world 'closed :perception t :replace t :arguments '((state state) (a boolean %) (b boolean %)))
  (setq perceive-list '((perceive '((test (b true))))))
  (evidence '((test (b true))))
  t)

; Constant test with integrate-universal-within-unique
(defun tiuwu (iuwu)
  (init)
  (setq integrate-universal-in-unique iuwu)
  (predicate 'test :world 'closed :arguments '((state state) (a boolean) (b boolean !)))
  (conditional 'tiuwu
               :conditions '((test (state 0) (a true) (b (b))))
               :actions '((test (state 0) (a false) (b (b))))
               )
  (evidence '((test (state 0) (a true) (b true)) (test (state 0) (a false) (b false))))
  (d 0)
  (ppwm 'test)
  )

(defun run-distributed-negate-single-sentence ()

(distributed-negate)

(setf trace-gdl t)
;single sentence
(evidence '( 
            (Current 1 (word 0)) (Cooccuring-Words 1 (word 0)) (Cooccuring-Words 1 (word 3)) (Cooccuring-Words 1 (word 9)) (Skip-Gram-Words 1 (word 3) (position 0) ) (Skip-Gram-Words 1 (word 9) (position 1)) 
            )
          t) 
(d 1) 


)

(defun run-distributed-negate-two-sentences ()

(distributed-negate)

(setf trace-gdl t)
;two sentences
(evidence '( 
            (Current 1 (word 0)) (Cooccuring-Words 1 (word 0)) (Cooccuring-Words 1 (word 3)) (Cooccuring-Words 1 (word 9)) (Skip-Gram-Words 1 (word 3) (position 0) ) (Skip-Gram-Words 1 (word 9) (position 1)) 
            )
          t) 
(d 1) 
(evidence '( 
            (Current 1 (word 1)) (Cooccuring-Words 1 (word 1)) (Cooccuring-Words 1 (word 3)) (Cooccuring-Words 1 (word 9)) (Skip-Gram-Words 1 (word 3) (position 0) ) (Skip-Gram-Words 1 (word 9) (position 1)) 
            )
          t) 
(d 1) 

)

(defun run-distributed-negate()

(distributed-negate)

(dotimes (i 10)
;first sentence
(evidence '( 
            (Current 1 (word 2)) (Cooccuring-Words 1 (word 2)) (Cooccuring-Words 1 (word 4)) (Cooccuring-Words 1 (word 7))  (Skip-Gram-Words 1 (word 0) (position 0) ) (Skip-Gram-Words 1 (word 4) (position 1)) 
            )
          t) 
(d 1) 
(evidence '( 
            (Current 1 (word 4))  (Skip-Gram-Words 1 (word 2) (position 0) ) (Skip-Gram-Words 1 (word 7) (position 1)) 
            )
          ) 
(d 1) 
(evidence '( 
            (Current 1 (word 7))  (Skip-Gram-Words 1 (word 4) (position 0) ) (Skip-Gram-Words 1 (word 1) (position 1)) 
            )
          ) 
(d 1) 

;second sentence
(evidence '( 
             (Current 1 (word 3))  (Cooccuring-Words 1 (word 3)) (Cooccuring-Words 1 (word 5)) (Cooccuring-Words 1 (word 9))  (Skip-Gram-Words 1 (word 0) (position 0) ) (Skip-Gram-Words 1 (word 5) (position 1) ) 
            )
          t) 
(d 1) 
(evidence '( 
            (Current 1 (word 5))  (Skip-Gram-Words 1 (word 3) (position 0) ) (Skip-Gram-Words 1 (word 9) (position 1)) 
            )
          ) 
(d 1) 
(evidence '( 
            (Current 1 (word 9))  (Skip-Gram-Words 1 (word 5) (position 0) ) (Skip-Gram-Words 1 (word 1) (position 1)) 
            )
          ) 
(d 1) 

;third sentence
(evidence '( 
              (Current 1 (word 2)) (Cooccuring-Words 1 (word 2)) (Cooccuring-Words 1 (word 5)) (Cooccuring-Words 1 (word 6))   (Skip-Gram-Words 1 (word 0) (position 0) ) (Skip-Gram-Words 1 (word 5) (position 1) ) 
            )
          t) 
(d 1) 
(evidence '( 
            (Current 1 (word 5))  (Skip-Gram-Words 1 (word 2) (position 0) ) (Skip-Gram-Words 1 (word 6) (position 1)) 
            )
          ) 
(d 1) 
(evidence '( 
            (Current 1 (word 6))  (Skip-Gram-Words 1 (word 5) (position 0) ) (Skip-Gram-Words 1 (word 1) (position 1)) 
            )
          ) 
(d 1)


;fourth sentence
(evidence '( 
            (Current 1 (word 3))  (Cooccuring-Words 1 (word 3)) (Cooccuring-Words 1 (word 4)) (Cooccuring-Words 1 (word 8))   (Skip-Gram-Words 1 (word 0) (position 0) ) (Skip-Gram-Words 1 (word 4) (position 1) ) 
            )
          t) 
(d 1) 
(evidence '( 
            (Current 1 (word 4))  (Skip-Gram-Words 1 (word 3) (position 0) ) (Skip-Gram-Words 1 (word 8) (position 1)) 
            )
          ) 
(d 1) 
(evidence '( 
            (Current 1 (word 8))  (Skip-Gram-Words 1 (word 4) (position 0) ) (Skip-Gram-Words 1 (word 1) (position 1)) 
            )
          ) 
(d 1)

)

(evidence '( 
            (Test-Word 1 (word 2))  
            )
          t) 
(d 1)



)
(defun distributed-negate ()
  (let (  (environmental-vectors  '((0.2 0 0) (-0.68 0 1) (-0.44 0 2) (-0.57 0 3) (0.87 0 4) 
                   (-0.29 1 0) (-0.66 1 1) (-0.46 1 2) (0.34 1 3) (-0.67 1 4) 
               (0.25 2 0) (-0.76 2 1) (-0.62 2 2) (-0.7 2 3) (0.07 2 4) 
               (-0.79 3 0) (0.57 3 1) (-0.3 3 2) (-0.64 3 3) (0.76 3 4) 
               (0.28 4 0) (-0.07 4 1) (0.22 4 2) (0.52 4 3) (0.69 4 4) 
               (0.22 5 0) (-0.74 5 1) (-0.08 5 2) (-0.23 5 3) (0.45 5 4) 
               (0.16 6 0) (-0.62 6 1) (0.97 6 2) (-0.10 6 3) (0.05 6 4) 
               (-0.30 7 0) (0.74 7 1) (-0.76 7 2) (0.74 7 3) (-0.41 7 4) 
               (-0.36 8 0) (0.39 8 1) (0.47 8 2) (-0.35 8 3) (-0.20 8 4)
               (0.82 9 0) (-0.72 9 1) (-0.69 9 2) (0.44 9 3) (-0.77 9 4) 
               ))
         (sequence-vectors  '( 
                   (0.39 0 0) (-0.4 0 1) (0.07 0 2) (-0.42 0 3) (-0.03 0 4) 
                   (0.35 1 0) (0.78 1 1) (0.97 1 2) (0.85 1 3) (0.52 1 4) 
                   ))        
         
  )
         
  (init)
  (setf fan-constant 0)
  ;(setf debug-init-descendants t)
  (learn '(:gd))
  (setf adaptive-smoothing nil)
  (setf learning-rate 1)
  (setf smoothing-parameter 0.000000000000001)
  (setf gradient-subtract-average nil)
  ;(setf trace-gdl t)
  ;(setf trace-transform t)
  ;(setq do-not-learn '(other-environment before-bigram-environment-to-lexical before-bigram-environment-to-lexical predicate))
  
  (new-type 'local :numeric t :discrete t :min 0 :max 10) 
  (new-type 'environment :numeric t :discrete t :min 0 :max 5) 
  (new-type 'position :numeric t :discrete t :min 0 :max 2)
  
  (predicate 'Cooccuring-Words :no-normalize t :world 'closed :arguments '((word local %)))
  (predicate 'Skip-Gram-Words :world 'closed :arguments '((word local %) (position position)))
  (predicate 'Current :world 'closed :arguments '((word local %)))
  (predicate 'Context-Vector  :arguments '((distributed environment []))) ;should normalize this ; need to have vector here
  (predicate 'Skip-Gram-Matrix :no-normalize t :arguments '((position position %) (distributed environment %) ) ) ;if I don't keep position as a distribution variable, ordering vector is calculated by max rather than sum. Hence,this is not a vector
  (predicate 'Ordering-Vector  :arguments '((distributed environment []))) ;should normalize this ; need to have vector here
  (predicate 'Meaning-Vector  :no-normalize t :arguments '((word local) (distributed environment [])) :function 1 ) ;need to have vector over here ; why making this vector changes the fan node from *sum* to *por* -> node 62

  (predicate 'Current-Environmental-Vector :no-normalize t :arguments '((distributed environment []))) 
  (predicate 'Sentence-Vector :no-normalize t :arguments '((distributed environment []))) 
  ;(predicate 'Environmental-Vectors :no-normalize t :learning-rate 0 :arguments '((word local) (distributed environment)) :function environmental-vectors) 
  ;(predicate 'Sequence-Vectors :no-normalize t :learning-rate 0 :arguments '((position position ) (distributed environment)) :function sequence-vectors) 
  (predicate 'Environmental-Vectors :learning-rate 0 :arguments '((word local) (distributed environment [])) :function environmental-vectors) 
  (predicate 'Sequence-Vectors :learning-rate 0 :arguments '((position position ) (distributed environment [])) :function sequence-vectors) 

  ;these predicates are needed for cosine calculations
  (predicate 'Lexical-Vectors :learning-rate 0 :arguments '( (word local) (distributed environment [])) :function 'meaning-vector )
  (predicate 'Test-Word :world 'closed :arguments '((word local %)))
  (predicate 'l-current :no-normalize t :arguments '((word local %)))

   

   ;if the extraction is done via a constant in the conditional argument for lexical vectors, max operation is applied in FIF nodes and negative values become 0.
   ;Using the predicate test-word with parameterized lexical-vectors arguments (two lexical-arguments: one just for the test word and second for all the lexical vectors
   (conditional 'Cosine-Values
                :conditions '(
                              (Test-Word (word (w)))
                              (Lexical-Vectors (word (w)) (distributed (d)))
                              ;(Lexical-Vectors (word 2) (distributed (d)))
                              (Lexical-Vectors (word (x)) (distributed (d)))
                              )
                :condacts '((l-current (word (x)))
                           )

               )

 
   (conditional 'current-environmental-vector
             
               :conditions '((Current (word (w)))
                             (Environmental-Vectors (word (w)) (distributed (d)))
                             )
               :actions '((Current-Environmental-Vector (distributed (d))))          
               )
                       
  (conditional 'sentence-co-occurence-vector
               :conditions '((Cooccuring-Words (word (w)))
                             (Environmental-Vectors (word (w)) (distributed (d)))
                             )
               :actions '((Sentence-Vector (distributed(d))))            
               )

  (conditional 'negated-co-occurence-for-the-current-word
               :conditions '(
                             (Current-Environmental-Vector (distributed (d)))
                             )
               :actions '((Context-Vector - (distributed(d))))
               )
   
  (conditional 'co-occurence
               :conditions '(
                             (Sentence-Vector (distributed (d)))
                             )
               :actions '((Context-Vector  (distributed(d))))       
               )
   
  (conditional 'skip-gram
               :conditions '((Skip-Gram-Words (word (w)) (position (p)))
                             (Environmental-Vectors (word (w)) (distributed (d)))
                             )
               :actions '((Skip-Gram-Matrix (distributed(d)) (position (p))))                      
               )

  (conditional 'ordering
               :conditions '((Skip-Gram-Matrix (distributed (d)) (position (p)))
                             (Sequence-Vectors (position (p)) (distributed (d)))
                             )
               :actions '((Ordering-Vector (distributed(d))))             
               )

  (conditional 'context
               :conditions '(
                             (Context-Vector (distributed (d)))
                             (Current (word (w)))                           
                             )
               :actions '((Meaning-Vector (word (w)) (distributed (d))))  
               )
  (conditional 'word-order
               :conditions '(
                             (Ordering-Vector (distributed (d)))
                             (Current (word (w)))                           
                             )
               :actions '((Meaning-Vector (word (w)) (distributed (d))))  
               )
  t)  
)



(defun hello-world ()
  (init)
  (defvar foo (write-to-string max-time))
 (format t "WELCOME TO SIGMA.................~S...~&" (second sys:*line-arguments-list*))
  (with-open-file (str "./helout.txt"
		       :direction :output
		       :if-exists :supersede
		       :if-does-not-exist :create)
    (format str foo))
;  (hcl:save-current-session "testsesssave.bin")
  )

(defun hello-world-sk ()
;  (reset-parametes)
  (setf foo (concatenate 'string "..................helloooooo............." (second sys:*line-arguments-list*) "~&"))
  (format t ".....global params are ::: ~S...~&" global-parameters)
  (format t foo)
(with-open-file (str "./helout.txt"
                     :direction :output
                     :if-exists :supersede
                     :if-does-not-exist :create)
  (format str foo))
)
